<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】TODOLIST]]></title>
    <url>%2F2022%2F09%2F01%2FTODOLIST%2F</url>
    <content type="text"><![CDATA[这是一篇发自现在功在将来的TODOLIST。哈哈哈不知道该写啥 每篇文章底下的gitment可以评论，但是我没设置自动初始化，所以…可以在这里留言…(如果你能看到这句话的话…太麻烦了，现在gitment貌似挂了，有啥问题直接发issue或者QQ729320011想换成gitalk也失败了…不搞了…随缘吧gitalk好像好了qwq，大噶在文章下方评论试下吧 2019 Python 机器学习 神经网络/深度学习 计算机视觉(CV) 信息安全]]></content>
      <categories>
        <category>TODOLIST</category>
      </categories>
      <tags>
        <tag>TODOLIST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】大学学习归档]]></title>
    <url>%2F2022%2F09%2F01%2Fmisc-daxueguidang%2F</url>
    <content type="text"><![CDATA[嗯…我先都删了，之后写个爬虫爬我自己文章重新整理下 专业课合集专业课笔记 2018-2019 第一学期2018-2019 第二学期2019-2020 第一学期2019-2020 第二学期2020-2021 第一学期2020-2021 第二学期2021-2022 第一学期2022-2023 第二学期]]></content>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib笔记]]></title>
    <url>%2F2019%2F07%2F28%2Fnote-matplotlib%2F</url>
    <content type="text"></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy笔记]]></title>
    <url>%2F2019%2F07%2F23%2Fnote-numpy%2F</url>
    <content type="text"><![CDATA[NumPynumpy = Numerical + Python 安装啥的我就不写了，因为我装的anaconda，这些东西直接都装好了全文默认import numpy as np 查看版本12import numpy as npprint(np.__version__) 数组numpy围绕ndarrays展开 数组的创建创建一维数组创建方法就是将序列传递给NumPy的array()函数; 你可以传递任何序列（类数组）12345678910a = np.array([0, 1, 2, 3, 4])b = np.array((0, 1, 2, 3, 4))c = np.arange(5)d = np.linspace(0, 2*np.pi, 5)print(a) # &gt;&gt;&gt;[0 1 2 3 4]print(b) # &gt;&gt;&gt;[0 1 2 3 4]print(c) # &gt;&gt;&gt;[0 1 2 3 4]print(d) # &gt;&gt;&gt;[ 0. 1.57079633 3.14159265 4.71238898 6.28318531]print(a[3]) # &gt;&gt;&gt;3 另外 12345678np.zeros((2, 3)) # 函数创建一个填充了0的数组 array([[ 0., 0., 0.], [ 0., 0., 0.]])np.ones((3,4)) # 函数创建一个填充了1的数组np.empty_like(x) # Create an empty matrix with the same shape as xnp.empty((2,3)) # empty函数创建一个数组。它的初始内容是随机的，取决于内存的状态np.full((2,2), 3) # full函数创建一个填充给定值的n * n数组np.eye(3,3) # eye函数可以创建一个n * n矩阵，对角线为1，其他为0np.linspace(0, 10, num=4) # 函数linspace在指定的时间间隔内返回均匀间隔的数字。 例如，下面的函数返回0到10之间的四个等间距数字np.random.random((2,2)) # 要创建一个填充0到1之间随机值的数组 创建多维数组1234567a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]])print(a[2,4]) # &gt;&gt;&gt;25 切片逗号的用法应该是和Python一样的，用逗号分隔维度如果不加冒号：单独取出一列会降维123456print(a[0, 1:4]) # &gt;&gt;&gt;[12 13 14]print(a[1:4, 0]) # &gt;&gt;&gt;[16 21 26]print(a[::2,::2]) # &gt;&gt;&gt;[[11 13 15] # [21 23 25] # [31 33 35]]print(a[:, 1]) # &gt;&gt;&gt;[12 17 22 27 32] 数组信息1234567print(type(a)) # &gt;&gt;&gt;&lt;class 'numpy.ndarray'&gt;print(a.dtype) # &gt;&gt;&gt;int64print(a.size) # &gt;&gt;&gt;25print(a.shape) # &gt;&gt;&gt;(5, 5)print(a.itemsize) # &gt;&gt;&gt;8 每个项占用的字节数print(a.ndim) # &gt;&gt;&gt;2 数组的维数print(a.nbytes) # &gt;&gt;&gt;200 数组中的所有数据消耗掉的字节数 基本操作注意除了最后一个以外，其他都是对对应元素的操作，也就是*不代表矩阵乘法，只是对应元素相乘，a.dot(b)是求内积或点积（一个意思吧）其实a.dot(b)=sum(a*b). 12345678910111213141516a = np.arange(25)a = a.reshape((5, 5))b = np.array([10, 62, 1, 14, 2, 56, 79, 2, 1, 45, 4, 92, 5, 55, 63, 43, 35, 6, 53, 24, 56, 3, 56, 44, 78])b = b.reshape((5,-1)) # Setting to -1 automatically decides the number of colsprint(a + b)print(a - b)print(a * b)print(a / b)print(a ** 2)print(a &lt; b) print(a &gt; b)print(a.dot(b)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748x = np.array([[1,2],[3,4]], dtype=np.float64)y = np.array([[5,6],[7,8]], dtype=np.float64)# Elementwise sum; both produce the array# [[ 6.0 8.0]# [10.0 12.0]]print(x + y)print(np.add(x, y))# Elementwise difference; both produce the array# [[-4.0 -4.0]# [-4.0 -4.0]]print(x - y)print(np.subtract(x, y))# Elementwise product; both produce the array# [[ 5.0 12.0]# [21.0 32.0]]print(x * y)print(np.multiply(x, y))# Elementwise division; both produce the array# [[ 0.2 0.33333333]# [ 0.42857143 0.5 ]]print(x / y)print(np.divide(x, y))# Elementwise square root; produces the array# [[ 1. 1.41421356]# [ 1.73205081 2. ]]print(np.sqrt(x))v = np.array([9,10])w = np.array([11, 12])# Inner product of vectors; both produce 219print(v.dot(w))print(np.dot(v, w))# Matrix / vector product; both produce the rank 1 array [29 67]print(x.dot(v))print(np.dot(x, v))# Matrix / matrix product; both produce the rank 2 array# [[19 22]# [43 50]]print(x.dot(y))print(np.dot(x, y)) 1234567import numpy as npx = np.array([[1,2],[3,4]])print(np.sum(x)) # Compute sum of all elements; prints "10"print(np.sum(x, axis=0)) # Compute sum of each column; prints "[4 6]"print(np.sum(x, axis=1)) # Compute sum of each row; prints "[3 7]" 1234567a = np.array([[0, 0], [1, 1]])print(a)#[[0 0]# [1 1]]print(a.T)#[[0 1]# [0 1]] numpy完整的函数列表https://www.numpy.org.cn/reference/routines/math.html 特殊运算符123456a = np.arange(10)print(a.sum()) # &gt;&gt;&gt;45print(a.min()) # &gt;&gt;&gt;0print(a.max()) # &gt;&gt;&gt;9print(a.cumsum()) # &gt;&gt;&gt;[ 0 1 3 6 10 15 21 28 36 45] 这个大概是求前缀和数组吧 索引12345a = np.arange(0, 100, 10)indices = [1, 5, -1]b = a[indices]print(a) # &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]print(b) # &gt;&gt;&gt;[10 50 90] 布尔屏蔽12345678910import matplotlib.pyplot as plta = np.linspace(0, 2 * np.pi, 50)b = np.sin(a)plt.plot(a,b)mask = b &gt;= 0plt.plot(a[mask], b[mask], 'bo')mask = (b &gt;= 0) &amp; (a &lt;= np.pi / 2)plt.plot(a[mask], b[mask], 'go')plt.show() 做出来的图满足b数组对应&gt;=0，a数组对应&lt;=pi/2 整数数组索引12345678910111213141516171819202122232425262728a = np.array([[1,2], [3, 4], [5, 6]])# An example of integer array indexing.# The returned array will have shape (3,) andprint(a[[0, 1, 2], [0, 1, 0]]) # Prints "[1 4 5]"print(a[[0, 2], [1, 1]]) # [2 6]a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])print(a) # prints "array([[ 1, 2, 3], # [ 4, 5, 6], # [ 7, 8, 9], # [10, 11, 12]])"# Create an array of indicesb = np.array([0, 2, 0, 1])# Select one element from each row of a using the indices in bprint(a[np.arange(4), b]) # Prints "[ 1 6 7 11]"# Mutate one element from each row of a using the indices in ba[np.arange(4), b] += 10print(a) # prints "array([[11, 2, 3], # [ 4, 5, 16], # [17, 8, 9], # [10, 21, 12]]) 布尔数组索引123456789101112131415161718a = np.array([[1,2], [3, 4], [5, 6]])bool_idx = (a &gt; 2) # Find the elements of a that are bigger than 2; # this returns a numpy array of Booleans of the same # shape as a, where each slot of bool_idx tells # whether that element of a is &gt; 2.print(bool_idx) # Prints "[[False False] # [ True True] # [ True True]]"# We use boolean array indexing to construct a rank 1 array# consisting of the elements of a corresponding to the True values# of bool_idxprint(a[bool_idx]) # Prints "[3 4 5 6]"# We can do all of the above in a single concise statement:print(a[a &gt; 2]) # Prints "[3 4 5 6]" 数据类型12345678x = np.array([1, 2]) # Let numpy choose the datatypeprint(x.dtype) # Prints "int64"x = np.array([1.0, 2.0]) # Let numpy choose the datatypeprint(x.dtype) # Prints "float64"x = np.array([1, 2], dtype=np.int64) # Force a particular datatypeprint(x.dtype) # Prints "int64" 广播12345678910111213141516# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = np.empty_like(x) # Create an empty matrix with the same shape as x# Add the vector v to each row of the matrix x with an explicit loopfor i in range(4): y[i, :] = x[i, :] + v# Now y is the following# [[ 2 2 4]# [ 5 5 7]# [ 8 8 10]# [11 11 13]]print(y) 在Python中显式循环会比较慢另一种等价的方法很快速1234567891011121314# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])vv = np.tile(v, (4, 1)) # Stack 4 copies of v on top of each otherprint(vv) # Prints "[[1 0 1] # [1 0 1] # [1 0 1] # [1 0 1]]"y = x + vv # Add x and vv elementwiseprint(y) # Prints "[[ 2 2 4 # [ 5 5 7] # [ 8 8 10] # [11 11 13]]" 看到这差不多不影响使用了后面遇到什么再补充好了 Reference https://www.numpy.org.cn/index.html]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190722]]></title>
    <url>%2F2019%2F07%2F22%2F20190722%2F</url>
    <content type="text"><![CDATA[今天有些难受，有点头疼… 好久没有写这样的文章了..给自己放了一个双休，回来找找同学，聊聊天，开个黑然后我又玩小号虐菜去了…自己原先会玩的几个英雄全改了，瑞兹菲兹啥的，有些难受，青铜局真的容易让人心态爆炸233，我杀就完事了，但队友不会打劣势，只会被滚雪球（我说这个干嘛今天 is study time，又去翻了翻之前同学的Blog，发现大家好像都不大写了…也不知道大家现在都怎么样，都在做些什么我写Blog的习惯已经养成好久了，之前不知道是为了什么，有时候就觉得做了道题，写个题解，似乎挺好，但是自己也不怎么会回头看。而笔记类的Blog就还好，自己如果有忘记的可以回去查一下，但是一些笔记是面向我自己的，别人看来可能会有些乱，跳跃太大之类的…咱也没辙 大一这么快就结束了，感觉自己也有很多地方没有做好，也在看着身边人的变化一年过去，我觉得我变帅了（雾感觉对自己有好处的事情都会去做会去尝试一下，感觉我不是那么功利吧，哪怕不知道能得到什么的事情也是会去做的自己的英语实在是太差了…也有很多没尽到自己的责任这一年也对能力越大，责任越大这句话有了新的理解，有时候被安排上完全本不属于我的事情，表面上答应的很爽，但大家都知道这么热个天，我一个新闻宣传部的还要去管签到…有时候就感觉这句话是承担责任多的人的自勉和安慰，是承担少的人的借口和推脱 有些东西还是不写好…不然说不定就有人翻到这篇Blog了呢 大二加油，感觉事情还是挺多的。]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习练习]]></title>
    <url>%2F2019%2F07%2F17%2Fml-practice%2F</url>
    <content type="text"><![CDATA[本来想着放在笔记后面，后来发现好像问题有点多…决定新开一篇文章来写 hw1https://www.kaggle.com/c/ml2019spring-hw1/overview作业说明 我一开始做了一个非常naive的model，反正分开处理，Python用的也不是很熟练，就当练代码了一开始没用AdaGrad，发现Learning Rate真的很难设置如果数据量小，那么Learning Rate应该大一些，如果数据量大，那就得小一些了，这个都是相对的如果数据本身小，那么初始值就没那么重要，如果本身大的话，那初始值就需要自己手动设置一下了举个第一个的栗子，如果一开始初始值都设成0,12960条数据，一开始得到的Loss就有51361098.87099994，Learning Rate我设成了1e-8，得到的结果还越来越大…当我把数据量调小一点，比如20条这个样子，还是有点用的…Learning Rate = 1e-6，迭代50次大概能得到一个不错的结果…实测1e-9,1e-12时有点用了…我忽然有个大胆的想法…如果前面变化大点后面变化小点是不是很科学，可以飞快接近结果p.s. Python的输出调试真的不好用…不如c++的#define debug(x) cout&lt;&lt;#x&lt;&lt;&quot;=&quot;&lt;&lt;x&lt;&lt;endl，可能我还没get到该技能原来只需要预测PM2.5就行了，那我直接写全得了一开始Loss=4231600.00，最后313187.27500353276 现在我不是很清楚要什么时候结束…所以先直接计次循环了先在这保存一下代码…之后改成AdaGrad果然这个naive的程序得到了private:9.66107 public:8.18926的高分，我觉得以后应该把训练的模块和输出模块分开来写，不然必须训练一次才能输出233第一次训练出来的w和b 12w = [0.02560433358938389, 0.012801930896077247, 0.004710981594648449, 0.005885507375027003, 0.009942499746330985, 0.026670961533262413, -0.0010603121145215564, 0.25976948883940576, 0.6202885065990642]b = 0.01483973260431497 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import numpy as np# read dataff = open('train.csv', 'r', True, 'big5hkscs');data_init = ff.readlines()total_line = len(data_init)-1# total_line = 19total_type = 8data = [[] for i in range(total_type)]# print(data)for i in range(1, total_line+1): # print(i, data_init[i], end=' ') for j in data_init[i].split(',')[3:]: # print(j, end=' ') if(j.startswith("NR")): data[(i-1)%total_type].append(0.0) else: data[(i-1)%total_type].append(float(j)) # print()# print(data)# for i in data:# print(len(i))ff.close()# init model without adagrad# just consider one typelearningrate = 1e-11w = [0 for i in range(9)]b = 0par = [0 for i in range(9)]# data[0]=data[0][:20]# print(data[0])def f(a): # calc y y = b # print(len(a)) for i in range(0, len(a)): y += w[i]*a[i] return ydef LF(): # loss function tot1, tot2 = 0, 0 for i in range(9, len(data[0])-1): tot1 += data[0][i]-f(data[0][i-9: i]) tot2 += (data[0][i]-f(data[0][i-9: i]))**2 return tot1, tot2def getpart(): # get partial w_i,b global w,b,learningrate parw = [0 for i in range(9)] parb = 0 for i in range(9, len(data[0])-1): a = data[0][i-9: i] tmp = data[0][i]-f(a) # print('a = ', a, ' tmp = ', tmp, 'f(a) = ', f(a)) parb += -2*(tmp) for j in range(len(parw)): parw[j] += -2*tmp*a[j] # print(parw, parb) for i in range(9): w[i]=w[i]-learningrate*parw[i] b = b-learningrate*parb# main loopfor i in range(500): loss1, loss2 = LF() print(loss2) getpart() # print(w, b, learningrate, end=' -&gt; ') 其实我觉得浮点数精度带来的误差还是很大的…今天跑不完了，明早起来再跑吧233 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import numpy as np# read dataff = open('train.csv', 'r', True, 'big5hkscs');data_init = ff.readlines()total_line = len(data_init)-1# total_line = 19total_type = 18data = [[] for i in range(total_type)]# print(data)for i in range(1, total_line+1): # print(i, data_init[i], end=' ') for j in data_init[i].split(',')[3:]: # print(j, end=' ') if(j.startswith("NR")): data[(i-1)%total_type].append(0.0) else: data[(i-1)%total_type].append(float(j)) # print()# print(data)# for i in data:# print(len(i))ff.close()# init model without adagrad# just consider one typelearningrate = 1e-9# w = [0 for i in range(9)]# b = 0w = [0.025824524413455778, 0.013532431831135698, 0.006330265404890848, 0.007117255928494381, 0.01912520613272634, 0.031712687701763935, -0.1291674302877186, 0.21741455874560975, 0.7772617955877607]b = 0.02353711727271333par = [0 for i in range(9)]print(data[9])def f(a): # calc y y = b # print(len(a)) for i in range(0, len(a)): y += w[i]*a[i] return ydef LF(): # loss function tot1, tot2 = 0, 0 for i in range(9, len(data[9])-1): tot1 += data[9][i]-f(data[9][i-9: i]) tot2 += (data[9][i]-f(data[9][i-9: i]))**2 return tot1, tot2def getpart(): # get partial w_i,b global w,b,learningrate parw = [0 for i in range(9)] parb = 0 for i in range(9, len(data[9])-1): a = data[9][i-9: i] tmp = data[9][i]-f(a) # print('a = ', a, ' tmp = ', tmp, 'f(a) = ', f(a)) parb += -2*(tmp) for j in range(len(parw)): parw[j] += -2*tmp*a[j] # print(parw, parb) for i in range(9): w[i]=w[i]-learningrate*parw[i] b = b-learningrate*parb# main looptimes = 1000learningrate = 1e-9loss2 = 0while True: lst = loss2 loss1, loss2 = LF() print(loss2) getpart() if abs(lst-loss2) &lt; 0.1: break # print(w, b, learningrate, end=' -&gt; ')learningrate = 1e-10while True: lst = loss2 loss1, loss2 = LF() print(loss2) getpart() if abs(lst-loss2) &lt; 0.1: breaklearningrate = 1e-11while True: lst = loss2 loss1, loss2 = LF() print(loss2) getpart() if abs(lst-loss2) &lt; 0.1: breakprint(w, b)print('----------------------')# read test data &amp; output resultff = open('test.csv', 'r', True, 'big5hkscs')fo = open('ans.csv', 'w', True, 'utf-8')dd = ff.readlines()print('id,value', file=fo)for i in dd: line = i.split(',') # print(line) if(line[1].startswith("PM2.5")): a = [] for j in line[2:]: a.append(float(j)) print(line[0], ',', f(a), file=fo, sep='') 总共跑了大概30min，然后得到了一个结果226303.2859914291，得到的w和b在下面，得到的分数是private:7.29680 public:6.02679，也差不多是我这种乱搞做法的比较好的结果了吧12w = [-0.01196089473848148, -0.0002154942523566853, 0.15614885717614674, -0.18703390611436793, -0.028484991059330843, 0.46031602604586386, -0.5230520726349329, 0.013331313987351568, 1.091108574289711]b = 0.15907341031251657 我发现那个助教做Demo的时候也是计次…AdaGrad 有进步但是不太大private:7.24162 public:5.93032我发现Learning Rate的初始值还是很重要的，不然第一次偏差太大，后面跑回来就比较慢了 我又在这基础上Train了一下，private:7.24797 public:5.92997，分数反而下降了…不解挠头，我好像不知道怎么变得更好了…我觉得吧…可能是多加些参数了，把其他的条件考虑进去再加上二次项 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import numpy as np# read dataff = open('train.csv', 'r', True, 'big5hkscs');data_init = ff.readlines()total_line = len(data_init)-1# total_line = 19total_type = 18data = [[] for i in range(total_type)]# print(data)for i in range(1, total_line+1): # print(i, data_init[i], end=' ') for j in data_init[i].split(',')[3:]: # print(j, end=' ') if(j.startswith("NR")): data[(i-1)%total_type].append(0.0) else: data[(i-1)%total_type].append(float(j)) # print()# print(data)# for i in data:# print(len(i))ff.close()# init model without adagrad# just consider one typelearningrate = 0.02# w = [0 for i in range(9)]# b = 0w = [-0.027453064157575136, -0.023350934972838352, 0.20364257875107225, -0.22111429241618002, -0.054197655604759414, 0.511059787427728, -0.5551156971312344, 0.0029147111942378363, 1.0896194827444017]b = 1.516876275197267par = [0 for i in range(9)]g = [0 for i in range(9)]gb = 0print(data[9])def f(a): # calc y y = b # print(len(a)) for i in range(0, len(a)): y += w[i]*a[i] return ydef LF(): # loss function tot1, tot2 = 0, 0 for i in range(9, len(data[9])-1): tot1 += data[9][i]-f(data[9][i-9: i]) tot2 += (data[9][i]-f(data[9][i-9: i]))**2 return tot1, tot2def getpart(): # get partial w_i,b global w, b, learningrate, g, gb parw = [0 for i in range(9)] parb = 0 for i in range(9, len(data[9])-1): a = data[9][i-9: i] tmp = data[9][i]-f(a) # print('a = ', a, ' tmp = ', tmp, 'f(a) = ', f(a)) parb += -2*(tmp) for j in range(len(parw)): parw[j] += -2*tmp*a[j] for i in range(9): g[i] += parw[i]**2 gb += parb**2 # print(parw, parb) for i in range(9): w[i]=w[i]-learningrate/np.sqrt(g[i])*parw[i] b = b-learningrate/np.sqrt(gb)*parb# main looptimes = 10000for i in range(times): loss1, loss2 = LF() print(loss2) getpart()print(w, b)print('----------------------')# read test data &amp; output resultff = open('test.csv', 'r', True, 'big5hkscs')fo = open('ans.csv', 'w', True, 'utf-8')dd = ff.readlines()print('id,value', file=fo)for i in dd: line = i.split(',') # print(line) if(line[1].startswith("PM2.5")): a = [] for j in line[2:]: a.append(float(j)) print(line[0], ',', f(a), file=fo, sep='') 哇哦 果然，考虑了二次项，就Training了一次，从0开始，虽然得到的loss有249940.5819514999，但是得到的结果就比之前好得多private:7.19917 public:6.21872惊了第二次private:6.64656 public:6.05368，直接过了strong baseline，进前30了…第三次private:6.48045 public:5.98424，嗯，这个作业就先这样吧…继续看看然后搞后面的了 1234567891011# train oncew = [0.038419991693316446, 0.007631560179476181, 0.017121148559214105, 0.008416625938076962, 0.03344269223900898, 0.07485213150840617, 0.02749672696408752, 0.22824357598542835, 0.5376247829222051, -0.0009578224442509027, -5.528884121464584e-05, 0.0015892367969355542, -0.002221411021284927, -0.0005837884778601767, 0.004221860266845362, -0.006797969291691342, -0.00225338003274975, 0.006461549785024542] b = 0.7707164178028746# train twicew = [0.04550231793751899, -0.002754055810508499, 0.01938652727209127, -0.012606727374062035, 0.026644811794796486, 0.08529566547520964, -0.07289173105545857, 0.20945837091642078, 0.6670259504885876, -0.0010213018236748075, 5.8566384278349695e-05, 0.0015977330997915425, -0.0020381249207644136, -0.0005208828351068215, 0.00420797586899282, -0.005646668562707524, -0.0020696412509102606, 0.004923568539656863]b = 0.9254806340743505# train thirdw = [0.04570395973486438, -0.011294077186582839, 0.025386967127299973, -0.029212382678632333, 0.028545066193682748, 0.11101330569370138, -0.14814515409168333, 0.17550209989307616, 0.7622350658920563, -0.0010221349938858725, 0.00015306217718345381, 0.0015709039506438167, -0.0019038640450172112, -0.0005728314281040582, 0.00400234194537975, -0.004792016150808898, -0.001711617920489784, 0.0038067167936126386]b = 1.0625348284097278 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import numpy as np# read dataff = open('train.csv', 'r', True, 'big5hkscs');data_init = ff.readlines()total_line = len(data_init)-1# total_line = 19total_type = 18data = [[] for i in range(total_type)]# print(data)for i in range(1, total_line+1): # print(i, data_init[i], end=' ') for j in data_init[i].split(',')[3:]: # print(j, end=' ') if(j.startswith("NR")): data[(i-1)%total_type].append(0.0) else: data[(i-1)%total_type].append(float(j)) # print()# print(data)# for i in data:# print(len(i))ff.close()# init model without adagrad# just consider one typelearningrate = 1w = [0 for i in range(18)]b = 0g = [0 for i in range(18)]gb = 0# print(data[9])def f(a): # calc y y = b # print(len(a)) for i in range(0, len(a)): y += w[i]*a[i] + w[i+9]*(a[i]**2) return ydef LF(): # loss function tot1, tot2 = 0, 0 for i in range(9, len(data[9])-1): tot1 += data[9][i]-f(data[9][i-9: i]) tot2 += (data[9][i]-f(data[9][i-9: i]))**2 return tot1, tot2def getpart(): # get partial w_i,b global w, b, learningrate, g, gb parw = [0 for i in range(18)] parb = 0 for i in range(9, len(data[9])-1): a = data[9][i-9: i] tmp = data[9][i]-f(a) # print('a = ', a, ' tmp = ', tmp, 'f(a) = ', f(a)) parb += -2*(tmp) for j in range(9): parw[j] += -2*tmp*a[j] parw[j+9] += -2*tmp*a[j]*a[j] for i in range(18): g[i] += parw[i]**2 gb += parb**2 # print(parw, parb) for i in range(18): w[i]=w[i]-learningrate/np.sqrt(g[i])*parw[i] b = b-learningrate/np.sqrt(gb)*parb# main looptimes = 10000for i in range(times): loss1, loss2 = LF() print(loss2) getpart()print(w, b)print('----------------------')# read test data &amp; output resultff = open('test.csv', 'r', True, 'big5hkscs')fo = open('ans.csv', 'w', True, 'utf-8')dd = ff.readlines()print('id,value', file=fo)for i in dd: line = i.split(',') # print(line) if(line[1].startswith("PM2.5")): a = [] for j in line[2:]: a.append(float(j)) print(line[0], ',', f(a), file=fo, sep='') 加了三次方，感觉要Overfitting…哦 结果变得肥肠爆炸… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import numpy as np# read dataff = open('train.csv', 'r', True, 'big5hkscs');data_init = ff.readlines()total_line = len(data_init)-1# total_line = 19total_type = 18data = [[] for i in range(total_type)]# print(data)for i in range(1, total_line+1): # print(i, data_init[i], end=' ') for j in data_init[i].split(',')[3:]: # print(j, end=' ') if(j.startswith("NR")): data[(i-1)%total_type].append(0.0) else: data[(i-1)%total_type].append(float(j)) # print()# print(data)# for i in data:# print(len(i))ff.close()# init model without adagrad# just consider one typelearningrate = 1w = [0 for i in range(27)]b = 0g = [0 for i in range(27)]gb = 0# print(data[9])def f(a): # calc y y = b # print(len(a)) for i in range(9): y += w[i]*a[i] + w[i+9]*(a[i]**2) + w[i+18]*(a[i]**3) return ydef LF(): # loss function tot1, tot2 = 0, 0 for i in range(9, len(data[9])-1): tot1 += data[9][i]-f(data[9][i-9: i]) tot2 += (data[9][i]-f(data[9][i-9: i]))**2 return tot1, tot2def getpart(): # get partial w_i,b global w, b, learningrate, g, gb parw = [0 for i in range(27)] parb = 0 for i in range(9, len(data[9])-1): a = data[9][i-9: i] tmp = data[9][i]-f(a) # print('a = ', a, ' tmp = ', tmp, 'f(a) = ', f(a)) parb += -2*(tmp) for j in range(9): parw[j] += -2*tmp*a[j] parw[j+9] += -2*tmp*a[j]*a[j] parw[j+18] += -2*tmp*(a[j]**3) for i in range(27): g[i] += parw[i]**2 gb += parb**2 # print(parw, parb) for i in range(27): w[i]=w[i]-learningrate/np.sqrt(g[i])*parw[i] b = b-learningrate/np.sqrt(gb)*parb# main looptimes = 10000for i in range(times): loss1, loss2 = LF() print(loss2) getpart()print(w, b)print('----------------------')# read test data &amp; output resultff = open('test.csv', 'r', True, 'big5hkscs')fo = open('ans.csv', 'w', True, 'utf-8')dd = ff.readlines()print('id,value', file=fo)for i in dd: line = i.split(',') # print(line) if(line[1].startswith("PM2.5")): a = [] for j in line[2:]: a.append(float(j)) print(line[0], ',', f(a), file=fo, sep='') hw2https://www.kaggle.com/c/ml2019spring-hw2作业说明 这就是一个Binary Classification，直接用X_train提出的特征就可以了 Probabilistic Generateive Model假设是高斯分布来算的，所以不需要训练，秒出结果，得分也不太高private:0.76047 public:0.76707也不知道是不是我写挂了… 没错是我写挂了，这全是0吧… ps.手写矩阵运算好麻烦啊，虽然也不长，但是种类太多，感觉不如C++方便，可能我都写C++写惯了，抽时间看一下numpy好了 probabilistic_generateive_model.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import numpy as npfrom math import pi, log, expfile_x = open('X_train', 'r')file_y = open('Y_train', 'r')file_xt = open('X_test', 'r')file_yt = open('Y_test', 'w')#x_train = y_train = x_test = []#mu1 = mu2 = sigm = []def deal_data(x): for i in range(0, len(x)): x[i]=x[i].split(',') for j in range(0, len(x[i])): x[i][j]=int(x[i][j])def load_data(): global x_train, y_train, x_test x_train = file_x.readlines()[1:] y_train = file_y.readlines()[1:] x_test = file_xt.readlines()[1:] deal_data(x_train) deal_data(y_train) deal_data(x_test)def mult(a, b): c = [] for i in range(len(a)): c.append([]) for j in range(len(b[0])): c[i].append(0) for i in range(len(a)): for j in range(len(b)): for k in range(len(b[0])): c[i][k] += a[i][j]*b[j][k] return cdef mult_num(a, b): c = [] for i in range(len(a)): c.append([]) for j in range(len(a[i])): c[i].append(a[i][j]*b) return cdef add(a, b): c = [] for i in range(len(a)): c.append([]) for j in range(len(a[0])): c[i].append(0) for i in range(len(a)): for j in range(len(a[0])): c[i][j] = a[i][j]+b[i][j] return cdef transpose(a): c = [] for i in range(len(a[0])): c.append([]) for j in range(len(a)): c[i].append(a[j][i]) return c def train(): global x_train, y_train, x_test global n, n0, n1, dim, mu0, mu1, sigm, sigm0, sigm1, w, b n = len(y_train) n0 = n1 = 0 dim = len(x_train[0]) mu0 = [] mu1 = [] for i in range(dim): mu0.append(0) mu1.append(0) for i in range(n): if y_train[i][0] == 0: n0+=1 for j in range(dim): mu0[j] += x_train[i][j] else: n1+=1 for j in range(dim): mu1[j] += x_train[i][j] for i in range(dim): mu0[i] /= n0 mu1[i] /= n1 sigm0 = 0 sigm1 = 0# for i in range(dim):# sigm0.append(0)# sigm1.append(0) for i in range(n): if y_train[i][0] == 0: for j in range(dim): sigm0+=(x_train[i][j]-mu0[j])**2 else: for j in range(dim): sigm1+=(x_train[i][j]-mu1[j])**2 sigm0 /= n0 sigm1 /= n1 sigm = n0/(n0+n1)*sigm0 + n1/(n0+n1)*sigm1 #change to vector w = [] for i in range(dim): w.append((mu0[i]-mu1[i])/sigm) for i in range(dim): mu0[i] = [mu0[i]] mu1[i] = [mu1[i]] b0 = mult_num(mult(transpose(mu0), mu0), -0.5/sigm) b1 = mult_num(mult(transpose(mu1), mu1), 0.5/sigm) b = add(b0, b1) b = b[0][0]+log(n0/n1) # print(b)# for i in range(dim):# sigm0[i] /= n0# sigm1[i] /= n1def sigmoid(z): return 1/(1+exp(-z)) def get_probability(x): global w, b z=0 for i in range(dim): z += w[i]*x[i] z += b return sigmoid(z)def get_predict(x): if get_probability(x)&gt;0.5: return 0 else: return 1def test(): print('id,label', file=file_yt) for i in range(len(x_test)): print(i+1, get_predict(x_test[i]),sep=',', file=file_yt)def main(): load_data() print('load_data() ok') train() print('train() ok') test() print('test() ok') if __name__ == '__main__': main() Logistic Regression Model设$s(x)=\frac{1}{1+e^{-x}}$，那么$s’(x)=s(x)(1-s(x))$，反过来证明很简单，正推求导还是有些麻烦的这个1w数据，又有很多浮点运算…实在是难顶…好慢… 哎，写了个Logistic Regression，train来train去，0还是太少了，我佛啦 我发现它每个几个就会出现一次结果非常糟的情况… 参考了下别人的代码魔改了一发，就是加上了AdaGrad，然后求偏微分的时候除总数，再加上Regularization 哇！ 我懂了！有个肥肠肥肠肥肠肥肠肥肠肥肠肥肠肥肠肥肠重要的数据处理就是把一些范围肥肠大的数据范围变小，就除均值就可以了，在这里，有第0,1,3,4,5有关年龄，收入支出的部分范围特别大，把他范围缩小，然后再train就不会出现之前那样每个几个就会出现一次结果非常糟的情况了，train 30次就能得到private:0.84363 public:0.84656 最高也就private: 0.85345 public:0.85356 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import numpy as npfile_x = open('X_train', 'r')file_y = open('Y_train', 'r')file_xt = open('X_test', 'r')file_yt = open('Y_test', 'w')#x_train = y_train = x_test = []#mu1 = mu2 = sigm = []def deal_data(x): for i in range(0, len(x)): x[i]=x[i].split(',') for j in range(0, len(x[i])): x[i][j]=int(x[i][j])def deal_col(x, a, xt): mean_x = 0 for i in range(len(x)): mean_x += x[i][a] mean_x /= len(x) for i in range(len(x)): x[i][a] /= mean_x for i in range(len(xt)): xt[i][a] /= mean_xdef load_data(): global x_train, y_train, x_test, x_val, y_val x_train = file_x.readlines()[1:] y_train = file_y.readlines()[1:] x_test = file_xt.readlines()[1:] deal_data(x_train) deal_data(y_train) deal_data(x_test) deal_col(x_train, 0, x_test) deal_col(x_train, 1, x_test) deal_col(x_train, 3, x_test) deal_col(x_train, 4, x_test) deal_col(x_train, 5, x_test) x = x_train y = y_train x_train, x_val = x[:20000], x[20000:] y_train, y_val = y[:20000], y[20000:] def sigmoid(z): return 1/(1+np.exp(-z))def get_loss(x): global w, b, dim for i in range(dim): pass def train(): global x_train, y_train, x_test, x_val, y_val global w, b, dim w = [] dim = len(x_train[0]) b = 0 lr = 1 y = [] reg_rate = 0.001 gradient_w_sum = [] gradient_b_sum = 0 for i in range(dim): w.append(1) gradient_w_sum.append(0) for t in range(200): print(t, ' testing...', end='') y = [] err = 0 for i in range(len(x_train)): y.append(b) for j in range(dim): y[i] += x_train[i][j]*w[j] y[i] = sigmoid(y[i]) if (y[i]&gt;0.5) != y_train[i][0]: err += 1 print(' train acc:', 1-err/len(x_train), end='') err = 0 for i in range(len(x_val)): yt = b for j in range(dim): yt += x_val[i][j]*w[j] yt = sigmoid(yt) if (yt&gt;0.5) != y_val[i][0]: err += 1 print(' val acc:', 1-err/len(x_val)) for i in range(dim): gradient_w = 2*reg_rate*w[i] for j in range(len(x_train)): gradient_w += -(y_train[j][0]-y[j])*x_train[j][i] gradient_w = gradient_w/len(x_train) gradient_w_sum[i] += gradient_w**2 w[i] = w[i] - lr/np.sqrt(gradient_w_sum[i])*gradient_w gradient_b = 0 for i in range(len(x_train)): gradient_b += -(y_train[i][0]-y[i]) gradient_b = gradient_b/len(x_train) gradient_b_sum += gradient_b**2 b = b - lr/np.sqrt(gradient_b_sum)*gradient_b def get_probability(x): global w, b, dim z = 0 for i in range(dim): z += w[i]*x[i] z += b return sigmoid(z)def get_predict(x): # print(get_probability(x)) if get_probability(x)&gt;0.5: return 1 else: return 0def test(): print('id,label', file=file_yt) nn = 0 for i in range(len(x_test)): if get_predict(x_test[i])==0: nn += 1 print(i+1, get_predict(x_test[i]),sep=',', file=file_yt) print(nn, len(x_test))def main(): load_data() print('load_data() ok') train() print('train() ok') print(w, b) test() print('test() ok')#mainif __name__ == '__main__': main() 我又修改了一下处理数据那部分，把范围大的变成$\frac{x-\min\{x\}}{\max\{x\}-\min\{x\}}$结果稍差了一丢丢private:0.84903 public:0.85282不管了…看后面的了 12345678910def deal_col(x, a, xt): mxx = x[0][a] mix = x[0][a] for i in range(len(x)): mxx = max(mxx, x[i][a]) mix = min(mix, x[i][a]) for i in range(len(x)): x[i][a] = (x[i][a]-mix)/(mxx-mix) for i in range(len(xt)): xt[i][a] = (xt[i][a]-mix)/(mxx-mix) hw3https://www.kaggle.com/c/ml2019spring-hw3作业说明要做的是一个人脸表情的分类]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>machinelearning</tag>
        <tag>problem</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记]]></title>
    <url>%2F2019%2F07%2F13%2Fnote-pwn%2F</url>
    <content type="text"><![CDATA[环境搭建我用的系统是Ubuntu 18.04.2 LTS，感觉最好还是用个LTS的吧 https://github.com/giantbranch/pwn-env-init 安装工具1234567sudo pip install pwntoolsgit clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.shsudo apt install gcc-multilib 这个因为用的是pip安装的，只安装到Python2中了…然鹅我装了anaconda是在虚拟环境中默认Python3，所以只能python2来打开咯 filefile命令可以查看文件的类型之类的 ida安装免费版的…https://www.hex-rays.com/products/ida/support/download_freeware.shtml爱盘里也有https://down.52pojie.cn/ 123chmod +x idafree70_linux.run./idafree70_linux.run./ida64 常用功能 F5 defs.h Shift+F12 字符串 n 重命名 x 引用 pwntools安装1sudo pip install pwntools 常用功能 process remote p64 u64 汇编命令参考]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>note</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记]]></title>
    <url>%2F2019%2F07%2F13%2Fnote-python%2F</url>
    <content type="text"><![CDATA[本文主要使用Python3.7 dir()列出指定类或模块中全部内容help()查看某个函数或方法的帮助文档 Prevrange生成序列 range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 函数12def f(x): return x+2 编写模块 12def f(x): return x+2 module1.py 12345import module1 as m1;# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if(__name__ == '__main__'): m1.foo(); 引用全局变量123def f(): global a a = 300 Python语言概述和开发环境特点面向对象、解释型、弱类型的脚本语言特色：清晰的语法和可扩展性弱点：运行速度慢，源代码加密困难 Sublime3 Python3配置123&#123; "cmd": ["python3", "-u", "$file"]&#125; 变量和简单类型单行注释 &amp; 多行注释12345678910# 233'''233'''"""233""" 变量Python作为弱类型语言，有两个典型特征：无须声明即可赋值，数据类型可以动态改变查看变量类型用type()变量命名规则差不多，可以使用中文日文等，Python2中需要声明编码utf-8，感觉…最好还是字母数字下划线吧，不能包含空格的不能包含关键字，所有的关键字可以通过以下方法获得12import keywordkeyword.kwlist 内置函数也不能包含当做识别符 print函数1print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) 类型整型支持None十进制形式：普通数字二进制形式：0b或0B开头八进制形式：0o或0O开头十六进制形式：0x或0X开头，不区分a-f大小写 浮点型科学计数法不允许除以0 复数在cmath模块中，虚部用j或J表示 字符串字符串必须用引号括起来，单引号双引号均可资瓷转义字符如果两个字符串紧挨着写在一起会自动拼接数值和字符串拼接时，将数值转换成字符串的两个函数str()和repr()略有不同 input()获得输入的时候总是返回一个字符串raw_input()是Python2.x提供的，相当于Python3.x的input() 长字符串其实就是多行注释的方法，三个引号，允许使用\对换行符进行转义 原始字符串，也就是不进行转义的，r&#39;G:\publish\code&#39; 字节串(bytes)：二进制保存数据可以在字符串添加b来构造包含ASCII字符的字节串可以调用bytes()函数来构造可以用encode()方法转换，用decode()解码 深入使用字符串转义字符就不说了.. 字符串格式化用%做分隔符Eg.print(&quot;%s is a %d years old boy&quot;, %(user, age))其他格式代表跟c/c++差不多，有个r是使用repr()转化，s是使用str()转换-指定左对齐，+指定带符号，0表示补充0 序列相关方法整数表示正索引，负数表示负索引，也就是倒数12345s[3: 5] # 不包含索引5，这是一个左闭右开区间，留空就是倒两端s[3: -5] s[-6: -3]s[5: ]s[: 5] 支持in运算符查找子串长度len()获取用max(),min()获取最大和最小字符 大小写相关方法title()：每个单词首字母大写lower()：全部小写upper()：全部大写 删除空白strip()：删除字符串前后的空白lstrip()：删除左边空白rstrip()：删除右边空白 这些方法并不会真正修改字符串 查找、替换startswith()：判断字符串是否以指定子串开头endswith()：判断字符串你是否以指定子串结尾find()：查找子串出现的位置，未找到返回-1index()：查找子串出现的位置，未找到引发ValueError错误replace()：使用指定子串替换字符串的目标子串，第三个参数是替换次数，留空表示全部替换translate()：使用指定的翻译映射表对字符串执行替换Python提供了一个maketrans()函数，有两个参数，前者是需要映射的所有字符，后者是映射后的所有字符 分割、连接split()：将字符串按指定分割符分割成多个短语，两个参数，第一个是分隔符，第二个是分成的部分数量join()：将多个短语连接成字符串，Eg.&#39;,&#39;.join(list) 运算符/表示普通除法，//表示整除%求余运算可以不是整数两个都不能除0，否则引发ZeroDivisionError错误乘方运算**，也可以执行开方运算 索引运算符[begin: end: step]差不多这个样子 比较运算符与bool类型is要求两个变量引用同一个对象id()可以获得引用对象的地址 逻辑运算符and, or, not 三目运算符True_statements if expression else False_statements先求expression，如果是True执行并返回True_statements的值，反之执行并返回False_statements允许使用多条语句，如果用逗号分割，每条都会执行，返回多条语句返回值组成的元组；如果用分号分割，每条购会执行，只返回第一条的返回值支持嵌套 in运算符判断是否位于序列，也有not in 符号优先级表我就不写了…打括号就vans了 列表、元组和字典序列简介字符串、列表、元组列表是可变的，元组是不可变的1234# 创建列表[ele1, ele2, ...]# 创建元组(ele1, ele2, ...) 通过索引可以访问元素 slice语法，左闭右开1[start: end: step] 加法元组和列表不能相加，但是元组和元组、列表和列表可以相加 乘法与整数相乘，将包含的元素重复$N$次为了表示只有一个元素的元组，必须在唯一的元组元素之后添加英文逗号 in运算符len(),max(),min()，比较大小必须相同类型且可比较大小 序列封包和序列解包程序把多个值赋给同一个变量时，会自动将多个值封装成元组，叫做序列封包程序允许将序列直接赋值给多个变量，各元素会依次赋值给每个变量（个数必须相等），称为序列解包如果在变量之前添加*那么这个变量就代表一个列表 使用列表list()可以将元组或range对象转换成列表 类似的，用tuple()可以转换成元组 增加列表元素append()将参数追加到列表最后，可以是元组或列表形成嵌套extend()可以将参数依次追加到列表后面而不是当做一个整体insert(index, ele)从中间插入 删除列表元素del语句，Eg.del a[2]不仅可以删除列表还可以删除变量列表的方法，remove()删除第一个找到的元素，clear()清空 修改列表元素直接赋值，也可以用slice语法对部分赋值，不要求数量相等，也就是可以增加元素如果用slice语法用字符串对列表赋值，那么会把字符当成一个元素，如果slice语法指定了step，那么个数必须相等 其他常用方法dir(list)可以查看所有方法count()： 统计某元素出现次数index()： 判断某元素出现位置pop()： 当成栈来使用，出栈reverse()： 将元素翻转sort()： 对元素排序，可以传入key和reverse两个参数，key是比较大小的键，reverse默认为False从小到大排序如果是True则从大到小排序 使用字典key和value的映射，需要通过key访问value，所以key不允许重复 创建字典列表不能作为key,必须是不可变类型，元组可以用dict创建列表时，列表中的每个元组被当成一个key-value，所以必须是两个元素指定关键字参数创建字典，这是key不允许使用表达式123&#123;key1: value1, key2: value2, ...&#125;dict(list)dict(chinese=1, jp=2) 添加只需赋值即可，删除用del语句，in判断是否有指定key 常见方法dir(dict)clear()： 清空所有key-value对get()： 通过key获得value，访问不存在的不会引发KeyError错误，而是返回Noneupdate()： 用一个字典更新另一个字典，可以添加和覆盖items()： 获得所有的key-value对keys()： 获得所有的keyvalues()： 获得所有的valuepop()： 获得key所对应的value并删除popitem()： 删除最后一个储存的setdefault()： 获得指定key的value，如果不存在则返回第二个参数也就是设置的默认值 使用字典格式化字符串多参数时适用123s='name: %(name)s, age: %(age)d, weight: %(weight).2f'd=&#123;'name': 'beiyu', 'age': 19, 'weight': 49.4&#125;print(s % d) # name: beiyu, age: 19, weight: 49.40 流程控制if严格缩进，缩进程度必须相同123456if expression : statements...elif expression : statements...else : statements 不要忘记冒号！还有以下会被认为是False1False, None, 0, "", (), [], &#123;&#125; pass语句可以当占位使用 assertassert expression如果为True继续执行，否则引发AssertionError错误 loopwhile1234[init_statements]while test_expression : body_statements [iteration_statements] for-in用于遍历循环变量受for-in控制，不应在循环体中进行赋值；用于可迭代对象，有next()方法12for var in set|str|dict|list : statements isinstance(var, type)可以判断是否为指定类型 循环可以使用else，是循环条件不满足时执行的，不管是否进入循环 for表达式可以有多层，继续往后加for即可1[表达式 for 计数器 in 可迭代对象] zip()可以将多个列表压缩成一个zip()对象，长度不等取短的 循环控制break,continue,return 函数函数123def function_name(var1, var2, ...) : statements return [var] 当函数体只有一行时，可以与函数头放在同一行 为函数添加文档将一段注释内容放在声明后函数体前，就可以通过help()和函数的__doc__获得文档 传参按位置，按关键字，可以设置参数默认值，带默认值的参数定义在形参后面 参数收集 个数可变参数前面加*号，当做元组个数可变前面加**，当做字典，关键字参数收集的参数 逆向参数收集将已有列表、元组、字典拆开传给函数参数在传入列表元组的参数之前加*，字典参数添加** 参数传递机制跟其他语言一样，传的是形参，列表元组字典传的是实参，可以修改 变量作用域globals()： 全局范围内所有变量组成的字典locals()： 当前局部范围vars(object)： 在指定对象范围内，若不传入object则跟locals()一样 在函数中声明全局变量，就是在变量名前加global 局部函数在函数体内定义函数，对外部是隐藏的，称为局部函数，只能在封闭函数中使用封闭函数可以返回局部函数供其他作用域中使用，如果封闭函数将局部函数返回，且程序使用变量保存了封闭函数的返回值，那么这些局部函数的作用域就会被扩大 可以使用nonlocal生命访问赋值语句只是访问该函数所在函数内的局部变量 函数高级内容函数变量，相当于起别名，也可以当做返回值、形参 局部函数与lambda表达式lambda表达式只能是单行表达式语法lambda [parameter_list]: 表达式 map()函数第一个参数是需要传入的函数，第二个参数是数据 到这里，基本的语法已经看完了，剩下就是类还有些比较高级的东西了，抽空看我错了，再补充下文件的部分…算了…先看下基本的文件操作就可以了，详细的以后再说吧.. 文件 I/O打开文件1open(file_name [, access_mode][, buffering]) file.closed： 返回文件是否已经关闭file.mode： 返回打开文件的访问模式file.name： 返回打开文件的文件名称 打开模式r： 只读w： 写a： 追加+： 读写b： 二进制模式 缓冲如果open第三个参数为0 or False那么就不带缓冲，如果是1 or True就带缓冲 读取文件read()如果读入是b模式则读入字节，否则是字符，read()的参数表示一次读取多少字节或字符 按行读取readline([n])： 读取$n$行内容readlines()： 读取所有行 csv库https://docs.python.org/zh-cn/3/library/csv.html 参考 《疯狂Python讲义》，李刚.—北京：电子工业出版社，2019.1 https://github.com/jackfrued/Python-100-Days/]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习笔记]]></title>
    <url>%2F2019%2F07%2F10%2Fnote-machinelearning%2F</url>
    <content type="text"><![CDATA[暑假不定时更新ing…写好的笔记可能不会立刻同步…可能大部分放英文，小部分中文翻译 Overview &amp; Learning Mapsupervised learning regression classification linear model non-linear model deep learning SVM, decision tree, K-NN… structured learning semi-supervised learningtransfer learningunsupervised learningreinforcement learning这些根据scenario的不同选择的 The Next Step for Machine Learning Anomaly Detection (让机器知道”我不知道“) Explainable AI (为什么知道) 防止 Adversarial Attack Life-long Learning Meta-learning / Learn to learn Few-shot / Zero-shot Learning 增强式学习 Network Compression 如果训练资料和测试资料很不一样 Regression 回归Step1: Model 模型首先要有一个Model，也就是一个Function Set，存各种各样的函数。像$y=b+\sum w_ix_i$这种模型，就是一个Linear Model 线性模型$x_i$表示attribute of input x，也就是$x$的各种属性feature 特征$w_i$表示weight权重$b$表示bias偏差 Step2: Goodness of Function接下来就是训练模型，选出一个较好的Function首先要有Training Data，用hat表示正确的数据也就是$\hat{y}$然后有另一个Function，也就是Loss Function，$L$来评价来估价，例如用平方差估价$L(f)=L(w,b)=\sum_{n}(\hat{y}^n-(b+w\cdot x^n_{cp}))^2$，得到Estimation Error 估测误差，以下便用这个函数估价 Step3: Best FunctionPick the “Best” Function, $f^{\ast}=arg \min L(f) $ 或 $w^{\ast},b^{\ast}=arg \min L(w,b) $在这个问题求解的地方用到了Gradient Descent 梯度下降的方法 Gradient Descent首先必须是一个可微分的方程，先假设只有一个参数$L(w)$，那我们要求的就是$w^{\ast}=arg\min_{w}L(w)$，步骤如下：随机选取或稍微优化选取一个初始解$w^{0}$然后计算$\left . \frac{\text{d}L}{\text{d}w} \right |_ {w=w^{0}}$显然$\left . \frac{\text{d}L}{\text{d}w} \right |_ {w=w^{0}}$为负，那么右边高损失大，左边低损失小那么就让$w^{n}=w^{n-1}-\eta \left . \frac{\text{d}L}{\text{d}w} \right |_ {w=w^{n-1}}$这里$\eta$表示Learning rate，$\eta$越大学习效率越高然后多次迭代，最后显然是会得到一个Local optimal 局部最优解，也就是导数为零的时候，但不一定是Global optimal 全局最优解。 如果有两个参数$w^{\ast},b^{\ast}=arg \min L(w,b) $，步骤也差不多，求偏微分就是了$w^{n}=w^{n-1}-\eta \left . \frac{\partial L}{\partial w}\right |_ {w=w^{n-1},b=b^{n-1}},b^{n}=b^{n-1}-\eta \left . \frac{\partial L}{\partial b}\right |_ {w=w^{n-1},b=b^{n-1}}$那么Gradient就是$\triangledown L=\begin{bmatrix}\frac{\partial L}{\partial w}\\ \frac{\partial L}{\partial b}\end{bmatrix}_ {gradient}$刚学过偏微分的我还是知道$(-\eta \frac{\partial L}{\partial w},-\eta \frac{\partial L}{\partial b})$的方向，对$L$的微分最大，也是空间的法线方向 在这里没有局部最优解，因为我们定义的函数是convex 凸的，只有全局最优解 Generalization我们这样可以得到$w,b$，而我们关心的不是训练数据里的损失值，而是Testing Data 测试数据中的数据。 Model Selection我们想要得到更准确的数据呢，就需要复杂的Model，比如增加三次方，四次方，五次方之类的A more complex model does not always lead to better performance on testing data. This is Overfitting.但是复杂的Model在Training Data上的结果很好，但是在Testing Data上的结果较差，这就是Overfitting 过拟合。 Redesign the Model这时候还会有一个情况，那就是其他隐藏的参数，那就需要重新设计Model如果是Pokemon的物种，那么就需要if来判断，用$\delta(x_s=x_0)$这个函数来将原函数改写成线性模型，函数值就是里面的等式成立是1不成立就是0 Regularization就是修改Loss Function$L=\sum_{n}(\hat{y}^n-(b+\sum w_ix_i))^2+\lambda (w_i)^2$，这里也就是我们希望参数越小越好，这里也是不需要$b$也就是bias的。如果输入加上一点点变化，我们希望输出不那么参数小也就是输出对输入不那么敏感 sensitive，也就是比较smooth 平滑的。If some noises corrupt input $x_i$ when testing. A smoother function has less influence.Training error: larger $\lambda$, considering the training error less.We prefer smooth function, but don’t be too smooth. Demo最后有一个Demo，就是实际操作的时候可能不太好选取Learning Rate也就是$\eta$，用了一个AdaGrad，并对$w,b$分别设置了Learning rate。 Bias and VarianceReviewError due to “bias” and “variance”. Estimator举个栗子，如果要估测$x$的mean 平均值assume the mean of $x$ is $\mu$assume the variance of $x$ is $\sigma^2$ 那么我们估测平均值$\mu$就随机取$N$个点来计算$m=\frac{1}{N}\sum_{n}x^n\neq \mu$$E[m]=E[\frac{1}{N}\sum_{n}x^n]=\frac{1}{N}\sum_{n}E[x^n]=\mu$，$m$的期望就是$\mu$，这个是unbiased的$Var[m]=\frac{\sigma^2}{N}$，这个Variance depends on the number of samples，如果数量较多那么就会比较集中，如果较少那么就会比较分散了 如果估测variance $\sigma^2$$m=\frac{1}{N}\sum_{n}x^n\neq \mu,s^2=\frac{1}{N}\sum_{n}(x^n-m)^2$这里这个$s^2$是biased的，$E[s^2]=\frac{N-1}{N}\sigma^2$ Variance如果$E[f^{\ast}]=\bar{f}$，那么这个$\bar{f}$和中心店偏移的距离就是bias，而其他$f$和$\bar{f}$分散的距离就是varianceModel 比较简单那么可能获得一个Small Variance的情况，而比较复杂的Model 可能得到一个Large Variance因为比较简单的Model受数据的影响较小 Bias$E[f^{\ast}]=\bar{f}$Bias: If we average all the $f^{\ast}$, is it close to $\hat{f}$然而一个简单的Model会有比较大的Bias，而比较复杂的Model便有一个小的Bias。 当你的function set的space比较小Model简单，那么它可能不包含target；Model复杂时，function set 的space也变大，就有可能包含target。 我们所得到的Error就是这两个造成的Error的和如果Error在Bias较小Variance较大的地方就是Overfitting，如果Error在Bias较大Variance较小的地方就是Underfitting 欠拟合 Large BiasDiagnosis： If your model cannot even fit the training examples, then you have large bias. If you can fit the training data, but large error on testing data, then you probably have large variance For bias, redesign your model: Add more features as input. A more complex model. Large variance More data这个可以自己生成许多训练数据 Regularization这时调整了function space，可能会影响到bias，需要调整weight来取得平衡 Model Selection There is usually a trade-off between bias and variance. Select a model that balances two kinds of error to minimize total Cross Validation将Training Set分成Training Set和Validation Set，然后用Validation Set来选择Model 如果你把Public Testing Set考虑进去来修改那么就考虑进去了Public Testing Set的bias… N-fold Cross Validation分成多份，将其中一份当成Validation Set Gradient Descent可以把参数写成向量的形式那么${\theta}^{\ast}=arg\min_{\theta}L(\theta)$Gradient:$\triangledown L=\begin{bmatrix}\frac{\partial L(\theta_1)}{\partial \theta_1}\\ \frac{\partial L(\theta_2)}{\partial \theta_2}\end{bmatrix}$$\theta^{n}=\theta^{n-1}-\eta \triangledown L(\theta^{n-1})$ Tip 1: Tuning your learning rateAdaptive Learning Rates Popular &amp; Simple Idea: Reduce the learning rate by some factor every few epochs.就是说经过几次计算后越来越接近最优解，就要调小Learning Rate，比如$\eta^t=\eta/\sqrt{t+1}$这个压子 Learning rate cannot be one-size-fits-allGive different parameters different learning rates. Adagrad Divide the learning rate of each parameter by the root mean square the its previous derivatives.Adagrad: $w^{t+1}=w^{t}-\frac{\eta^{t}}{\sigma^{t}}g^{t},\sigma^{t}=\sqrt{\frac{1}{t+1}\sum_{i=0}^{t}(g^{i})^2},\eta^t=\eta/\sqrt{t+1}$$\sigma^{t}$：root mean square of the previous derivatives of parameter w，就是前面所有的微分的平方的平均值再开根号约分一下得到$w^{t+1}=w^{t}-\frac{\eta}{\sqrt{\sum_{i=0}^{t}(g^{i})^2}}g^{t}$ Adagrad呢，上面$g^{t}$越大，变化越大，而下面的$\sqrt{\sum_{i=0}^{t}(g^{i})^2}$，会导致$g^{t}$越大，变化越小Adagrad就是强调一个反差，how suprise it is，下面的考虑的是估计一下二次微分 考虑多个参数时，$g^t$越大，Gradient Descent不一定越大 Tip 2: Stochastic Gradient DescentLoss函数$L=\sum_{n}\left (\hat{y}^n-(b+\sum w_ix_i^n) \right )^2$这里要做的就是随机一个$x^n$，$L=\left (\hat{y}^n-(b+\sum w_ix_i^n) \right )^2,\theta^i=\theta^{i-1}-\eta \triangledown L^n(\theta^{i-1})$有一个Sample就更新一下参数这个样子 Tip 3: Feature ScalingMake different features have the same scaling.常见做法：$R$个向量组$x^i$，For each dimension $i$，都算mean: $m_i$,standard deviation: $\sigma_i$对第$r$个向量组$x^r$，$x_i^r=\frac{x_i^r-m_i}{\sigma_i}$，这样做完之后呢，所有的mean 会变成0，standard deviation 会变成1 TheoryTaylor Series理论主要是泰勒展开这个样子，大于等于二次项全部略去，然后相当于在一个圆圈中找一个向量与一次导数组成的向量内积最小，也就是一次导数组成的向量的反方向，再乘上一个常数指到圆圈边界，就得到了Gradient Descent的形式这也就可以解释Learning Rate设置不对的时候偏差较大的问题 More Limitation of Gradient Descent会Stuck at Local minimum or saddle pointVery slow at the plateau Classification: Probabilistic Generative ModelIdeal AlternativesFunction(Model): x-&gt;f(x):g(x)&gt;0?class=1:class2Loss function: $L(f)=\sum_{n}\delta (f(x^n)\neq \hat{y}^n)$, The number of times f get incorrect results on training dataFind the best function: Perceptron, SVN Generative model$P(C_1|x)=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}$$P(x)=P(x|C_1)P(C_1)+P(x|C_2)P(C_2)$ PriorAssume the points are sampled from a Gaussian distribution.Find the Gaussion distribution behind them Gaussian Distribution:$f_{\mu,\Sigma}(x)=\frac{1}{(2\pi)^{D/2}}\frac{1}{|\Sigma|^{1/2}}\exp\{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)\}$Input: vector x, output: probability of sampling xThe shape of the function determines by mean $\mu$ and convariance matrix $\Sigma$这部分有空可以再详细看下 How to find $\mu$ and $\Sigma$ ? Maximum Likelihood我们假设这些向量由一个高斯分布generate，要找一个Gussian$(\mu^{\ast},\Sigma^{\ast})$ with maximum likelihood.$L(\mu,\Sigma)=f_{\mu,\Sigma}(x^1)f_{\mu,\Sigma}(x^2)…f_{\mu,\Sigma}(x^n)$.$\mu^{\ast},\Sigma^{\ast}=arg\max_{\mu,\Sigma}L(\mu,\Sigma)$.$\mu^{\ast}=\frac{1}{n}\sum {x^i}(average x),\Sigma^{\ast}=\frac{1}{n}\sum (x^i-\mu^{\ast})(x^i-\mu^{\ast})^{T}$ Modifying Model公用同一个$\Sigma$，$\Sigma=P(C_1)\Sigma^1+P(C_2)\Sigma^2$，加权平均 Bernoulli distributions Naive Bayes Classifier Posterior Probability$P(C_1|x)=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}=\frac{1}{1+\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}$Let $z=\ln \frac{P(x|C_1)P(C_1)}{P(x|C_2)P(C_2)}$$=\frac{1}{1+\exp(-z)}=\sigma(z)$ Sigmoid function 这里$z$是可以化简的$P(x|C_1)=\frac{1}{(2\pi)^{D/2}}\frac{1}{|\Sigma|^{1/2}}\exp\{-\frac{1}{2}(x-\mu^1)^{T}\Sigma^{-1}(x-\mu^1)\}$.$P(x|C_2)=\frac{1}{(2\pi)^{D/2}}\frac{1}{|\Sigma|^{1/2}}\exp\{-\frac{1}{2}(x-\mu^2)^{T}\Sigma^{-1}(x-\mu^2)\}$.$P(C_1)=\frac{N_1}{N_1+N_2},P(C_2)=\frac{N_2}{N_1+N_2}$. z=\ln \frac{P(x|C_1)}{P(x|C_2)}+ \ln \frac{P(C_1)}{P(C_2)}=\ln \frac{N_1}{N_2}-\frac{1}{2}[(x-\mu^1)^{T}\Sigma^{-1}(x-\mu^1)-(x-\mu^2)^{T}\Sigma^{-1}(x-\mu^2)]把后面的展开$(x-\mu^1)^{T}\Sigma^{-1}(x-\mu^1)=x^{T}\Sigma^{-1}x-x^{T}\Sigma^{-1}\mu^1-(\mu^1)^{T}\Sigma^{-1}x+(\mu^1)^{T}\Sigma^{-1}\mu^1$中间两项其实是一样的，可以合并，因为右乘一个矩阵和左乘转置矩阵是一样的。又因为$\Sigma$相同，所以最后可以化成 z=(\mu^1-\mu^2)^{T}\Sigma^{-1}x-\frac{1}{2}(\mu^1)^{T}\Sigma^{-1}\mu^1+\frac{1}{2}(\mu^2)^{T}\Sigma^{-1}\mu^2+\ln \frac{N_1}{N_2}只有第一项包含$x$，后面就是常数，所以可以写成$z=w^{T}\cdot x+b$的形式，要算的就是$\mu^1,\mu^2,\Sigma^{-1}$ Classification: Logistic Regression我们想要找到一个函数$P(C_1|x)=\sigma(z),z=w\cdot x+b$当$P(C_1|x)\geqslant 0.5$时输出Class1，反之输出Class2这样子$f_{w,b}(x)=\sigma(\sum_{i}w_ix_i+b)$ output是0到1之间的数如果$x^1,x^2$属于Class1，$x^3$属于Class2，$L(w,b)=f_{w,b}(x^1)f_{w,b}(x^2)(1-f_{w,b}(x^3))…$我们要找$w^{\ast},b^{\ast}=arg\max_{w,b}L(w,b)\Leftrightarrow arg \min_{w,b}-\ln L(w,b)$为了统一函数，我们给每个设置$\hat{y}$，如果属于Class1，$\hat{y}=1$，否则$\hat{y}=0$这样对于每一个$-\ln f_{w,b}(x^1)=-[\hat{y}^1\ln f(x^1)+(1-\hat{y}^1)\ln (1-f(x^1))]$最后我们要minimize的$-\ln L(w,b)=\sum_{n}-[\hat{y}^n\ln f(x^n)+(1-\hat{y}^n)\ln (1-f(x^n))]$后面这个好像叫做Cross entropy between two Bernoulli distribution，用于评价两个函数有多接近？ 最后一步用Gradient Descent来求$w^{\ast},b^{\ast}$就行了$w_{i+1}=w_{i}-\eta \sum_{n} -(\hat{y}-f_{w,b}(x^n))x_i^n$和Linear regression的式子一样的 Logistic Regression + Square Error ?主要是求微分以后，离Target最近和最远，微分全都是0 Discriminative v.s. Generative因为我们假设的不一样，所以Logistics Regression 也就是 Discriminative Model 和 Generative Model找出来的$w$和$b$是不同的一般来说，Discriminative Model performance会比 Generative Model更好 Benefit of generative model With the assumption of probability distribution, less training data is needed. With the assumption of probability distribution, more robust to the noise. Priors and class-dependent probabilities can be estimated from different sources. Generative model因为有假设，所以可能会无视一些数据，受数据影响较小，所以可能数据量小时表现会比较好，数据量大的时候就比Discriminative Model 表现较差了 Multi-class Classification对于每一个Class，都有$w^i,b_i,z_i=w^i\cdot x +b_i$然后做Softmax，就是强化最大和最小值的差距，然后把概率控制下$y_i=e^{z_i}/\sum_{n}e^{z_n}$然后算$y_i$和$\hat{y}_ i$的Cross Entropy $-\sum_{i}\hat{y}_ i\ln y_i$$\hat{y}$几类就设置成几维，然后自己属于哪一维，那一维就为1，其他为0 Limitation of Logistic Regression最简单的，比如$(0,0),(1,1)$一类，$(0,1),(1,0)$一类，Logistic Regression就爆炸了 Feature Transformation就把Logistics Regression接起来用，用几次以后当成转换后的值，在做Logistic Regression。我们把每一个Logistic Regression叫做一个Neuron，串起来就是Neuron Network 类神经网络，就到了 Deep Learning 先看到这里，我再学一下Python，做一下下作业，不然光看也没啥用… Deep LearningUps and downs of Deep Learning 1958: Perceptron (linear model) 1969: Perceptron has limitation 1980s: Multi-layer perceptron Do not have significant difference from DNN today 1986: Backpropagation Usually more than 3 hidden layers is not helpful 1989: 1 hidden layer is “good enough”, why deep? 2006: RBM initialization (breakthrough) 2009: GPU 2011: Start to be popular in speech recognition 2012: win ILSVRC image competition 真的是感觉有些不太完善… Three Step of Deep Learning跟Machine Learning的三步一样，第一步也就是一个Neural Network Neural Network: Different connection leads to different network structures.Network parameter $\theta$ :all the weights and biases in the “neurons”. Fully Connect Feedforward Network如果我们知道所有的weights和bisaes，那么这其实就是一个function如果只知道structure不知道这些，那么就是一个function set 一共分成三层input layer - hidden layers - output layer Deep = Many hidden layers Matrix Operation: 其实就是input vector 来进行matrix operation （每一层集合所有的weights 和 biases，每一层最后有一个activation function），最后得到output vector矩阵运算可以GPU加速 feature extractor replacing feature engineering Backpropagation在Neutral Network里面做Gradient Descent有很多参数，那么怎么求Gradient呢就是用Backpropagation Chain Rule就是链式求导法则要求$\frac{\partial L}{\partial w}$, $L=\sum C^n$，$C^n$就是评价$y$和$\hat{y}$之间距离的函数那么$\frac{\partial L}{\partial w}=\sum \frac{\partial C^n}{\partial w}$而$\frac{\partial C}{\partial w}=\frac{\partial z}{\partial w}\frac{\partial C}{\partial z}$ Forward pass: Compute $\frac{\partial z}{\partial w}$ for all parameters.Backward pass: Compute $\frac{\partial C}{\partial z}$ for all activation function inputs z, Compute $\frac{\partial C}{\partial z}$ from the output layer.有一些细节，就是从后往前算，需要乘上weight然后经过op-amp乘上一个常数得到其实就是建一个反向Neural Network来计算，output变成input KerasInterface of TensorFlow or TheanoEasy to learn and use(still have some flexibility) 安装 &amp; 使用：https://keras.io/ 12sudo pip install tensorflowsudo pip install keras 但是遇到了一个问题…123456789 Complete output from command python setup.py egg_info: Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-aAiWd2/scipy/setup.py&quot;, line 31, in &lt;module&gt; raise RuntimeError(&quot;Python version &gt;= 3.5 required.&quot;) RuntimeError: Python version &gt;= 3.5 required. ----------------------------------------Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build-aAiWd2/scipy/ 我Python明明是3.7，为啥就不行了呢，后来我想起来我装了Anaconda以后都是在虚拟环境中，所以，不加sudo就能安装了 Mini-batchone epoch Randomly initialize network parameters Pick the 1st batch, Update parameters once Pick the 2nd batch, Update parameters once Until all mini-batches have been picked Repeat the above process 设置这个可以利用GPU加速 Tip for Deep LearningRecipe of Deep Learning两个问题：一个是在Training Data上performance不好，一个是在Testing Data上performance不好 Bad Results on Training Data两种方法 New activation function Adaptive Learning Rate 有一种情况，靠近input layer的地方微分值很小，Learn very slow，Almost random；靠近ouput layer的地方微分值较大，Learn very fast，Almost converge。这件事发生的原因是使用sigmoid function，一个很大的$\Delta$经过sigmoid function以后是会变小的，而且影响也会越来越小。解决的方法呢 Rectified Linear Unit(ReLU)\sigma(z)=\left\{\begin{matrix} a=z, && z\geqslant 0\\ a=0, && z]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>machinelearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266WiFi模块]]></title>
    <url>%2F2019%2F06%2F08%2Fesp-wifi%2F</url>
    <content type="text"><![CDATA[一开始设置WiFi一直连不上，最后发现是模式有问题，默认是STA模式，所以begin是连不上的…然后改成了用softAP模式启动就可以了…等着以后来补补吧…周一专业课考试嗷，考完有时间搞一下，最近也没玩CTF.. 1234567891011121314151617181920212223#include &lt;ESP8266WiFi.h&gt;void setup() &#123; Serial.begin(115200); Serial.println(); Serial.print("Setting soft-AP ... "); boolean result = WiFi.softAP("www", "password"); if(result == true) &#123; Serial.println("Ready"); &#125; else &#123; Serial.println("Failed!"); &#125;&#125;void loop() &#123; Serial.printf("Stations connected = %d\n", WiFi.softAPgetStationNum()); if(WiFi.softAPgetStationNum()) &#123; WiFi.printDiag(Serial); Serial.println(WiFi.localIP()); &#125; delay(3000);&#125; 参考 完美图解物联网IoT实操. ESP8266 Arduino，Cordova物联网移动App， JavaScript微控制器编程 / 赵英杰著.—北京：电子工业出版社，2018.9]]></content>
      <categories>
        <category>esp</category>
      </categories>
      <tags>
        <tag>esp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专业课笔记]]></title>
    <url>%2F2019%2F06%2F04%2Fnote-niit%2F</url>
    <content type="text"><![CDATA[引用站内文章1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 第一学期 PLT笔记 Linux笔记 Vim笔记 Shell笔记 第二学期 关系数据库管理系统(RDBMS)笔记 Java笔记 MySQL笔记 数据库笔记 正则表达式笔记]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>niit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据库管理系统(RDBMS)笔记]]></title>
    <url>%2F2019%2F06%2F02%2Fnote-rdbms%2F</url>
    <content type="text"><![CDATA[关系型数据库管理系统（Relational Database Management System，RDBMS） 亲，双语对照 名词解释 候选键 ：表中可以唯一确定一个元组的某个属性（或者属性组）叫候选键 主键 : 从许多候选键(可包含多个属性)中挑一个用来维护记录的完整性就叫主键。 外键 ：一个属性（或属性组），它不是这个表的主键，但是它别的表的主键，它就是这个表的外键。 主属性 ：一个属性只要在任何一个候选键中出现过，这个属性就是主属性。 非主属性 ：与上面相反，没有在任何候选键中出现过，这个属性就是非主属性。 数据模型A data model is a description of the data in a database. In addition, the data model describes the relationship among data, and any constraints that have to be defined on the data. Data models can broadly be classified into the following categories. Object-based logical model: Focuses on desctibing the data, the relationship among the data, and any constraints defined. Record-based logical model: Focuses on specifying the logical structuring of the database. ER模型(ER Model)ER模型是基于对象的逻辑模型(Object-Based Logical Model)“实体”-“关系”模型，是描述数据及其联系的数据模型The ER model views the real world as a collection of objects or entities and the relationship among them. 实体实体：客观存在并可以相互区分的事物Entities:a thing, whick can be easily identitfied. 属性属性：实体所具有的若干特征Attributes: an attribute is a property of given entity. 关系关系：实体之间的联系Relationships: an association among entities.A relationship type is an association of entity types. A relationship instance is an association of entity instances.A relationship can associate an entity with itself.关系类型： One-to-One One-to-Many(or Many-to-One) Many-to-Many 子类型和超类型子类型是另一个实体的子集A subtype is a subset of another entity.超类型就是那个完整的集合咯A subentity or subtype is always dependent on the supertype for its existence.The attributes of a supertype apply to all of its subtypes. The converse is not true.The supertype is connected to the relationship with a line containing a crossbar, as indicated in the preceding diagram. The attributes, which describe supertype will also belong to all subtypes. The subtype is described by the attributes that are unique to it. 基于记录的逻辑模型(Record-Based Logical Model)层次模型：树形结构网状模型：不加任何条件限制的无向图关系模型：采用二维表来表示，满足一定条件的二维表称为关系；二维表中凡能唯一标识元祖的最小属性集称为该表的键或码。 Hierarchical Model(层次模型)In this model, data is represented in the form of a tree, and relationships between the data are represented by links. Network Model(网状模型)In this model, the data and relationships among them are represented in the form of records and links. It is similar to a hierarchical model. However, records in a databse are represented by graphically. Relational Model(关系模型)In this model, the table in a database has a fixed length record with fixed number of attributes or fields. Of these three models, the relational model is the most popular. 关系模型关系数据结构 An RDBMS can be defined as a database management system where all the data visible to the user is organized strictly as tables of data values, and all the database operations work on these tables. The basic principle in a relational database is a tabular arrangement of data values. Each table in a databse has a unique table name that identifies its contents. The row(or record) in the table is called a tuple, and the column(or field) is called an attribute. Every column in a table must have a unique name. The number of tuples is called the cardinality of the table, and the number of attributes is called the degree of the table.One important property of a relation is that its rows are unordered. Every table must have some column or conbination of columns that uniquely identifies each row in the table.No two rows of table contain the same values in that column or column conbination. This column is called the primary key.A table where every row is different from all other rows is called relation.Each attribute of a table has an associated domain(域). A domain is a collection of values from which one or more attribute(columns) draw their actual values. The domain lists the possible values for an attribute. (域就是所有取值可能) ER图(ER Diagram)矩形框：表示实体，在框中记入实体名。菱形框：表示联系，在框中记入联系名。椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。) 关系运算(Relational Operators)Restrict 约束限制The restrict operator extracts specified tuple or rowss from a given relation besed on a condition.约束：根据条件提取几个元组 Project 投影The project operator extracts specified attributes or columns from a given relation.提取几列成为新的表 Produce 乘The product operator joins two relations such that every tuple of the first relation is matched with every tuple of second relation. To be product compatible, the two tables must have common attributes. Union 并The union operator builds a relation from tuples appearing in erither or both of the specified relations where as intersect operator builds a relation consisting of tuples that appear in both the relations. Intersect 交The intersect operator builds a relation consisting of tuples that appear in both the relaiton. Difference 差The difference operator builds a relation of tuples appearing in the first but not in the second of the two specified relation. Join 连接The join operator builds a relation from two specified relations. This relation consists of all the possible combinations of tuples, one from each relation that satisfies the specified condition. The join operation requires a common attribute. Divide 除The divide operator takes two relations and builds another relation consisting of values of an attribute of one relation that match all the values in the other relation. The divide operation is the opposite of the product operation. 数据库设计(Database design)将图标映射到表格ER图中几个重要的组成 Regular entities Attributes Relationships Weak entities Subtypes and supertypes Weak entitiesA weak entities is an entity whose existence depends on some other entity. The weak entities have the composite key, part of which consists of the primary key of the entity they depend on. 基于逻辑的数据库设计Attributes It identifies its owner entity. It refers to another entity. It simplifies the description of an entity. Keys Primary Foreign Candidate Alternate Composite Any attribute(or set of attributes) that uniquely identifies a row in table is a candidate for the primary key(主键). Such an attribute is called a candidate key(候选键). One of the candidate keys is chosen to be the primary key, based on the familiarity and greater usage. Any attribute that is a candidate for the primary key but is not the primary key is called the alternate key(替代键). When the key that uniquely identifies the row of the table is made up of more than one attribute, it is called a composite key(组合键). EntitiesSome attributes may acquire further attributes to qualify themselves during databses design and become entities. SubentitiesSpecialization(特化) is the result of taking a subset of a higher-level entity set to form a lower-level entity set.Generalization(概化) is the result of taking the union of two or more lower-level entity set to produce a higher-level entity set. It is the opposite of specialization. 规范化定义(范式)Normalization is a method of breaking down complex table structures into simple table structures by using certaion rules. Using this mathod, you can reduce redundancy in a table, and eliminate the problems of inconsistency and disk space usage. You can also ensure that there is no loss of information. Normalization has the following benefits It helps in maintaining data integrity(完整). It helps in simplifying the structure of tables, therefore, making a database more compact(简洁). It helps in reducing the null values, which reduces the complexity of data operation. Achieve a good database design Each table should have an identifier Each table should store data for a single type of entity. Columns that accept NULLs should be avoided. The reprtition of values or columns should be avoided. 第一范式(1NF)A table is said to be 1NF when each cell of the table contains precisely one value.定义：符合1NF的关系中的每个属性都不可再分解, 并且在一条记录里一个属性只能对应一个值 Guidelines Place the related data values in a table. Further, define similar data values with the column name. There should be no repeating group in the table. Every table must have a unique primary key. Functional dependency(函数依赖)如果属性A依赖B，那么B就叫决定因素determinant 函数依赖就是对于每个x都有唯一的y与之对应，记作x-&gt;y部分依赖(partial dependency) 不完全依赖于键，如有组合键时只依赖于组合键中的某一个键依赖传递(transitive dependency) x-&gt;y-&gt;z 第二范式(2NF)A table is said to be in 2NF when: It is in 1NF, and No partial dependency exists between non-key attributes and key attributes. 定义： 符合1NF的前提下, 当表存在组合主键的时候, 每一个非键属性都必须完全依赖于组合主键中的所有主键, 而不能只依赖部分主键 Guidelines Find and remove attributes that are functionally dependent on only a part of the key and not on the whole key. Place them in a different table. Group the remaining attributes. 第三范式(3NF)A relation is said to be in 3NF if and only if: It is in 2NF, and No transitive(indirect) dependency exists between non-key attributes and key attributes. 定义：符合2NF的前提下, 每一个非主键属性和主键之间不能有依赖传递(间接依赖) Guidelines Find and remove non-key attributes that are functionally dependent on attributes that are not the primary key. Place them in a different table. Group the remaining attributes. BCNF(鲍依斯-科得范式)The original definition of 3NF was not sufficient in some situations.不满足的情况 That had multiple candidate keys. Where the multiple candidate keys were composite. Where the multiple candidate keys overlapped(had at least one attribute in common).A relation is in BCNF if and only if every determinant is candidate key. 定义：符合3NF的前提下, 同时主属性内部没有部分依赖或者依赖传递关系 Guidelines Find and remove the overlapping candidate keys. Place the part of the candidate key an th attribute it is functionally dependent on, in a different table. Group the remaining items into a table. 逆范式The intentional introduction of redundancy in a table in order to improve performance is called denormalization.逆范式化指的是根据项目情况故意通过增加冗余或重复的数据来提高数据库的查询性能(从而避免频繁使用性能较差的连接语句或子查询语句)]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>database</tag>
        <tag>rdbms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266的LED灯]]></title>
    <url>%2F2019%2F06%2F02%2Fesp-digital-light%2F</url>
    <content type="text"><![CDATA[步骤让esp8266的LED灯一闪一闪的…在Arduino中配置好，根据自己的配置… 工具-开发板-··NodeMCU 1.0 工具-端口-COM4(我的是COM4…) 下面这段代码就是文件-示例-Basics-Blink 一定要注意加上一行代码#define LED_BUILTIN 2 12345678910111213141516171819202122232425262728293031323334353637/* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. http://www.arduino.cc/en/Tutorial/Blink*/#define LED_BUILTIN 2// the setup function runs once when you press reset or power the boardvoid setup() &#123; // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT);&#125;// the loop function runs over and over again forevervoid loop() &#123; digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second&#125; 最后，项目-上传 参考 完美图解物联网IoT实操. ESP8266 Arduino，Cordova物联网移动App， JavaScript微控制器编程 / 赵英杰著.—北京：电子工业出版社，2018.9]]></content>
      <categories>
        <category>esp</category>
      </categories>
      <tags>
        <tag>esp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理笔记]]></title>
    <url>%2F2019%2F06%2F01%2Falgorithm-chinese-remainder-theorem%2F</url>
    <content type="text"><![CDATA[中国剩余定理$\left\{\begin{matrix}x\equiv a_1\bmod m_1\\ x\equiv a_2\bmod m_2\\ … \\x\equiv a_n\bmod m_n\end{matrix}\right.$其中$m_i$两两互质$M=\prod_{i=0}^{n}m_i, M_i=\frac{M}{m_i}$$x=\sum_{i=0}^{n}a_i M_i M_i^{-1}\pmod {m_i}$ 扩展中国剩余定理模数不互质的时候$x\equiv a_1\bmod m_1$$x\equiv a_2\bmod m_2$也就是$x=k_1m_1+a_1=k_2m_2+a_2$$\therefore k_1m_1=(a_2-a_1)+k_2m_2$即$k_1m_2\equiv (a_2-a_1)\bmod m_2$让$d=(m_1,m_2)$即$k_1\frac{m_1}{d}\equiv \frac{(a_2-a_1)}{d}\bmod {\frac{m_2}{d}}$这样就可以得到$k_1=k’\frac{m_2}{d}+\frac{a_2-a_1}{d}(\frac{m_1}{d})^{-1}\pmod {\frac{m_2}{d}}$令$t=\frac{a_2-a_1}{d}(\frac{m_1}{d})^{-1}\pmod {\frac{m_2}{d}}$带回原式得$x=(k’\frac{m_2}{d}+t)m_1+a_1$即可并成$x=k’\frac{m_1m_2}{d}+tm_1+a_1$即$x\equiv a\bmod m$，其中$a=tm_1+a_1, m=\frac{m_1m_2}{d}$]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>chinese-remainder-theorem</tag>
        <tag>gcd</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF WriteUP]]></title>
    <url>%2F2019%2F05%2F30%2Fctf-buuctf%2F</url>
    <content type="text"><![CDATA[Web随便注不知道为啥一开始注的时候一直成功不了，不知道有啥毛病…最后&#39; or 1=1;#就成功了1234array(1) &#123; [0]=&gt; string(38) &quot;flag&#123;3fy145hzdo5ryeho9za94r0qnbkvha0g&#125;&quot;&#125; 1flag&#123;3fy145hzdo5ryeho9za94r0qnbkvha0g&#125; Pwn连上就有flag的pwn123nc buuoj.cn 6000flag&#123;2e54332c-bad2-4f2f-aaa9-49364f9edcf4&#125; ReverseCrypto看我回旋踢1synt&#123;5pq1004q-86n5-46q8-o720-oro5on0417r1&#125; 简单的移位恺撒密码https://planetcalc.com/1434/ROT131flag&#123;5cd1004d-86a5-46d8-b720-beb5ba0417e1&#125; 变异凯撒12加密密文：afZ_r9VYfScOeO_UL^RWUc格式：flag&#123; &#125; 输出一下对应的ASCII码1297 102 90 95 114 57 86 89 102 83 99 79 101 79 95 85 76 94 82 87 85 99 102 108 97 103 前4位和flag相比依次少了$5,6,7,8$12345t='afZ_r9VYfScOeO_UL^RWUc'j=5for i in t: print(chr(ord(i)+j), end='') j += 1 1flag&#123;Caesar_variation&#125; MD51e00cf25ad42683b3df678c61f42c6bda cmd5查一下https://www.cmd5.com/ 1flag&#123;admin1&#125; Url编码1%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d http://web.chacuo.net/charseturlencode1flag&#123;and 1=1&#125; Quoted-printable1=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6 http://web.chacuo.net/charsetquotedprintable1flag&#123;那你也很棒哦&#125; password1234ÐÕÃû£ºÕÅÈý ÉúÈÕ£º19900315keyžñÊœÎªkey&#123;xxxxxxxxxx&#125; 一看就是编码错误GBK to UTF-8https://www.dedemao.com/convert/#解码后1234姓名：张三 生日：19900315key格式为key&#123;xxxxxxxxxx&#125; 提交的时候并不是key1flag&#123;zs19900315&#125; 摩丝1.. .-.. --- ...- . -.-- --- ..- http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx1flag&#123;ILOVEYOU&#125; rsarsa123456789Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message 直接计算$d$和$m$即可，不需要再编码 123456789101112131415161718import gmpy2 as gpfrom binascii import a2b_hex,b2a_hexp = gp.mpz(9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483)q = gp.mpz(11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407)e = gp.mpz(65537)c = gp.mpz(83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034)n = p*qphi = (p-1) * (q-1)d = gp.invert(e, phi)m = pow(c, d, n)print(m)# print(hex(m)[2:])# print(bytes.fromhex(hex(m)[2:])) 解得1flag&#123;5577446633554466577768879988&#125; RSA12ÔÚÒ»ŽÎRSAÃÜÔ¿¶ÔÉú³ÉÖÐ£¬ŒÙÉèp=473398607161£¬q=4511491£¬e=17Çóœâ³öd×÷ÎªflgaÌáœ» GBK to UTF-8https://www.dedemao.com/convert/#12在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d作为flga提交 12345678import gmpy2 as gpp = gp.mpz(473398607161)q = gp.mpz(4511491)e = 17phi = (p-1)*(q-1)d = gp.invert(e, phi)print(d) 1125631357777427553 RSA212345e = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751 这道题一开始不会做的..都不知道dp啥意思…$dp\equiv d \bmod \varphi(p)$ $e\times dp\equiv ed \bmod \varphi(p)$$ed=k\varphi(p)+edp$$ed=(k\varphi(p)+edp)\equiv 1\bmod \varphi(n)$ 这步是我没有想到的…感觉这步相当妙啊$k\varphi(p)+edp=k’(p-1)(q-1)+1$移项得$(p-1)(k’(q-1)-k)+1=edp$$\because dp&lt;(p-1)$$\therefore e=65537&gt;(k’(q-1)-k)=x$然后枚举$x$就可以计算得出$p-1$根据$n$可以算出所有的值了1234567891011121314151617181920212223242526272829import gmpy2 as gpe = 65537n = gp.mpz(248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113)dp = gp.mpz(905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657)c = gp.mpz(140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751)for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gp.invert(e, phin) m=gp.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print('--------------') print(m) print(hex(m)[2:]) print(bytes.fromhex(hex(m)[2:]))'''print('--------------')print(m)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:]))''' 最后得到1233670434958110785066911905751469631231338751225710158680692616521935747246580688484040488309932916523151997666c61677b776f775f6c65616b696e675f64705f627265616b735f7273613f5f39383932343734333530327db&apos;flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;&apos; RSA312345c1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291 共模攻击 攻击条件 当两个用户使用相同的模数 $N$、不同的私钥时，加密同一明文消息时即存在共模攻击。 攻击原理设两个用户的公钥分别为$e_1$和$e_2$，且两者互质。明文消息为$m$，密文分别为：c_1 = m^{e_1}\bmod N \\c_2 = m^{e_2}\bmod N 当攻击者截获 $c_1$ 和 $c_2$ 后，就可以恢复出明文。用扩展欧几里得算法求出 $re_1+se_2=1\bmod n$的两个整数 $r$ 和 $s$，由此可得： \begin{align*}c_{1}^{r}c_{2}^{s} &\equiv m^{re_1}m^{se_2}\bmod n\\&\equiv m^{(re_1+se_2)} \bmod n\\&\equiv m\bmod n\end{align*}https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/rsa/rsa_module_attack/#_6 123456789101112131415161718192021import gmpy2 as gpdef exgcd(a, b): if b==0: return 1, 0, a x2, y2, r = exgcd(b, a%b) x1 = y2 y1 = x2-(a//b)*y2 return x1, y1, rc1=gp.mpz(22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361)n=gp.mpz(22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801)e1=gp.mpz(11187289)c2=gp.mpz(18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397)e2=gp.mpz(9647291)r1, r2, t = exgcd(e1, e2)m = gp.powmod(c1, r1, n) * gp.powmod(c2, r2, n) % nprint(m)print(hex(m)[2:])print(bytes.fromhex(str(hex(m)[2:]))) 12313040004482819947212936436796507286940525898188874967465457845309271472287032383337801279101666c61677b34396439313037376131616263623134663161396435343663383062653965667db&apos;flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;&apos; RSA112345p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 其中$dp\equiv d \bmod\varphi(p), dq\equiv d \bmod\varphi(q)$这其实就是一个同余方程，用中国剩余定理合并即可但是$p-1, q-1$不互质，在这里推导一下令$dd=(p-1,q-1)$$d=k_1(p-1)+dp=k_2(q-1)+dq$$k_2(q-1)\equiv dp-dq\bmod {(p-1)}$$k_2\frac{(q-1)}{dd}\equiv \frac{dp-dq}{dd}\bmod {\frac{(p-1)}{dd}}$$k_2=k’\frac{(p-1)}{dd}+\frac{dp-dq}{dd}{(\frac{q-1}{dd})}^{-1}$$d=k_2(q-1)+dq=(k’\frac{(p-1)}{dd}+\frac{dp-dq}{dd}{(\frac{q-1}{dd})}^{-1})(q-1)+dq$这里直接$d=\frac{dp-dq}{dd}{(\frac{q-1}{dd})}^{-1}(q-1)+dq$就好咯 12345678910111213141516171819202122import gmpy2 as gpp = gp.mpz(8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229)q = gp.mpz(12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469)dp = gp.mpz(6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929)dq = gp.mpz(783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041)c = gp.mpz(24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852)n = p*qphin = (p-1)*(q-1)dd = gp.gcd(p-1, q-1)d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dqprint(d)m = gp.powmod(c, d, n)print('-------------------')print(m)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) 得到123116302080902045061763029611715390220427211378079118188766378217591016e6f784354467b57333163306d335f37305f4368316e343730776e7db&apos;noxCTF&#123;W31c0m3_70_Ch1n470wn&#125;&apos; 然鹅需要提交flag{W31c0m3_70_Ch1n470wn}才能成功，我已经反馈了，不知道有没有修改 Windows系统密码1234Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::ctf:1002:06af9108f2e1fecf144e2e8adef09efd:a7fcb22a88038f35a8f39d503e7f0062:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:bef14eee40dffbc345eeb3f58e290d56::: 这一看就是Linux 的passwd文件啊…然后我就随便去cmd5查了一下ctf的最后一项a7fcb22a88038f35a8f39d503e7f0062https://www.cmd5.com/就得到了12good-luckflag&#123;good-luck&#125; robomunication一个mp3，下下来听一听…一堆bi bu，感觉就是莫斯电码，然后我就听着用bp分别记录下来，然后b替换成.p替换成-1.... . .-.. .-.. --- .-- .... .- - .. ... - .... . -.- . -.-- .. - .. ... -... --- --- .--. -... . . .--. http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx得到1HELLOWHATISTHEKEYITISBOOPBEEP 再加点英语基础1flag&#123;BOOPBEEP&#125; 传统知识+古典密码12345小明某一天收到一封密信，信中写了几个不同的年份 辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。 信的背面还写有“+甲子”，请解出这段密文。key值：CTF&#123;XXX&#125; 依次对应得到28, 30, 23, 8, 17, 10, 16, 3060一甲子，全加60然后输出1234a=[28, 30, 23, 8, 17, 10, 16, 30]for i in a: print(chr(i+60), end='')print() 得到XZSDMFLZ后面是我不会做的…用了两个古典密码加密…我就想知道这除了碰运气还能咋做..先栅栏得到XMZFSLDZ 再恺撒ROT21 SHUANGYU1flag&#123;SHUANGYU&#125; old-fashion题目一段文字1Os drnuzearyuwn, y jtkjzoztzoes douwlr oj y ilzwex eq lsdexosa kn pwodw tsozj eq ufyoszlbz yrl rlufydlx pozw douwlrzlbz, ydderxosa ze y rlatfyr jnjzli; mjy gfbmw vla xy wbfnsy symmyew (mjy vrwm qrvvrf), hlbew rd symmyew, mebhsymw rd symmyew, vbomgeyw rd mjy lxrzy, lfk wr dremj. Mjy eyqybzye kyqbhjyew mjy myom xa hyedrevbfn lf bfzyewy wgxwmbmgmbrf. Wr mjy dsln bw f1_2jyf-k3_jg1-vb-vl_l 观察一下ASCII码其实发现不了什么，已经提示了是古典密码，那么应该是个字母置换，而且不会去除空格。恺撒什么的也都试过了，发现不了啥因为这一段比较长，所以可以用词频分析来解密，最后一句话很像是flag…https://quipqiup.com/第一个就得到1?l fog?vryoe?sg, e h?dhv?v?v?rl f??sao ?h e ?avsrb rc alfrb?ly dg ?s?fs ?l?vh rc ?ne?lvaiv eoa oa?nefab ??vs f??saovaiv, effrob?ly vr e oay?neo hghva?; the units may be single letters (the most common), pairs of letters, triplets of letters, mi?tures of the above, and so forth. The receiver deciphers the te?t by performing an inverse substitution. So the flag is n1_2hen-d3_hu1-mi-ma_a 所以1flag&#123;n1_2hen-d3_hu1-mi-ma_a&#125; zip伪加密感觉这题应该放在Misc…不知道为什么出现在这里伪加密就是并没有加密，然后装作加密的样子，用wxHexEditor打开，然后将两个50 4B 03 04 14 00 09 00都修改成50 4B 03 04 14 00 00 00就ok了，解压得到flag.txt。1flag&#123;Adm1N-B2G-kU-SZIP&#125; Alice与Bob1密码学历史中，有两位知名的杰出人物，Alice和Bob。他们的爱情经过置换和轮加密也难以混淆，即使是没有身份认证也可以知根知底。就像在数学王国中的素数一样，孤傲又热情。下面是一个大整数:98554799767,请分解为两个素数，分解后，小的放前面，大的放后面，合成一个新的数字，进行md5的32位小写哈希，提交答案。 注意：得到的 flag 请包上 flag&#123;&#125; 提交 直接用factordb查一下http://factordb.com/index.php?query=98554799767然后md5加密echo -n 101999966233 | md5sum，得到flag{d450209323a847c8d01c6be47c81811a} Misc签到1签到题 flag&#123;buu_ctf&#125; 金三胖一个gif，可以看到有很快的东西闪过用convert aaa.gif aaa.png将gif按帧分解得到三张包含flag的图片1flag&#123;he11ohongke&#125; 来首歌吧一首歌，下下来一听，感觉十分耳熟…然后听着听着感觉左耳聋了…左声道没声音，然后一会开始滴滴滴了，一听就是莫斯电码的样子…尝试用耳朵听…感觉听不过来…还是得用点工具用Audacity打开Audacity安装https://launchpad.net/~ubuntuhandbook1/+archive/ubuntu/audacity123sudo add-apt-repository ppa:ubuntuhandbook1/audacitysudo apt-get updatesudo apt-get install audacity 得到1..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-. 然后翻译出莫斯电码http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx15BC925649CB0188F52E617D70929191C 本来以为这个还被加密过，甚至查了一下md5，需要付费没想到flag就是这个…1flag&#123;5BC925649CB0188F52E617D70929191C&#125; 二维码扫一下得到secret is here用binwalk检测一下1234567binwalk QR_code.png DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 PNG image, 280 x 280, 1-bit colormap, non-interlaced471 0x1D7 Zip archive data, encrypted at least v2.0 to extract, compressed size: 29, uncompressed size: 15, name: 4number.txt650 0x28A End of Zip archive 发现有个zip 然后binwalk QR_code.png -e把压缩包搞出来然后发现压缩包加密了，里面有个文件叫4number.txt，也就提示了密码是4位数字，用fcrackzip来暴力破解123fcrackzip -b -c1 -u -l4 1D7.zip PASSWORD FOUND!!!!: pw == 7639 解压以后得到1CTF&#123;vjpw_wnoei&#125; 需提交1flag&#123;vjpw_wnoei&#125; 假如给我三天光明一个压缩包和一张图片海伦凯勒用盲文写的这本书，所以底下自然是盲文咯对照一下得到kmdonowg 用这个密码解压一下，发现解压不了…12345binwalk music.zip DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 RAR archive data, first volume type: MAIN_HEAD 这其实是一个rar…unrar e music.zip 得到music.wav，一听就是莫斯电码，用audacity打开得到1-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --.. 解密一下，莫斯电码英文是没有大小写的12CTFWPEI08732?23DZctfwpei08732?23dz 原题应该是提交CTF{wpei08732?23dz}这里就要提交flag{wpei08732?23dz} N种方法解决KEY.exe显然是运行不了..strings 查看一下 12strings KEY.exedata:image/jpg;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAACFCAYAAAB12js8AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAArZSURBVHhe7ZKBitxIFgTv/396Tx564G1UouicKg19hwPCDcrMJ9m7/7n45zfdxe5Z3sJ7prHbf9rXO3P4lLvYPctbeM80dvtP+3pnDp9yF7tneQvvmcZu/2lf78zhU+5i9yxv4T3T2O0/7eud68OT2H3LCft0l/ae9ZlTo+23pPvX7/rwJHbfcsI+3aW9Z33m1Gj7Len+9bs+PIndt5ywT3dp71mfOTXafku6f/2uD09i9y0n7NNd2nvWZ06Ntt+S7l+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTtDklqXMnsZxY33LCPiVtbpKUX7/rwwlzk7Q5JalzJ7GcWN9ywj4lbW6SlF+/68MJc5O0OSWpcyexnFjfcsI+JW1ukpRfv+vDCXOTWE7a/i72PstJ2zfsHnOTpPz6XR9OmJvEctL2d7H3WU7avmH3mJsk5dfv+nDC3CSWk7a/i73PctL2DbvH3CQpv37XhxPmJrGctP1d7H2Wk7Zv2D3mJkn59bs+nDA3ieWEfdNImylJnelp7H6bmyTl1+/6cMLcJJYT9k0jbaYkdaansfttbpKUX7/rwwlzk1hO2DeNtJmS1Jmexu63uUlSfv2uDyfMTWI5Yd800mZKUmd6Grvf5iZJ+fW7PjzJ7v12b33LSdtvsfuW75LuX7/rw5Ps3m/31rectP0Wu2/5Lun+9bs+PMnu/XZvfctJ22+x+5bvku5fv+vDk+zeb/fWt5y0/Ra7b/ku6f71+++HT0v+5l3+tK935vApyd+8y5/29c4cPiX5m3f5077emcOnJH/zLn/ar3d+/flBpI+cMDeNtJkSywn79BP5uK+yfzTmppE2U2I5YZ9+Ih/3VfaPxtw00mZKLCfs00/k477K/tGYm0baTInlhH36iSxflT78TpI605bdPbF7lhvct54mvWOaWJ6m4Z0kdaYtu3ti9yw3uG89TXrHNLE8TcM7SepMW3b3xO5ZbnDfepr0jmlieZqGd5LUmbbs7onds9zgvvU06R3TxPXcSxPrW07YpyR1pqTNKUmdKUmdk5LUaXzdWB/eYX3LCfuUpM6UtDklqTMlqXNSkjqNrxvrwzusbzlhn5LUmZI2pyR1piR1TkpSp/F1Y314h/UtJ+xTkjpT0uaUpM6UpM5JSeo0ft34+vOGNLqDfUosN7inhvUtJ+ybRtpMd0n39Goa3cE+JZYb3FPD+pYT9k0jbaa7pHt6NY3uYJ8Syw3uqWF9ywn7ppE2013SPb2aRnewT4nlBvfUsL7lhH3TSJvpLunecjWV7mCftqQbjSR1puR03tqSbkx/wrJqj7JPW9KNRpI6U3I6b21JN6Y/YVm1R9mnLelGI0mdKTmdt7akG9OfsKzao+zTlnSjkaTOlJzOW1vSjelPWFbp8NRImylJnWnL7r6F7zN3STcb32FppUNTI22mJHWmLbv7Fr7P3CXdbHyHpZUOTY20mZLUmbbs7lv4PnOXdLPxHZZWOjQ10mZKUmfasrtv4fvMXdLNxndYWunQlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K95SpLlFhutHv2W42n+4bds7wl3VuuskSJ5Ua7Z7/VeLpv2D3LW9K97avp6GQ334X3KWlz+tukb5j+hO2/hX3Ebr4L71PS5vS3Sd8w/Qnbfwv7iN18F96npM3pb5O+YfoTtv8W9hG7+S68T0mb098mfcP0Jxz/W+x+FPethvUtN2y/m7fwnvm1+frzIOklDdy3Gta33LD9bt7Ce+bX5uvPg6SXNHDfaljfcsP2u3kL75lfm68/D5Je0sB9q2F9yw3b7+YtvGd+bb7+vCEN7ySpMzXSZrqL3bOcsN9Kns4T2uJRk6TO1Eib6S52z3LCfit5Ok9oi0dNkjpTI22mu9g9ywn7reTpPKEtHjVJ6kyNtJnuYvcsJ+y3kqfzxNLiEUosJ+xTYvkudt9yg3tqpM2d5Cf50mKJEssJ+5RYvovdt9zgnhppcyf5Sb60WKLEcsI+JZbvYvctN7inRtrcSX6SLy2WKLGcsE+J5bvYfcsN7qmRNneSn+RLK5UmbW4Sywn7lOzmhH3a0u7ZN99hadmRNjeJ5YR9SnZzwj5taffsm++wtOxIm5vEcsI+Jbs5YZ+2tHv2zXdYWnakzU1iOWGfkt2csE9b2j375jtcvTz+tuX0vrXF9sxNkjrTT+T6rvyx37ac3re22J65SVJn+olc35U/9tuW0/vWFtszN0nqTD+R67vyx37bcnrf2mJ75iZJneknUn+V/aWYUyNtpqTNqZE2UyNtGlvSjTsT9VvtKHNqpM2UtDk10mZqpE1jS7pxZ6J+qx1lTo20mZI2p0baTI20aWxJN+5M1G+1o8ypkTZT0ubUSJupkTaNLenGnYnl6TujO2zP3DTSZkp2c8L+0xppM32HpfWTIxPbMzeNtJmS3Zyw/7RG2kzfYWn95MjE9sxNI22mZDcn7D+tkTbTd1haPzkysT1z00ibKdnNCftPa6TN9B2uXh5/S9rcbEk37jR2+5SkzpSkzo4kdaavTg6/JW1utqQbdxq7fUpSZ0pSZ0eSOtNXJ4ffkjY3W9KNO43dPiWpMyWpsyNJnemrk8NvSZubLenGncZun5LUmZLU2ZGkzvTVWR/e0faJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBdac72vaJ7Xdzw/bMKbGc7PbNE1x3uqNtn9h+Nzdsz5wSy8lu3zzBcsVewpyS1LmTWG7Y3nLCPm1JN05KLP/D8tRGzClJnTuJ5YbtLSfs05Z046TE8j8sT23EnJLUuZNYbtjecsI+bUk3Tkos/8Py1EbMKUmdO4nlhu0tJ+zTlnTjpMTyP/R/i8PwI//fJZYb3Jvv8Pd/il+WWG5wb77D3/8pflliucG9+Q5//6f4ZYnlBvfmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9PH7KFttbfhq+zySpMyVtbr7D1cvjp2yxveWn4ftMkjpT0ubmO1y9ftRg9y0n7FPD+paTtk9O71sT13Mv7WD3LSfsU8P6lpO2T07vWxPXcy/tYPctJ+xTw/qWk7ZPTu9bE9dzL+1g9y0n7FPD+paTtk9O71sT1/P7EnOTWG5wb5LUmRptn3D/6b6+eX04YW4Syw3uTZI6U6PtE+4/3dc3rw8nzE1iucG9SVJnarR9wv2n+/rm9eGEuUksN7g3SepMjbZPuP90X9+8PpwwN0mb72pYfzcn1rf8NHwffXXWhxPmJmnzXQ3r7+bE+pafhu+jr876cMLcJG2+q2H93ZxY3/LT8H301VkfTpibpM13Nay/mxPrW34avo++OuvDCXOT7OZGu7e+5YT9XYnlhH36DlfvfsTcJLu50e6tbzlhf1diOWGfvsPVux8xN8lubrR761tO2N+VWE7Yp+9w9e5HzE2ymxvt3vqWE/Z3JZYT9uk7XL1+1GD3LX8avt8klhu2t5yc6F+/68OT2H3Ln4bvN4nlhu0tJyf61+/68CR23/Kn4ftNYrlhe8vJif71uz48id23/Gn4fpNYbtjecnKif/3+++HTnub0fd4zieUtvLfrO1y9PH7K05y+z3smsbyF93Z9h6uXx095mtP3ec8klrfw3q7vcPXy+ClPc/o+75nE8hbe2/Udzv9X+sv/OP/881/SqtvcdpBh+wAAAABJRU5ErkJggg== 这是一个jpg转成了base64，还原回去就好了http://imgbase64.duoshitong.com/或者直接把上面一段丢到浏览器地址栏里就可以显示了扫一扫得到1KEY&#123;dca57f966e4e4e31fd5b15417da63269&#125; 提交1flag&#123;dca57f966e4e4e31fd5b15417da63269&#125; 镜子里面的世界题目就一张图片用StegSolve查看一下，这就是一个LSB，查看RGB最后一位，发现只有前面一段有信息，3个合在一起查看就看到了123456784865792049207468 696e6b2077652063 Hey I th ink we c616e207772697465 20736166656c7920 an write safely 696e207468697320 66696c6520776974 in this file wit686f757420616e79 6f6e652073656569 hout any one seei6e672069742e2041 6e797761792c2074 ng it. A nyway, t6865207365637265 74206b6579206973 he secre t key is3a2073743367305f 7361757275735f77 : st3g0_ saurus_w7233636b73000000 0000000000000000 r3cks... ........ 得到1flag&#123;st3g0_ saurus_wr3cks&#125; 你竟然赶我走题目一张图片用wxHexEditor查看一下，翻到最后1flag IS flag&#123;stego_is_s0_bor1ing&#125; LSB题目都提示到这份上了…就是LSB，用StegSolve查看，然后可以发现前几个字符123489504e470d0a1a0a 0000000d49484452 .PNG.... ....IHDR0000011800000118 080200000008ec7e ........ .......~db00000542494441 54789ceddd416e23 ....BIDA Tx...An#391000416931ffff b2f707c480932e57 9..Ai1.. .......W 把这个二进制导出成一个png文件就得到一个二维码扫一下得到1cumtctf&#123;1sb_i4_s0_Ea4y&#125; 提交1flag&#123;1sb_i4_s0_Ea4y&#125; 基础破解题目1给你一个压缩包，你并不能获得什么，因为他是四位数字加密的哈哈哈哈哈哈哈。。。不对= =我说了什么了不得的东西。。 注意：得到的 flag 请包上 flag&#123;&#125; 提交 提示了4位数字密码，给了一个rar文件，用一下rarcrack rarcrack 1.rar --threads 4 --type rar他会生成一个1.rar.xml文件，修改一下123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;rarcrack&gt; &lt;abc&gt;0123456789&lt;/abc&gt; &lt;current&gt;0000&lt;/current&gt; &lt;good_password/&gt;&lt;/rarcrack&gt; 再运行一下1234567891011RarCrack! 0.2 by David Zoltan Kedves (kedazo@gmail.com)INFO: the specified archive type: rarINFO: cracking 1.rar, status file: 1.rar.xmlINFO: Resuming cracking from password: &apos;0000&apos;Probing: &apos;0437&apos; [144 pwds/sec]Probing: &apos;0882&apos; [148 pwds/sec]Probing: &apos;1332&apos; [150 pwds/sec]Probing: &apos;1776&apos; [148 pwds/sec]Probing: &apos;2217&apos; [147 pwds/sec]GOOD: password cracked: &apos;2563&apos; 解压以后得到flag.txt1ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30= 解密一下base641flag&#123;70354300a5100ba78068805661b93a5c&#125; FLAG给了一个png，也是LSB，文件头123504b030414000000 0800dd855d49fd91 PK...... ....]I..e24cd90800003d21 00000100000031ed .L....=! ......1.5959cc0b5114be1d b5336aafbdb10589 YY..Q... .3j..... 可以看到是一个压缩包，导出成压缩包，直接解压就可以了，没有密码得到一个1，然后用wxHexEditor查看一下，可以找到一行1hctf&#123;dd0gf4c3tok3yb0ard4g41n~~~&#125; 提交1flag&#123;dd0gf4c3tok3yb0ard4g41n~~~&#125; 乌镇峰会种图常规一套binwalk, strings, wxHexEditor结果strings一下就得到了1flag&#123;97314e7864a8f62627b26f3f998c37f1&#125; 喵喵喵 (unfinished)还没做完…后面不太了解了，先记录一下一张图片binwalk检查一下应该是LSB隐写，然后用StegSolve打开，确实有隐藏的信息，但是很乱，然后我把右下角的顺序随便换了些，当换成BGR时，可以看到一个PNG图片然后savebin保存成PNG，然鹅并不能打开，用wxHexEditor打开，发现头部和尾部有多余的信息PNG文件起始和结束的一段分别是1234.PNG89 50 4E 47 0D 0A 1A 0AIEND00 00 00 00 49 45 4E 44 AE 42 60 82 把这一段提取出来保存成PNG，然鹅还是打不开，CRC错误，然后用StegSolve可以打开，然鹅二维码只有一半…根本扫不了又查了一下PNG文件结构，IHDR位置第1和第2个参数分别是宽高，直接在wxHexEditor中修改高度跟宽度一样，再用StegSolve打开然后又扫不出来了…把它异或一下扫完得到一个百度云的地址https://pan.baidu.com/s/1pLT2J4f下下来一个rar，解压以后有一个flag.txt，然鹅里面却写着…1flag不在这里哦 你猜猜flag在哪里呢？ 找找看吧 用wxHexEditor打开rar，发现里面其实有一个flag.pyc文件，然鹅现在不知道怎么解压出来 rar这个是一个rar文件，里面好像隐藏着什么秘密，但是压缩包被加密了，毫无保留的告诉你，rar的密码是4位纯数字。 注意：得到的 flag 请包上 flag{} 提交提示了4位数字密码，给了一个rar文件，用一下rarcrack rarcrack 1.rar --threads 4 --type rar生成一个1.rar.xml文件，修改一下123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;rarcrack&gt; &lt;abc&gt;0123456789&lt;/abc&gt; &lt;current&gt;0000&lt;/current&gt; &lt;good_password/&gt;&lt;/rarcrack&gt; 再运行一下1234567891011121314151617181920212223242526RarCrack! 0.2 by David Zoltan Kedves (kedazo@gmail.com)INFO: the specified archive type: rarINFO: cracking 1.rar, status file: 1.rar.xmlINFO: Resuming cracking from password: &apos;0000&apos;Probing: &apos;0442&apos; [146 pwds/sec]Probing: &apos;0882&apos; [146 pwds/sec]Probing: &apos;1324&apos; [147 pwds/sec]Probing: &apos;1755&apos; [143 pwds/sec]Probing: &apos;2183&apos; [142 pwds/sec]Probing: &apos;2589&apos; [135 pwds/sec]Probing: &apos;2999&apos; [136 pwds/sec]Probing: &apos;3410&apos; [137 pwds/sec]Probing: &apos;3831&apos; [140 pwds/sec]Probing: &apos;4261&apos; [143 pwds/sec]Probing: &apos;4683&apos; [140 pwds/sec]Probing: &apos;5099&apos; [138 pwds/sec]Probing: &apos;5498&apos; [133 pwds/sec]Probing: &apos;5920&apos; [140 pwds/sec]Probing: &apos;6355&apos; [145 pwds/sec]Probing: &apos;6801&apos; [148 pwds/sec]Probing: &apos;7230&apos; [143 pwds/sec]Probing: &apos;7661&apos; [143 pwds/sec]Probing: &apos;8076&apos; [138 pwds/sec]Probing: &apos;8487&apos; [137 pwds/sec]GOOD: password cracked: &apos;8795&apos; 解压就得到flag.txt1flag&#123;1773c5da790bd3caff38e3decd180eb7&#125; Mobile]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网(IoT)笔记]]></title>
    <url>%2F2019%2F05%2F30%2Fnote-iot%2F</url>
    <content type="text"><![CDATA[物联网物联网(Internet of Things, IoT) MCU(Microprocessor Unit) 微处理器， 其实就是CPU，可运行命令、进行运算和逻辑处理MPU(Microcontroller Unit) 单片机，把微处理器(MCU)、快晒存储器和主存储器(内存)包在同一芯片里SoC(System on a Chip) 系统芯片，机器微处理器和特定功能树莓派 一种基于Linux系统的单片机, SoC 参考 完美图解物联网IoT实操. ESP8266 Arduino，Cordova物联网移动App， JavaScript微控制器编程 / 赵英杰著.—北京：电子工业出版社，2018.9]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得算法与扩展欧几里得算法]]></title>
    <url>%2F2019%2F05%2F29%2Falgorithm-exgcd%2F</url>
    <content type="text"><![CDATA[gcdLet $\gcd(a,b)=\left( a, b\right)=r$Then $a=pr, b=qr, a \pmod b=a-kb=pr-kqr \mid r$$\Rightarrow \gcd(a,b) = \gcd(b, a\%b)$ Then we prove that the gcd is max gcd.(Oh, my poor English.)There are two ways to prove it.First Way:Presume that $r$ is the maxium gcd(a,b), and $r$ is different from $r’$ which is the maxium $\gcd(b, a\% b)$.It means $r &gt; r’$.$a=pr, b=qr, a\% b=pr-kqr$$r\mid b, r\mid (a\% b), r&gt;r’$so $r$ is maxium $\gcd(b, a\% b)$, it’s against to the condition which we presumed.so $r$ is the maxium $\gcd(a, b)$ and $\gcd(a, a\% b)$. Second Way:Let set $A$ be all factor of $\gcd(a, b)$, and let set $B$ be all factor of $\gcd(b, a\% b)$. if $d\in A$, $a=pd, b=qd, a\% b=pd-kqd$so $d\mid (a\% b), d\in B$ if $d\in B$, $b=pd, a\% b=qd, a=kqd + pd$so $d \mid a, d\in A$ It means $A=B$, so $\gcd(a,b)_{max}=\gcd(b, a\% b)_{max}$ 1234def gcd(a, b): if(b==0): return a return gcd(b, a%b) 123int gcd(int a, int b) &#123; return b?gcd(b, a%b):a;&#125; exgcdxa + by = rx(\left \lfloor \frac{a}{b} \right \rfloor\times b + a\% b) + yb = r(x\left \lfloor \frac{a}{b} \right \rfloor+y)b + xa\% b=r\left\{\begin{matrix} x'=x\left \lfloor \frac{a}{b} \right \rfloor+y\\ y'=x\end{matrix}\right.\Rightarrow \left\{\begin{matrix}x=y'\\ y=x'-y'\left \lfloor \frac{a}{b} \right \rfloor\end{matrix}\right.123456789def exgcd(a, b):# if(a&lt;b):# a, b = b, a if(b==0): return 1, 0, a x1, y1, r = exgcd(b, a%b) x = y1 y = x1-(a//b)*y1 return x, y, r 123456789int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if(!b) &#123; x=1, y=0; return a; &#125; int d = exgcd(b, a%b, y, x); y-=(a/b)*x; return d;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>gcd</tag>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记]]></title>
    <url>%2F2019%2F05%2F28%2Fnote-python-scratch%2F</url>
    <content type="text"><![CDATA[最简单的爬虫获取标题， 并捕获异常我爬我自己 12345678910111213141516171819202122232425from urllib.request import urlopenfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSoupdef getTitle(url): try: html = urlopen(url) except HTTPError as e: return None try: bsObj = BeautifulSoup(html.read()) title = bsObj.body.h1 except AttributeError as e: return None tmp = bsObj.findAll("", &#123;"class": "headerlink"&#125;) for obj in tmp: print(obj) return title.get_text()tit = getTitle("https://beiyuouo.github.io/2019/05/26/note-matlab/")if tit != None: print(tit)else: print("None")]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>python</tag>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MATLAB笔记]]></title>
    <url>%2F2019%2F05%2F26%2Fnote-matlab%2F</url>
    <content type="text"><![CDATA[MATLAB简介Matrix Laboratory 是一门高级程序设计语言建立在C/C++语言基础之上特点： 变量可以当作矩阵 元素可以当作复数 解释语言 数据可实现可视化 数值运算、符号运算、系统仿真 工具箱 有C、FORTRAN、Word接口 基本语法下标从1开始…都是矩阵以分号结束则不显示计算结果，不加分号显示计算结果%为注释 数组基本定义以方括号为界限，两行之间用分号，各行匀速必须相同 冒号生成符1-10 12345678A=1:10A=1:3:10 % A=起始:[步长:]终止A=linspace(-pi,pi,50) % 将[-pi，pi] n等分A=zero(3,3) % 3x3 0矩阵A=one(3,3) % 3x3 全1矩阵A=eye(3,3) % 3x3 单位矩阵A=rand(3,3) % 0-1均匀分布随机数矩阵A=randn(3,3) % 标准正态分布矩阵 数据元素存取操作123456A(1) % 第一个元素A(1, 2)A(1, :) % 第一行A(:, 1) % 第一列A(m1, m2, n1, n2) % 子矩阵size(A) % 返回A的行列 算术运算123456789101112% 矩阵运算A+BA-BA*B % ABA/B % AB^&#123;-1&#125;A\B % A^&#123;-1&#125;B 锐角对应的是分母A^2% 数组运算A.*B % 对应相乘A./B % 对应相除A.^2 % 对应拼房 数组变形12C=[A B]C=[A; B]]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESP8266做WiFi杀手]]></title>
    <url>%2F2019%2F05%2F23%2Fesp-wifikiller%2F</url>
    <content type="text"><![CDATA[自己在网上买了个esp9266+OLED显示屏然鹅…不会把两个东西连起来一开始用的数据线也是坏的，我真是fo了… 把esp连上电脑，然后直接烧录…那个标准版本里无屏幕的烧录以后不成功的说，打不开192.168.4.1虽然我没屏幕，烧录的有屏幕的也可以，然后就可以连上了嗷 注意烧录完要按一下rst 这几个攻击模式，第一个是不让认证的，谁都连不上的那种第二个是建最多48个假WiFi第三个是自己当一个假WiFi让客户端误以为是原来的WiFi ps. 最近给文章地址和图片地址重命名的比较多，可能很多链接都失效了]]></content>
      <categories>
        <category>esp</category>
      </categories>
      <tags>
        <tag>esp</tag>
        <tag>wifikiller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDCTF WriteUP]]></title>
    <url>%2F2019%2F05%2F21%2Fctf-HDCTF1%2F</url>
    <content type="text"><![CDATA[http://ctf-hainu.com/ 蒟蒻看大佬秒题现场忽然得知周六白天有事情，只好周日参加了233 然鹅周六去划水反而做了题，周日一天反而什么都没做233 听说CTF的解题报告叫WriteUP… 第一次打CTF只做了3道Web 1道Misc 2道Crypto 做的时候没保存数据…只好等网站重新开了哈哈哈哈 update 20190521 18:50 MISCT1 Welcome 10Description加❤裙+看🚺FlagSolution一个加群的二维码…flag在这里… WEBT1 欢迎来到HDCTF 50http://149.28.22.177:10000/0.html打开以后，有一段话123欢迎进入HDCTF！只需改变一个数字你将进入另一个世界 进入-&gt;http://149.28.22.177:10000/1.html又有一段话123456你已经踏上了成为黑客 的道路希望你有足够的耐心拿到这道题的flag你将成为真正的HD黑客A system without security 右键查看源代码，flag就在里面1&lt;span lang="en-us"&gt;&lt;b&gt;&lt;font face="Comic Sans MS" size="6"&gt;A system without security&lt;/font&gt;&lt;!--flag&#123;welcome_t0_HDctf&#125;--&gt;&lt;/b&gt;&lt;/span&gt;&lt;/p&gt; 表示这对于一个nazo通关的人来说…so easy…所以我一直觉得CTF其实和Nazo真的有些像的 T2 测试你与flag的缘分 100常规编码啦 链接：http://149.28.22.177:10001/12常规编码啦~flag.txt这个就是文档了，对不对我可不敢保证，你看你能不能解出来吧。 flag.txt提供了一个超链接来下载nazo有道题跟这个挺像的，一看就是Js代码，丢进console里运行，得到13D45353D39333D38383D45353D39333D38383D45353D39333D38383D45353D39333D38382C3D45343D42443D41303D45383D41323D41423D45393D41413D39373D45343D42413D38362C3D0A3D45343D42383D38443D45363D39383D41463D45383D42463D39393D45343D42383D41412C3D45353D42303D42313D45393D39373D41453D45343D42443D41303D45383D41373D41333D0A3D45343D42413D38363D45353D38443D38413D45353D41343D41393D45363D42303D39343D45343D42383D38443D45363D42303D3934 这个编码只有数字和ABCD那应该是16进制的，转成ASCII码，网站http://www.ab126.com/goju/1711.html得到123=E5=93=88=E5=93=88=E5=93=88=E5=93=88,=E4=BD=A0=E8=A2=AB=E9=AA=97=E4=BA=86,==E4=B8=8D=E6=98=AF=E8=BF=99=E4=B8=AA,=E5=B0=B1=E9=97=AE=E4=BD=A0=E8=A7=A3==E4=BA=86=E5=8D=8A=E5=A4=A9=E6=B0=94=E4=B8=8D=E6=B0=94 这个编码有很多等号，后面跟两位16进制的数，是Quoted-printable编码，网站http://web.chacuo.net/charsetquotedprintable得到1哈哈哈哈,你被骗了,不是这个,就问你解了半天气不气 wdnmd…重新看了一遍题目，好像出题人确实暗示了….对不对我可不敢保证…右键查看源代码，发现一个隐藏的div12345&lt;div&gt;&lt;p style="display: none"&gt;能看到这个，证明你没有被利益迷住了眼睛&lt;/p&gt;&lt;p style="display: none"&gt;5530565352465a46576a6454626b35745a46644f636c6836526e70594d6e64335a47315763325654526a6b3d&lt;/p&gt;&lt;p style="display: none"&gt;emmmm，如果你是解过jsfuck才看到的这个，不要打出题人。。。&lt;/p&gt;&lt;/div&gt; 这一看以为还是16进制转ASCII，结果解出来是乱码..经过一番搜索，发现Hex编码也是这样子的，网站https://www.107000.com/T-Hex/解码后1U0VSRFZFWjdTbk5tZFdOclh6RnpYMnd3ZG1Wc2VTRjk= 最后…base64解码一下1SERDVEZ7SnNmdWNrXzFzX2wwdmVseSF9 再解码一次1HDCTF&#123;Jsfuck_1s_l0vely!&#125; T3 简单的代码审计 200http://149.28.22.177:10003/右键查看源代码，有一行注释1&lt;!--hint:file=once.php--&gt; 打开 http://149.28.22.177:10003/once.php让你输入密码 有一个提示 “You password must be alphanumeric”php代码审计里，好像可以跳过正则的检查，有两种方式一种是%0空字符终止检查，一种是传入数组第一种方式是不行滴第二种打开http://149.28.22.177:10003/once.php?password[]=得到1Flag: HDCTF&#123;Is_V3ry_1nteresting!&#125; 第四道题sql注入可能我姿势太辣鸡，试了好多都成功不了，就放弃了… CRYPTOT1 basic rsa 50这可能是最最最最简单的 rsa 了密文：127565231154623519221597938803435789010285480123476977081867877272451638645710 关于rsa 总之记住几个重要的式子 p,q是大质数N=p\times q\varphi(N)=\varphi(p)\varphi(q)=(p-1)(q-1)e和\varphi(N)互质,ed\equiv 1\pmod{\varphi(N)}加密 m^e\equiv c\pmod N解密 c^d\equiv m\pmod N因为当时在海师大的机房做的，Windows下，Python3，代码是Python2还有库，修改了一下encode.py12345678910111213141516#import gmpy2#from Crypto.Util.number import *from binascii import a2b_hex,b2a_hexflag = "*****************"p = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533n = p*qprint(b2a_hex(flag))c = pow(int(b2a_hex(flag),16),e,n)print(c) 看一下encode代码，其实几乎所有参数都告诉了，我们要做的就是算一下d就完事了因为没导入库什么的，我直接手写的扩展欧几里得最后得到一串数字以后还要再搞一下…先转成hex，然后去掉前面的0x，再输出就行了decode.py1234567891011121314151617181920212223242526272829303132from math import gcdimport mathfrom binascii import a2b_hex,b2a_hexp = 262248800182277040650192055439906580479q = 262854994239322828547925595487519915551e = 65533n = p*qc = 27565231154623519221597938803435789010285480123476977081867877272451638645710phi = (p-1)*(q-1)def ex_gcd(dividend, divisor): if 0 == divisor: return 1, 0, dividend x2, y2, remainder = ex_gcd(divisor, dividend % divisor) x1 = y2 y1 = x2 - (dividend // divisor) * y2 return x1, y1, remainder# print(gcd(e,phi))# print(ex_gcd(20,17))# print(ex_gcd(e,phi))x1, y1, rr = ex_gcd(e,phi)# print((x1*e+y1*phi)%phi)d = x1+phi# print(d*e%phi)m = pow(c,d,n)print(hex(m))print(str(hex(m)))print(str(hex(m))[2::1])print(a2b_hex(str(hex(m))[2::1])) 得到1b&apos;flag&#123;B4by_Rs4&#125;&apos; T2 bbbbbbrsa 100babyrsa，还是一道 RSA 的题目~ 同样encode.py123456789101112131415161718192021222324252627282930from base64 import b64encode as b32encodefrom gmpy2 import invert,gcd,irootfrom Crypto.Util.number import *from binascii import a2b_hex,b2a_heximport randomflag = "******************************"nbit = 128p = getPrime(nbit)q = getPrime(nbit)n = p*qprint pprint nphi = (p-1)*(q-1)e = random.randint(50000,70000)while True: if gcd(e,phi) == 1: break; else: e -= 1;c = pow(int(b2a_hex(flag),16),e,n)print b32encode(str(c))[::-1] enc123p = 177077389675257695042507998165006460849n = 37421829509887796274897162249367329400988647145613325367337968063341372726061c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM 这次给了$p,n,c$，$e$是$[50000,70000)$之内随机一个合法的，反正就2w枚举$e$就行了注意代码最后一个很鸡贼的地方，倒着输出了，其实也能看出来$c$的base64等号在后面还有一个地方就是import的时候，from base64 import b64encode as b32encode233333看似base32其实就是base64$c$解码后12373740699529364991763589324200093466206785561836101840381622237225512234632 把所有的合法的全部输出decode.py12345678910111213141516171819202122232425262728from binascii import a2b_hex,b2a_hexfrom math import gcdn = 37421829509887796274897162249367329400988647145613325367337968063341372726061p = 177077389675257695042507998165006460849q = n//pphi = (p-1)*(q-1)c = 2373740699529364991763589324200093466206785561836101840381622237225512234632def ex_gcd(dividend, divisor): if 0 == divisor: return 1, 0, dividend x2, y2, remainder = ex_gcd(divisor, dividend % divisor) x1 = y2 y1 = x2 - (dividend // divisor) * y2 return x1, y1, remainderfor e in range(50000,70001): if gcd(e, phi) == 1: d=ex_gcd(e, phi)[0] d=(d+phi)%phi m=pow(c,d,n) ss=str(hex(m))[2::1] if(len(ss)%2==1): continue print(a2b_hex(ss)) 然后输出到文件，查找flag，得到1b&apos;flag&#123;rs4_1s_s1mpl3!#&#125;&apos; Summary第一次打CTF，Capture The Flag， 感觉还是蛮有意思的，知识面比较广，面向的都是安全问题这是第一届HDCTF，学长办的，总是非常感谢学长将CTF竞赛搬来让我们了解吧这次题貌似不难，甚至比较简单，（虽然我也不会剩下的题解有空就补Thx for H4lo! update 20190523 16:30]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用wireshark hark一次tplink的管理员登录]]></title>
    <url>%2F2019%2F05%2F19%2Fhack-wiresharktplink%2F</url>
    <content type="text"><![CDATA[听说tplink的管理员登录有蛮大漏洞的…记一次用wireshark捕获password 首先打开wireshark，选择捕获wlan0，无线网卡 点击开始，然后打开tplogin.cn登录账户 然后结束捕获，在捕获的结果中寻找http相关的流，然后追踪 发现一条登录相关的流，追踪以后可以发现password tplogin中password加密相关的函数在class.js中，搜索encode就可以发现 把这段函数拿出来12345678910orgAuthPwd=function(a) &#123; return securityEncode(a,"RDpbLfCPsJZ7fiv","yLwVl0zKqws7LgKPRQ84Mdt708T1qQ3Ha7xv3H7NyU84p21BriUWBU43odz3iP4rBL3cD02KZciXTysVXiV8ngg6vL48rPJyAUw0HurW20xqxv9aYb4M9wK1Ae0wlro510qXeU07kV57fQMc8L6aLgMLwygtc0F10a0Dg70TOoouyFhdysuRMO51yY5ZlOZZLEal1h0t9YQW0Ko7oBwmCAHoic4HYbUyVeU3sfQ1xtXcPcf1aT303wAQhv66qzW")&#125;;securityEncode=function(a,c,b) &#123; var d="",e,f,g,h,k=187,l=187; f=a.length;g=c.length;h=b.length;e=f&gt;g?f:g; for(var m=0;m&lt;e;m++) l=k=187,m&gt;=f?l=c.charCodeAt(m):m&gt;=g?k=a.charCodeAt(m):(k=a.charCodeAt(m),l=c.charCodeAt(m)),d+=b.charAt((k^l)%h); return d&#125;; 可以发现他其实是一位一位加密的，每位独立的话，那挨个枚举就好了，首先枚举位数，在枚举每一位的字符，查看和加密后的是否相同。我写了一个html代码来运行JavaScript 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="cnv1" width="300" height="600"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt;orgAuthPwd=function(a) &#123; return securityEncode(a,"RDpbLfCPsJZ7fiv","yLwVl0zKqws7LgKPRQ84Mdt708T1qQ3Ha7xv3H7NyU84p21BriUWBU43odz3iP4rBL3cD02KZciXTysVXiV8ngg6vL48rPJyAUw0HurW20xqxv9aYb4M9wK1Ae0wlro510qXeU07kV57fQMc8L6aLgMLwygtc0F10a0Dg70TOoouyFhdysuRMO51yY5ZlOZZLEal1h0t9YQW0Ko7oBwmCAHoic4HYbUyVeU3sfQ1xtXcPcf1aT303wAQhv66qzW")&#125;;securityEncode=function(a,c,b) &#123; var d="",e,f,g,h,k=187,l=187; f=a.length;g=c.length;h=b.length;e=f&gt;g?f:g; for(var m=0;m&lt;e;m++) l=k=187,m&gt;=f?l=c.charCodeAt(m):m&gt;=g?k=a.charCodeAt(m):(k=a.charCodeAt(m),l=c.charCodeAt(m)),d+=b.charAt((k^l)%h); return d&#125;;decode=function(c, b) &#123; var a=""; var d="xbZ60JKy9TefbwK"; var k=187, l=187; var e=c.length; var h=b.length; var g=c.length; var res=""; for(var f=0; f&lt;e;f++) &#123; res="" for(var i=0; i&lt;e; i++) &#123; l=k=187; for(var j=0; j&lt;128; j++) &#123; i&gt;=f?l=c.charCodeAt(i):i&gt;=g?k=j:k=j,l=c.charCodeAt(i); if(b.charAt((k^l)%h)==d.charAt(i)) &#123; console.log(j) res+=String.fromCharCode(j); break; &#125; &#125; &#125; console.log(res); console.log("\n----\n");&#125;&#125;cc="RDpbLfCPsJZ7fiv";dd="yLwVl0zKqws7LgKPRQ84Mdt708T1qQ3Ha7xv3H7NyU84p21BriUWBU43odz3iP4rBL3cD02KZciXTysVXiV8ngg6vL48rPJyAUw0HurW20xqxv9aYb4M9wK1Ae0wlro510qXeU07kV57fQMc8L6aLgMLwygtc0F10a0Dg70TOoouyFhdysuRMO51yY5ZlOZZLEal1h0t9YQW0Ko7oBwmCAHoic4HYbUyVeU3sfQ1xtXcPcf1aT303wAQhv66qzW";decode(cc,dd);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如图，因为不知道长度，所以长度太长和太短都不合适，无法登录，中间长度和输入密码长度差不多的都可以登录，大概有3-4个的样子是可以成功登录的 登录成功]]></content>
      <categories>
        <category>hack</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>hark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析与挖掘笔记]]></title>
    <url>%2F2019%2F05%2F16%2Fnote-dataanalysisandmining%2F</url>
    <content type="text"><![CDATA[准备工作Python相关的第三方库 Numpy Scipy Matplotlib Pandas Scikit-Learn Keras Gensim Anaconda发行版自带了Numpy, Scipy, Matplotlib, Pandas, Scikit-Learn 数据探索数据质量分析脏数据包括以下内容 缺失值 异常值 不一致的值 重复数据及含有特殊符号的数据 数据特征分析 分布分析 对比分析]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>data_analysis</tag>
        <tag>data_mining</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anaconda安装 & 人脸识别]]></title>
    <url>%2F2019%2F05%2F16%2Finstall-anaconda%2F</url>
    <content type="text"><![CDATA[一个数据科学的Python库，我从这里下的Python 安装opencv 1pip3 install opencv-python 安装dlib 和 face_recognition 12pip install dlibpip install face_recognition face_recognition依赖dlib，如果安装dlib报了一个cmake的错误，因为没有c编译器，所以pip install cmake 就好了 查看视频设备 1ls /dev/video* 一个简单的人脸识别代码123456789101112131415161718192021222324252627282930313233343536# face_detector.py# import librariesimport cv2import face_recognition# Get a reference to webcam video_capture = cv2.VideoCapture("/dev/video0")# Initialize variablesface_locations = []while True: # Grab a single frame of video ret, frame = video_capture.read() # Convert the image from BGR color (which OpenCV uses) to RGB color (which face_recognition uses) rgb_frame = frame[:, :, ::-1] # Find all the faces in the current frame of video face_locations = face_recognition.face_locations(rgb_frame) # Display the results for top, right, bottom, left in face_locations: # Draw a box around the face cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # Display the resulting image cv2.imshow('Video', frame) # Hit 'q' on the keyboard to quit! if cv2.waitKey(1) &amp; 0xFF == ord('q'): break# Release handle to the webcamvideo_capture.release()cv2.destroyAllWindows() 参考https://www.analyticsvidhya.com/blog/2018/12/introduction-face-detection-video-deep-learning-python/]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arduino安装]]></title>
    <url>%2F2019%2F05%2F14%2Finstall-arduino%2F</url>
    <content type="text"><![CDATA[我在先Windows下安装的..直接贴网址算了…https://www.arduino.cn/thread-82298-1-1.htmlhttps://www.arduino.cn/thread-5838-1-1.html 历时n个小时后，终于下完装完了？？这下载速度也太慢了吧… update 20190514 22:25]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>arduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali下载 & 安装]]></title>
    <url>%2F2019%2F05%2F14%2Finstall-kali%2F</url>
    <content type="text"><![CDATA[找到一个kali的下载地址…http://cdimage.kali.org/ i386 - 32位处理器amd64 - 64位处理器 KDE - Kool Desktop Environmentxfce - Xtra fine computing environment轻量级桌面lxde - 基于GTK2的美观和国际化的桌面环境light - 轻量级系统 我下的是kali-linux-xfce-2019.1-amd64.iso 然后跟安装Ubuntu差不多…用UltraISO把磁盘映像写到U盘里。好久没装系统，这软件都快忘怎么用了…要先打开再写到磁盘映像。注意这个写入方式要改一下，不然安装不了！！！！！改成RAW 然后从U盘启动，图形化安装… 我会说我装了3遍才装到移动硬盘里打开吗？？？？？安装的时候分区一个主分区Ext4挂载/， 一个逻辑分区swap， 不需要boot因为我不想把整个盘都装上，所以手动分区，/ 256G, swap 8.5G最后把GRUB引导添加到sdc我移动硬盘，然后启动就一个-？？？我以为是我哪步搞错了，又重新试了一下，还是一个-？？？？最后看到一个装双系统的，他把引导挂到了某个分区，我试了一下，挂到了/dev/sdc1成功了？？？？？？我？？？？ 我是一个Kali安装时长6h的个人练习生。 然后用root登进去以后，新建了一个用户，我只写了useradd beiyu，然后….进不去…要useradd -m beiyu这样才能建立用户目录…passwd修改密码，userdel 删除用户，cat /etc/passwd 可以查看用户暂时先写这么多… update: 20190514 14:18 一开始以用户登录不显示路径…上下键还没法查历史命令…原来是bash没设置…12/bin/shchsh -s /bin/bash beiyu logout注销重登才生效 没法sudo命令1234su rootvisudoroot ALL=(ALL:ALL) ALLbeiyu ALL=(ALL) ALL 安装 及其依赖12dpkg -i *.debsudo apt-get -f install chrome extensionchrome更新后无法直接拖入插件了，要进入开发者模式，然后把插件当成zip解压再安装development mode - unzip ggfwzs.crx - install update: 20190514 20:05 root 无法打开chrome 需要加—no-sandbox update: 20190515 18:35 忽然发现之前安装不了依赖的原因是自己更新了源却没有update apt…1apt-get install update 另外截图工具：scrot update: 20190519 13:09]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>kali</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoderSRM755Div1]]></title>
    <url>%2F2019%2F04%2F18%2Fpro-TopCoderSRM755%2F</url>
    <content type="text"><![CDATA[Google CodeJam Round1A没赶上做，刚好有场SRM，然后就打了当场只做了T1…T2没调完…果然老年人…好久没做Topcoder格式都快忘了，扒了Leanote的模板 ps.掉rating了.. T1Description$n$个数字，$n+1$个位置，用每次移动一步，排成正确顺序。$n\leqslant 500$ Solution这其实就是找环就完了，随便把一个放在最后，然后一个个移动就好了…其实这是个排列，当时读题的时候没看到…然后想复杂了许多，所以代码有点长… Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define mpr make_pair#define x first#define y second#define debug(a) cout&lt;&lt;(#a)&lt;&lt;"="&lt;&lt;a&lt;&lt;" "typedef long long LL;const int N = 100050;const int M = 205;const LL p = 1000000007;const int oo = 0x3fffffff;const LL OO = 1e18;LL Pow(LL a,LL b,LL r=1) &#123; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) r=r*a%p;return r; &#125;inline LL in(LL x=0,char ch=getchar(),int v=1) &#123; while(ch&gt;'9' || ch&lt;'0') v=ch=='-'?-1:v,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*v;&#125;/*end*/#define CS OneHandSort#define FC sortShelfclass CS &#123;private: int n; vector&lt;int&gt; a, ans; map&lt;int, int&gt; rk, rrk, wz; int find() &#123; for(int i=0; i&lt;n; i++) if(rk[a[i]]!=i) return i; return -1; &#125; void addAns(int x) &#123; ans.push_back(x); &#125; void Sol(int x) &#123; int fx=a[x]; addAns(x); for(;;) &#123; addAns(wz[rrk[x]]); a[x]=rrk[x]; x=wz[rrk[x]]; if(rrk[x]==fx) break; &#125; a[x]=fx; addAns(n); &#125;public: vector&lt;int&gt; FC(vector&lt;int&gt; target) &#123; a=target; sort(a.begin(), a.end()); n=a.size(); for(int i=0; i&lt;n; i++) &#123; rk[a[i]]=i; rrk[i]=a[i]; wz[target[i]]=i;// cout &lt;&lt; a[i] &lt;&lt; " " &lt;&lt; i &lt;&lt; endl; &#125; a=target; for(int x=find();~x;x=find()) &#123; Sol(x);// cout &lt;&lt; x &lt;&lt; endl; &#125; return ans; &#125;&#125;;int main() &#123; ios::sync_with_stdio(false);// if(freopen("in.in","r",stdin)); CS py; LL n; vector&lt;int&gt; a, ans; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; int x; cin &gt;&gt; x; a.push_back(x); &#125; ans=py.FC(a); for(int i=0; i&lt;ans.size(); i++) cout&lt;&lt; ans[i]&lt;&lt;" "; return 0;&#125;/**/ T2Description一个人拿着刷子刷路，给出要刷的路段，和每次最长能刷的距离，求最短路程$n\leqslant 500, dStart[i] &lt; dEnd[i] &lt; 2\times 10^9$ Solution这题倒着贪心，当时想出来了，有个地方写的有问题。贪心为啥对呢…因为如果刷一次的话，最远路程便是最后一个，如果你还刷了前面的部分，那么第二次刷的路程就会变大。(没怎么想证明…对就vans了) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define mpr make_pair#define x first#define y second#define debug(a) cout&lt;&lt;(#a)&lt;&lt;"="&lt;&lt;a&lt;&lt;" "typedef long long LL;const int N = 550;const int M = 205;const LL p = 1000000007;const int oo = 0x3fffffff;const LL OO = 1e18;LL Pow(LL a,LL b,LL r=1) &#123; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) r=r*a%p;return r; &#125;inline LL in(LL x=0,char ch=getchar(),int v=1) &#123; while(ch&gt;'9' || ch&lt;'0') v=ch=='-'?-1:v,ch=getchar(); while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*v;&#125;/*end*/#define CS OneHandRoadPainting#define FC fastestclass CS &#123;private: int n, m; LL ans; vector&lt;int&gt; a; LL calc(int x, int t) &#123; return ((LL)x+x-(LL)(t-1)*m)*t; &#125;public: LL FC(vector &lt;int&gt; dStart, vector &lt;int&gt; dEnd, int paintPerBrush) &#123; n=dStart.size(); ans=0; m=paintPerBrush;// for(int i=0; i&lt;n;i++) cout&lt;&lt; dStart[i] &lt;&lt; " " &lt;&lt; dEnd[i]&lt;&lt;endl;// cout &lt;&lt; m &lt;&lt; endl; for(int i=0; i&lt;n; i++) a.push_back(dEnd[i]-dStart[i]); for(int i=n-1;i&gt;=0;--i) &#123; int t=a[i]/m; ans+=calc(dStart[i]+a[i], t);// cout &lt;&lt; calc(dStart[i]+a[i], t) &lt;&lt; endl; a[i]=a[i]%m; t=m; if(a[i]==0) continue; ans+=2LL*(dStart[i]+a[i]); // cout &lt;&lt; 2LL*(dStart[i]+a[i]) &lt;&lt; endl; for(;t&gt;0 &amp;&amp; i&gt;=0; i--) &#123; if(a[i]&lt;=t) &#123; t-=a[i], a[i]=0; &#125; else &#123; a[i]-=t, t=0, i++; break; &#125; &#125;// debug(i),debug(ans); &#125; return ans; &#125;&#125;;int main() &#123; ios::sync_with_stdio(false);// if(freopen("in.in","r",stdin)); CS py; int n, m, x; cin &gt;&gt; n; vector&lt;int&gt; a,b; for(int i=1;i&lt;=n; i++) &#123; cin &gt;&gt; x; a.push_back(x); &#125; for(int i=1;i&lt;=n; i++) &#123; cin &gt;&gt; x; b.push_back(x); &#125; cin &gt;&gt; m; cout &lt;&lt; py.FC(a, b, m) &lt;&lt; endl; return 0;&#125;/*3 1 10 20 4 13 22 2*/]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>topcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数笔记]]></title>
    <url>%2F2019%2F04%2F07%2Fnote-algebra%2F</url>
    <content type="text"><![CDATA[Update 2019-07-01 …写不下去了 再这样写下去可能药丸先做题了… 第三章第二节 Update 2019-07-02 11:00 差不多施工完成了..下午就考线代.. ball ball 让我全会 第一章 行列式第一节 二阶与三阶行列式第二节 $n$阶行列式的定义逆序数为奇数的排列叫做奇排列，逆序数为偶数的排列叫做偶排列。 在排列中，将任意两个元素对调，其余元素保持不动，这种作出新排列的方法叫做对换，将相邻两个元素对换，叫做相邻对换 定理1.1 一个排列中任意两个元素对换，排列改变奇偶性 \left | \begin{matrix}a_{11} & \cdots & a_{1n}\\\vdots & \ddots & \vdots\\a_{n1} & \cdots & a_{nn}\end{matrix}\right | = \sum (-1)^{\tau p_1p_2...p_n}a_{1p_1}a_{2p_2}...a_{np_n}其中$\tau$为排列中逆序数 上三角行列式和下三角行列式叫做对角行列式 \left | \begin{matrix}a_{11} & & & \\ & a_{22} & &\\& & \ddots & \\ & & & a_{nn}\end{matrix}\right | = a_{11}a_{22}...a_{nn}第三节 行列式的性质$D$的转置行列式记作$D^{T}$或$D’$ 性质1 $D=D^{T}$ 性质2 交换行列式的两行或两列，行列式改变符号 推论1 如果行列式有两行或两列完全相同，则此行列式等于零 性质3 行列式中某一行或列的各元素有公因子，则可将公因子提到行列式符号的外面 推论2 行列式的某一行或列所有元素都乘以同一个数$k$，等于用数$k$乘此行列式 推论3 行列式的某一行或列的元素全为零食，行列式的值等于零 性质4 若行列式中有两行或列的元素对应成比例，则此行列式的值等于零 性质5 若行列式的某一行或列的元素都是两数之和，那么可以将他们分成两个行列式D=\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1i}+a_{1i}' & \cdots & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2i}+a_{2i}' & \cdots & a_{2n}\\ \vdots & \vdots & & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{ni}+a_{ni}' & \cdots & a_{nn} \end{vmatrix}=\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1i} & \cdots & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2i} & \cdots & a_{2n}\\ \vdots & \vdots & & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{ni} & \cdots & a_{nn} \end{vmatrix}+\begin{vmatrix} a_{11} & a_{12} & \cdots & a_{1i}' & \cdots & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2i}' & \cdots & a_{2n}\\ \vdots & \vdots & & \vdots & & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{ni}' & \cdots & a_{nn} \end{vmatrix} 性质6 把行列式的某一行或列各元素乘以同一数$k$后加到另一行或列对应的元素上去，行列式的值不变 第四节 行列式按一行或列展开在$n$阶行列式中，划去元素$a_{ij}$所在的行和列，余下的$n-1$阶行列式，称为元素$a_{ij}$的余子式，记为$M_{ij}$，余子式前面冠以符号$(-1)^{i+j}$，称为元素$a_{ij}$的代数余子式，记为$A_{ij}=(-1)^{i+j}M_{ij}$ 引理1 一个$n$阶行列式$D$，如果第$i$行所有元素除$a_{ij}$外全为零，则行列式$D=a_{ij}A_{ij}$ 定理1.4 行列式等于它的任一行或列的各元素与其对应的代数余子式的乘积之和，即D=a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj}或D=a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in} 这个定理称为行列式按行（列）展开法则 范德蒙德（Vandermonde）行列式 D_n=\begin{vmatrix} 1&1&1&\ldots&1\\ x_1&x_2&x_3&\ldots&x_{n}\\ x_1^2&x_2^2&x_3^2&\ldots&x_{n}^2\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ x_1^{n-1}&x_2^{n-1}&x_3^{n-1}&\ldots&x_{n}^{n-1}\\ \end{vmatrix}=\Pi_{n\geqslant i > j \geqslant 1}(x_i-x_j) 推论1 行列式任一行或列的元素与另一行或列的对应元素代数余子式乘积之和等于零，即 a_{i1}A_{j1}+a_{i2}A_{j2}+...+a_{in}A{jn}=0(i\neq j)或 a_{1i}A_{1j}+a_{2i}A_{2j}+...+a_{ni}A{nj}=0(i\neq j) 定义1.3 在一个$n$阶行列式$D$中，任意取定$k$行$k$列$(k\leqslant n)$，位于这些行与列的交点处的$k^2$个元素，按原来的顺序构成的$k$阶行列式$M$，称为行列式$D$的一个$k$阶子式；而在$D$中划去这$k$行$k$列后余下的元素，按原来的顺序构成的$n-k$阶行列式$N$，称为$k$阶子式$M$的余子式，$(-1)^{(i_1+i_2+…+i_n)+(j_1+j_2+…+j_n)}$称为$k$阶子式$M$的代数余子式 定理1.5 设在行列式$D$中任意选定$k(1\leqslant k\leqslant n-1)$行或列，则行列式$D$等于由这$k$行或列元素组成的一切$k$阶子式与它们对应的代数余子式的乘积之和。 第五节 克莱默法则 定理1.6（克莱默法则） 若方程组\left\{\begin{matrix} a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\ \cdots \cdots\\ a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n \end{matrix}\right.的系数行列式D=\left | \begin{matrix} a_{11} & a_{12} & \cdots & a_{1n}\\ a_{21} & a_{22} & \cdots & a_{2m}\\ \vdots & \vdots & & \vdots\\ a_{n1} & a_{n2} & \cdots & a_{nn} \end{matrix} \right |\neq 0则方程组有唯一解，且可表示为x_1=\frac{D_1}{D},x_2=\frac{D_2}{D},...,x_n=\frac{D_n}{D}其中$D_j$是将$D$中的第$j$列换成常数项所得的行列式，即D_j=\left | \begin{matrix} a_{11} & \cdots & a_{1,j-1} & b_1 & a_{1,j+1} & \cdots & a_{1n} \\ a_{21} & \cdots & a_{2,j-1} & b_1 & a_{2,j+1} & \cdots & a_{2n} \\ \vdots & & \vdots & \vdots & \vdots & & \vdots \\ a_{n1} & \cdots & a_{n,j-1} & b_n & a_{n,j+1} & \cdots & a_{nn} \\ \end{matrix} \right | 使用克莱默法则必须注意（1）未知量的个数与方程的个数要相等（2）系数行列式不为零常数项全为零的线性方程组叫做齐次线性方程组；不全为零，就是非齐次线性方程组。$x_1=x_2=…=x_n=0$，称为零解，除零解外还有不全为零的解，称为非零解。 定理1.7 如果齐次线性方程组的系数行列式$D\neq 0$，则齐次线性方程组只有零解。 定理1.7’ 如果齐次线性方程组有非零解，则它的系数行列式必为零。 第二章 矩阵第一节 矩阵的概念定义2.1 由$m\times n$个数$a_{ij}$排成$m$行$n$列的数表，称为$m$行$n$列的矩阵，简称$m\times n$矩阵，并加一个括号（中括号或小括号），并用大写黑体字母表示，记作$A=\left [ \begin{matrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\\vdots &amp; \vdots &amp; &amp; \vdots\\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}\end{matrix} \right ]$，其中$a_{ij}$表示矩阵第$i$行第$j$列的元素，矩阵可简记为$A=(a_{ij})_ {m\times n}$或$A=(a_{ij})$，$m\times n$矩阵也简记为$A_{m\times n}$元素是实数的矩阵称为实矩阵，是复数的称为复矩阵；$m=n$时$A$称为$n$阶方阵；只有一行的矩阵称为行矩阵；只有一列的矩阵称为列矩阵。如果行数和列数相等，则称他们是同型的；如果同型并且对应元素相等，则称他们是相等的，记作$A=B$。元素全为零的矩阵称为零矩阵，记作$O$。恒等变换的系数矩阵$E=\left [ \begin{matrix}1 &amp; 0 &amp; \cdots &amp; 0\\0 &amp; 1 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; 1\end{matrix} \right ]$，称为$n$阶单位矩阵，简称单位阵。$E=(\delta_{ij}),\delta_{ij}=\left\{\begin{matrix}1, &amp; i=j\\ 0, &amp; i\neq j \end{matrix}\right.$ $y_i=\lambda_ix_i$的线性变换的系数矩阵$A=\left [ \begin{matrix}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\\0 &amp; \lambda_2 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; \lambda_n \end{matrix} \right ]$，称为对角阵，特点是不在主对角线的元素都为零，特别的当$\lambda_1=\lambda_2=…=\lambda_n$时称为数量矩阵。 还有上三角矩阵和下三角矩阵，见名知意我就不写了.. 第二节 矩阵的运算 矩阵的加法，对应元素相加。 数与矩阵的乘法，对应相乘。 矩阵与矩阵的相乘，$c_{ij}$等于$A$的第$i$行与$B$的第$j$列的对应元素乘积之和，不满足交换律，分为左乘和右乘。若$AB=BA$，则称$A$与$B$是可交换的。类似定义矩阵的幂$(AB)^k=A^kB^k$$A^2=A$，幂等矩阵 矩阵的转置：将矩阵行和列一次互换位置，称为$A$的转置，记作$A^{T}$或$A’$满足以下规律：$(A^{T})^{T}=A,(A+B)^{T}=A^{T}+B^{T},(\lambda A)^{T}=\lambda A^{T},(AB)^{T}=B^{T}A^{T}$ 定义2.6 若$A^{T}=A$，那么称$A$为对称阵，各元素以主对角线为对称轴对应相等定义2.7 若$A^{T}=-A$，称为反对称阵，主对角线的元素全为零 方阵的行列式方阵各元素构成的行列式称为方阵$A$的行列式，记为$|A|$。具有以下性质$|A^{T}|=|A|,|\lambda A|=\lambda ^n|A|,|AB|=|A||B|$$|AB|=|BA|=|A||B|$ 第三节 逆矩阵逆变换 定义2.9 设$A$为$n$阶方阵，若存在$n$阶方阵$B$，使得$AB=BA=E$，则称方阵$A$是可逆的，称$B$是$A$的逆矩阵或逆阵。 由定义可知：互为逆矩阵，逆变换的矩阵必为逆矩阵，逆矩阵唯一。 定理2.1 $n$阶方阵$A$可逆的充分必要条件是：$|A|\neq 0$，且当$A$可逆时有 A^{-1}=\frac{1}{|A|}A^{* }其中$A^{* }=\left [ \begin{matrix}A_{11} &amp; A_{21} &amp; \cdots &amp; A_{n1} \\A_{12} &amp; A_{22} &amp; \cdots &amp; A_{n2} \\\vdots &amp; \vdots &amp; &amp; \vdots \\A_{1n} &amp; A_{2n} &amp; \cdots &amp; A_{nn} \\\end{matrix} \right ]$，称为$A$的伴随矩阵，$A_{ij}$是$|A|$的元素$a_{ij}$是代数余子式。注意排列顺序是关于主对角线对称的，注意代数余子式，有个$(-1)^{i+j}$。 另外 $AA^{* }=|A|E$； $A^{* }A=|A|E$ 推论1 若$A,B$都是$n$阶方阵，且$AB=E$，则$BA=E$ 定义2.10 设$A$为方阵，若$|A|\neq 0$，则称$A$为非奇异方阵；若$|A|=0$，则称$A$为奇异方阵。可逆方阵即为非奇异方阵，方阵的逆具有以下性质（假设都可逆） $(A^{-1})^{-1}=A$ $\lambda \neq 0,(\lambda A)^{-1}=\frac{1}{\lambda}A^{-1}$ $(AB)^{-1}=B^{-1}A^{-1}$ $A^{T}$可逆，$(A^{T})^{-1}=(A^{-1})^{T}$ $|A^{-1}|=\frac{1}{|A|}=|A|^{-1}$ 几个结论： 设对角阵$\Lambda =\begin{bmatrix}\lambda_1 &amp; &amp; &amp; \\ &amp; \lambda_2 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; \lambda_n\end{bmatrix}$，则$\Lambda ^k=\begin{bmatrix}\lambda_1^k &amp; &amp; &amp; \\ &amp; \lambda_2^k &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; \lambda_n^k\end{bmatrix}$ $|A|\neq 0$，$A^0=E,A^{-k}=(A^{-1})^k,A^{\lambda}A^{\mu}=A^{\lambda + \mu},(A^{\lambda})^{\mu}=A^{\lambda \mu}$ 第四节 分块矩阵定义2.11 用若干条纵线和横线把$A$分成若干个小块，每一个小块构成的小矩阵称为$A$的子块，以子块伪元素的矩阵称为$A$的分块矩阵。 若分块方法相同，矩阵相加等于子块对应相加若$A$列分法与$B$行分法相同，得到的子块为对应子块乘积之和，与矩阵乘法相同。$A^{T}=\begin{bmatrix}A_{11}^{T} &amp; \cdots &amp; A_{s1}^{T}\\ \vdots &amp; &amp; \vdots \\ A_{1r}^{n} &amp; &amp; A_{sr}^{T}\end{bmatrix}$只有在对角线上有非零子块，且对角线上的子块都是方阵，$A=\begin{bmatrix}A_1 &amp; &amp; &amp; \\ &amp; A_2 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; A_s\end{bmatrix}$，此时称$A$为分块对角矩阵，则有$|A|=|A_1||A_2|…|A_s|$当$|A_i|\neq 0$时，$A^{-1}=\begin{bmatrix}A_1^{-1} &amp; &amp; &amp; \\ &amp; A_2^{-1} &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; A_s^{-1}\end{bmatrix}$$A_i,B_i$是同阶方阵$AB=\begin{bmatrix}A_1B_1 &amp; &amp; &amp; \\ &amp; A_2B_2 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; A_sB_s\end{bmatrix}$ 第五节 矩阵的秩与矩阵的初等变换定义2.12 $m\times n$的矩阵$A$中，任取$k$行$k$列，在行列交叉的$k^2$个元素按原来的次序所构成的$k$阶行列式，称为$A$的$k$阶子式。 定义2.13 矩阵$A$中不为零的子式的最高阶数称为矩阵$A$的秩，记为$rank(A)$，简记为$r(A)$。非奇异方阵的秩等于它的阶数，故非奇异方阵称为满秩矩阵，而奇异方阵称为降秩矩阵。 定理2.2 若矩阵$A$中至少有一个$k$阶子式不为零，而有所$k+1$阶子式全为零，则$r(A)=k$ 矩阵秩的性质 $r(A_{m\times n}\leqslant \min\{m,n\}$ $r(A^{T})=r(A),r(\lambda A)=r(A)(\lambda neq 0)$ $A\sim B,r(A)=r(B)$ $RQ$可逆，$r(A)=r(PA)=r(AQ)=r(PAQ)$ $\max \{r(A),r(B)\}\leqslant r(A,B)\leqslant r(A)+r(B)$ $r(A+B)\leqslant r(A)+r(B)$ $r(AB)\leqslant \min \{r(A),r(B)\}$ 若$A_{m\times n}\cdot B_{n\times l}=O$，则$r(A)+r(B)\leqslant n$ 若$AB=O$，$A\neq O \nRightarrow B=O$；$|A|\neq 0 \Rightarrow B=O$；$A$列满秩$\Rightarrow B=O$；$B$行满秩$\Rightarrow A=O$ 行阶梯矩阵，行最简形阶梯矩阵（行最简形），标准形$I$（左上角有一个单位矩阵，其他元素都为零）定义2.15 若矩阵$A$经过有限次初等变换后，化为矩阵$B$，则称$A$与$B$等价，记为$A\sim B$ $A\sim A$ $A\sim B,B\sim A$ $A\sim B, B\sim C$则$A\sim C$ $A\sim B,r(A)=r(B)$ 定义2.16 由单位阵$E$经过一次初等变换得到的方阵称为初等矩阵 定理2.4 设$A$是一个$m\times n$矩阵，则对$A$施行一次初等行变换，相当于用相应的$m$阶初等矩阵左乘$A$；对$A$施行一次初等列变换，相当于用相应的$n$阶初等矩阵右乘$A$。定理2.5 设$A$为可逆阵，则存在有限个初等矩阵$P_1,P_2,…,P_l$使$A=P_1P_2…P_l$ 推论1 $m\times n$矩阵$A\sim B$的充分必要条件是：存在$m$阶可逆方阵$P$及$n$阶可逆方阵$Q$，使$PAQ=B$。 初等变换求逆矩阵$(A,E)\sim (E,A^{-1})$，$AX=E,(A,B)\sim (E,X)/(E,A^{-1}B)$ 第三章 向量组的线性相关性第一节 $n$维向量定义3.1 $n$个有顺序的数$a_1,a_2,…,a_n$所组成的数组$\alpha=(a_1,a_2,…,a_n)$称为$n$维向量，数$a_j$称为向量$\alpha$的第$j$个分量（或坐标）实向量，复向量，行向量，列向量都略了… 具体相关向量空间、线性组合、线性表示第七章写过了 平凡子空间（空间本身和零向量）、非平凡子空间 第二节 向量组的线性相关性由若干个同维数的向量所组成的集合称为向量组。 定义3.3 设有$n$为向量组$\alpha_1,\alpha_2,…,\alpha_m$，若存在不全为零的数$c_1,c_2,…,c_m$，使得，$c_1\alpha_1+c_2\alpha_2+…+c_n\alpha_n=0$，则称向量组线性相关；否则称线性无关。当向量组线性无关时，称这个向量组为线性无关（向量）组 几条结论 零向量是线性相关的 任一非零向量线性无关 包含零向量的向量组是线性相关的 两个向量线性相关的充要条件是：它们的对应分量称比例 定理3.1 向量组$\alpha_1,\alpha_2,…,\alpha_m$线性相关的充分必要条件是：这个向量组中至少有一个向量可由其余$m-1$个向量线性表示定理3.2 若$n$维向量组$\alpha_1,\alpha_2,…,\alpha_m$有一个部分组线性相关，则该向量组也线性相关定理3.3 设$\alpha_1,\alpha_2,…,\alpha_m$线性无关，而$\alpha_1,\alpha_2,…,\alpha_m,\beta$线性相关，则$\beta$能由$\alpha_1,\alpha_2,…,\alpha_m$表示，且表示法唯一 定义3.9 若向量组$A$中每一个元素都能由$B$中的元素线性表示，则称向量组$A$能由向量组$B$线性表示，若$B$也能由$A$线性表示，则称向量组$A,B$等价满足 自反性、对称性、传递性 向量组线性相关性的矩阵判别法 定理3.4 将向量组的两个分量对调，不改变向量组的线性相关性。定理3.5 两个向量组，一个向量组是由另一个向量组添加一个分量所得，若前者线性无关，则后者也线性无关 推论1 设$r$维向量组的每个向量在相应位置上天上$n-r$个分量成为$n$维向量组，若$r$为向量组线性无关，则$n$维向量组也线性无关，反之$n$维向量组线性相关，则$r$维向量组也线性相关。定理3.6 设$n$维向量组，$r$个向量$(r\leqslant n)$，向量组线性无关的充分必要条件是：矩阵$A$中存在一个不等于零的$r$阶子式 推论2 $n$个$n$维向量线性无关的充要条件是：它们所构成的方阵行列式不等于零 推论3 含$n$个方程的$n$元齐次线性方程组$Ax=0$有非零解的充要条件是：系数行列式$|A|=0$ 推论4 $m&gt;n$时，$m$个$n$维向量组必定线性相关 定理3.6’ 设$r$个$n$维行向量构成矩阵$A$，那么这$r$个向量线性相关的充分必要条件是：$A$中存在不等于零的$r$阶子式。反之，这$r$个向量线性相关的充分必要条件是：没有不等于零的$r$阶子式 推论5 如果在$m\times n$矩阵$A$中有一个$r$阶子式$D\neq 0$，则含有$D$的相应元素的$r$个行向量及$r$个列向量都线性无关；如果$A$中所有的$r$阶子式全为0，则$A$的任意$r$个行向量及任意$r$个列向量都线性相关。 最大线性无关组的个数就是向量组的秩 性质1 向量组线性无关的充要条件是：它所含向量的个数等于它的秩。 性质2 设矩阵$A$的某个$r$阶子式$D$是$A$的最高阶非零子式，则$D$所在的$r$个行向量及$r$个列向量分别是矩阵$A$的行向量组和列向量组的一个最大无关组 性质3 矩阵$A$的秩等于$A$的行向量组的秩，也等于$A$的列向量组的秩 性质4 设向量组$A$是向量组$T$的一个最大线性无关组，则向量组$A$与向量组$T$等价 定理3.7 如果向量组$A$有$r$个元素，向量组$B$有$s$个元素，如果$A$能由$B$组线性表示，且$A$组线性无关，则$r\leqslant s$. 推论6 等价的线性无关向量组所含向量的个数相等。 推论7 设向量组$A$的秩为$r_1$，向量组$B$的秩为$r_2$，如果$A$组能由$B$组线性表示，则$r_1\leqslant r_2$ 推论8 等价向量组有相同的秩 推论10 设矩阵$A$中有一个$r$阶子式$D\neq 0$，而包含$D$的相应元素的所有$r+1$阶子式全为零，则$A$中所有$r+1$阶子式全为零，从而$r(A)=r$ 引理1 如果矩阵$A$经初等行（列）变换后变成$B$，则$A$的行（列）向量组和$B$的行（列）向量组等价引理2 设$A,B$都是$m\times n$矩阵，若$A,B$的行向量组等价，则齐次线性方程组$Ax=0$与$Bx=0$同解引理3 若矩阵$A$经过有限次初等行（列）变换后变成$B$，则$A$在任意$k$列（行）详列与$B$中对应的$k$个列（行）向量有相同的线性关系 第三节 向量空间的基、维数与坐标详见第七章 第四章 线性方程组第一节 高斯消元法第二节 齐次线性方程组 定理4.1 $n$元齐次线性方程组$Ax=0$，存在非零解的充要条件是系数矩阵$A$的秩$r(A)&lt;n$，也即$Ax=0$只有零解的充要条件是$r(A)=n$定理4.2 若$x=\xi_1,x=\xi_2$为齐次线性方程组的两个解，则$x=\xi_1+\xi_2$也是齐次方程组的解，即齐次方程组的任意两个解之和还是它的解。定理4.3 若$x=\xi$是齐次线性方程组的一个解，$k$为任意常数，则$x=k\xi$也是齐次线性方程组的解，即齐次线性方程组的解的任意常数倍也是它的解 定义4.1 设$\xi_1,\xi_2,…,\xi_r$是$Ax=0$的解向量，如果$\xi_1,\xi_2,…,\xi_r$线性无关，$Ax=0$的任一解向量均可由$\xi_1,\xi_2,…,\xi_r$线性表示，则称其为$Ax=0$的基础解系。 定理4.4 对于$n$元齐次线性方程组$Ax=0$，如果$r(A)=r&lt;n$，则方程组的基础解系存在，且含$n-r$个解向量，即解空间的维数为$n-r$ 第三节 非齐次线性方程组若非齐次线性方程组有解，则称方程组是相容的，否则称是不相容的，矩阵表示$Ax=b$ 定理4.5 对于非齐次线性方程组，下面条件等价(1)$Ax=b$有解(2)$b$可由$A$的列向量组线性表示(3)增广矩阵$\widetilde{A}$的秩等于系数矩阵$A$的秩定理4.6 设$\eta_1,\eta_2$是非齐次线性方程组$Ax=b$的阶，则$\eta_1-\eta_2$是对应的齐次线性方程组（也称导出组）$Ax=0$的解定理4.7 如果非齐次线性方程组$Ax=b$有解，则其通解为$\eta=\xi+\eta^{* }$，其中$\xi$是对应$Ax=0$的通解，另一个是$Ax=b$的特解 非齐次线性方程组有解的充分必要条件是：$r(A)=r(\widetilde{A})=r$，且$r=n$时只有唯一解，$r&lt; n$时有无穷多解 已知基础解系求满足的方程，将基础解系转置，经过初等行变换即可得 第五章 矩阵的对角化第一节 特征值与特征向量设$A=a_{ij}$是一个$n$阶方阵，如果存在一个数$\lambda $和一个非零列向量$x=(x_1,x_2,…,x_n)^T$，使得关系式$Ax=\lambda x$成立，则称数$\lambda $为方阵$A$的一个特征值，非零向量$x$称为$A$的对应于（或属于）特征值$\lambda $的特征向量。 特征值问题只对方阵而言 特征向量必须是非零向量 方阵$A$的每个特征值均对应于无穷多个特征向量，属于同一特征值的特征向量的任意非零线性组合也是属于该特征值的特征向量，$A(kx)=k(Ax)=k(\lambda x)=\lambda (kx),k\neq 0$，$A(x_1+x_2)=Ax_1+Ax_2=\lambda x_1+\lambda x_2=\lambda (x_1+x_2), x_1+x_2\neq 0$ 求法 (A-\lambda E)x=0 , (\lambda E-A)x=0有解的充要条件是：系数行列式$|A-\lambda E|=0$，此方程称为方阵$A$的特征方程，左端$|A-\lambda E|$是$\lambda $的$n$次多项式，称为方阵$A$的特征多项式，记为$f(\lambda )$ 特征值与特征向量的性质 一个特征向量只能属于一个特征值（相同的看成一个） 若$\lambda $是方阵$A$的特征值，$x$是其属于$\lambda $的特征向量，则(1) $\mu\lambda$是$\mu A$的特征值，$x$是其属于$\mu \lambda$的特征向量(2) $\lambda ^m$是$A^m$的特征值，$x$是其属于$\lambda ^m$的特征向量(3) 当$|A|\neq 0$时，$\lambda ^{-1}$是$A^{-1}$的特征值，$\lambda ^{-1}|A|$为$A^{*}$的特征值，且$x$为其对应的特征向量。 $A$与$A^{T}$有相同的特征值 设$n$阶矩阵$A=(a_{ij})$的$n$个特征值为$\lambda_1,\lambda_2,…, \lambda_n$，则(1) $\sum_{i=1}^n \lambda_i=\sum_{i=1}^na_{ii}=trA$(2) $\lambda 1\lambda 2…\lambda n=|A|$其中$tr A$称为$A$的迹，为$A$的主对角线元素之和$A$可逆当且仅当$A$的特征值不为零 设$\lambda_1,\lambda_2,…\lambda_m$是方阵$A$的$m$个特征值，$p_1,p_2,…,p_m$是依次与之对应的特征向量，如果$\lambda_1,\lambda_2,…\lambda_m$互不相等，则$p_1,p_2,…,p_m$线性无关。 第二节 相似矩阵向量的内积向量内积$(x,y)=x_1y_1+x_2y_2+…+x_ny_n$ $(x,y)=(y,x)$ $(\lambda x,y)=\lambda(x,y)$ $(x+y,z)=(x,z)+(y,z)$ $(x,x) \geqslant 0$ 定义5.3 $||A||=\sqrt{(x,x)}$为$n$维向量$x$的长度（或范数） $||x||\geqslant 0$，等号成立当且仅当$x=0$ $||x||=|\lambda | ||x||$ $||x+y||\leqslant ||x|| +||y||$单位向量$||x||=1$，单位化$\frac{x}{||x||}$柯西-施瓦茨不等式$(x,y)^2\leqslant (x,x)(y,y)$或$|(x,y)|\leqslant ||x||\cdot ||y||$ 夹角$\theta =\arccos \frac{(x,y)}{||x||\cdot ||y||}$$(x,y)=0$时称两向量正交，零向量与任何向量都正交一组两两正交的非零向量，称为正交向量组 定理5.1 正交向量组必定是线性无关组 用正交向量组作向量空间的基，称为向量空间的正交基，若每个正交向量组的向量都是单位向量，则称为向量空间的正交规范基或标准正交基。 施密特正交化过程 \begin{matrix} \beta_1= &\alpha_1\\ \beta_2= &\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1\\ \beta_3= &\alpha_3-\frac{(\alpha_3,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_3,\beta_2)}{(\beta_2,\beta_2)}\beta_2\\ \cdots \cdots\\ \beta_r= & \alpha_r-\frac{(\alpha_r,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_r,\beta_2)}{(\beta_2,\beta_2)}\beta_2-\cdots-\frac{(\alpha_r,\beta_{r-1})}{(\beta_{r-1},\beta_{r-1})}\beta_{r-1} \end{matrix}定义5.5 如果$n$阶方阵$A$满足，$A^{T}A=E(A^{-1}=A^{T})$，那么称$A$为正交矩阵 定理5.2 设$A,B$都是$n$阶正交矩阵，则(1)$|A|=\pm 1$(2)$A$的列（行）向量组是两两正交的单位向量(3)$A^{T}(A^{-1})$也是正交矩阵(4)$AB$也是正交矩阵注： $A$为正交矩阵，当且仅当$A$的列（行）向量组为正交规范向量组由此可见，正交矩阵$A$的$n$歌列（行）向量构成的向量空间$R^n$的一个正交规范基 相似矩阵定义5.6 设$A,B$都是$n$阶方阵，如果存在一个可逆矩阵$P$，使得$P^{-1}AP=B$，则称$A$与$B$是相似的，$P^{-1}AP$陈给对$A$做相似变换，可逆矩阵$P$称为把$A$变成$B$的相似变换矩阵 $E^{-1}AE=A$ $P^{-1}AP=B,(P^{-1})^{-1}BP^{-1}=A$ $P^{-1}AP=B,Q^{-1}BQ=C,(PQ)^{-1}A(PQ)=C$相似矩阵性质 性质1 相思举着扭矩有相同的秩及相同的行列式 性质2 相似矩阵若可逆，则其逆矩阵也相似 若$A$与$B$相似，则$A^k$与$B^k$也相似 定理5.3 相似矩阵有相同的特征多项式及相同的特征值（你明天不成立） 方阵对角化 定理5.4 $n$阶方阵$A$与对角阵相似的充分必要条件是：$A$有$n$个线性无关的特征向量方阵$A$如果能够对角化，则对角矩阵$\Lambda$在不计入$\lambda_k$的排列顺序时是惟一的，称为$A$的相似标准形$P^{-1}AP=\Lambda$，其中$P$是由特征向量的列向量组成的。 推论1 $n$阶方阵$A$若有$n$个不同的特征值，则$A$可对角化 推论2 如果对$n$阶方阵$A$的任一$k$重特征值$\lambda$，都有$r(A-\lambda E)=n-k$，则$A$可对角化 实对称矩阵的对角化 定理5.5 实对称矩阵的特征值为实属定理5.6 实对称矩阵对应于不同特征值的特征向量必正交定理5.7 设$A$为$n$阶实对称矩阵，$\lambda$是$A$的$r$重特征值，则$r(A-\lambda E)=n-r$，从而矩阵$A$对应特征值$\lambda$恰有$r$个线性无关的特征向量定理5.8 设$A$为$n$阶实对称矩阵，则必存在正交矩阵$P$，使得$P^{-1}AP=P^{T}AP=\Lambda$，其中$\Lambda$是以$A$的$n$个特征值为对角线元素的对角矩阵 将每个对应于$r_j$重特征值$\lambda_j$的$r_j$个线性无关的特征向量正交化并单位化，即可得到$r_j$个单位正交特征向量，以所有特征值的正交化并单位化后特征向量为列向量构成正交矩阵$P$ 第六章 二次型第一节 二次型及其矩阵表示二次型基本概念 定义6.1 含有$n$个变量$x_1,x_2,…,x_n$的二次齐次函数$f(x_1,x_2,…,x_n)=a_{11}x_1^2+a_{22}x_2^2+…+a_{nn}x_n^2+2a_{12}x_1x_2+2a_{13}x_1x_3+…+2a_{n-1,n}x_{n-1}x_n$ 称为二次型 当$a_{ij}$为复数时，$f$称为复二次型，为实数时称为实二次型。将系数$a_{ij}$提出来形成一个矩阵$A$，对称阵$A$称为二次型$f$的矩阵，也称二次型$f$为对称阵$A$的二次型，矩阵$A$的秩叫作二次型$f$的秩。 线性变换 定义6.2 矩阵表示$x=Cy$，$C$为线性变换的矩阵，当$|C|\neq 0$时，称线性变换为可逆的线性变换或非退化的线性变换；当$C$为正交矩阵时，称线性变换为正交线性变换，简称正交变换。 矩阵的合同设$A,B$为$n$阶方阵，如果存在$n$阶可逆方阵$C$，使得$C^{T}AC=B$，则称$A$与$B$合同。满足自反性、对称性、传递性、经过线性变换后对应矩阵依然合同。 第二节 二次型的标准形 定义6.4 若二次型经可逆线性变换后变成只含平方项的二次型，则称变换后的二次型为原二次型的标准形。 正交变换法 定理6.1（主轴定理） 对任意一个$n$元实二次型$f=x^{T}Ax$，一定存在正交变换$x=Py$，使$f$化为标准形 \lambda_1y_1^2+\lambda_2y_2^2+...+\lambda_ny_n^2其中$\lambda_1,\lambda_2,…,\lambda_n$是$f$的矩阵$A$的$n$个特征值，正交矩阵$P$的$n$个列向量为$A$的对应于特征值的单位正交特征向量。 配方法 定理6.2 任何一个二次型都可通过非退化的线性变换化为标准形。若存在$a_{ii}\neq 0$，那么将其依次配方，例如$f=a_{11}[x_1+\frac{1}{a_{11}}(a_{12}x_2+…+a_{1n}x_n)]^2-\frac{1}{a_{11}}(a_{12}x_2+…+a_{1n}x_n)^2+a_{22}x_2^2+2a_{23}x_2x_3+…+a_{nn}x_n^2$，即可将前面的平方项对应$y_1$的线性变换，后面是对应的$n-1$元二次型。若不存在$a_{ii}=0$，那么就令$x_1=y_1-y_2,x_2=y_1+y_2,x_3=y_3…,x_n=y_n$，即可得一个包含平方项的二次型。 初等变换法由于$C^{T}AC=\Lambda$，转换成一系列初等矩阵$C=P_1P_2…P_s$，$C^{T}AC=P_s^{T}…P_2^{T}P_1^{T}AP_1P_2…P_s=\Lambda$，注意到$EP_1P_2…P_s=C$。对$2n\times n$的矩阵$\begin{bmatrix}A\\E\end{bmatrix}$通过右乘$P_1P_2..P_s$的初等列变换，左乘$P_1^{T}P_2^{T}…P_n^{T}$的初等行变换。变换后，$A$变成了$\Lambda$，$E$变成了$C$。 不花里胡哨的说（说人话），把第一行除第一个元素外，用列变换消成$0$；再把第一列除第一个元素外，用行变换消成$0$；依次做第二行、第二列…，最后消成一个对角矩阵。 第三节 正定二次型惯性定理与规范形 定理6.3（惯性定理） 在实二次型$f=x^{T}Ax$的标准形中，正系数的个数及负系数的个数是唯一确定的，与可逆线性变换无关。 定义6.5 在实二次型$f$的标准形中，正系数个数$p$称为二次型$f$的正惯性系数，负系数个数$q$称为二次型$f$的负惯性系数。 将二次型变成如下形式$f=z_1^2+…+z_p^2-z_{p+1}^2-…z_r^2$，称为二次型的规范形。（大概是系数为$\pm 1$？）由惯性定理知，任一实二次型的规范形唯一。 二次型的有定型定义6.6 设有实二次型$f=x^{T}Ax$，如果对任取的$x$（1）$f\geqslant 0$，当且仅当$x=0$时，$f=0$，则称二次型$f$是正定二次型，而称对称矩阵$A$为正定矩阵；（2）$f\leqslant 0$，当且仅当$x=0$时，$f=0$，则称二次型$f$是负定二次型，而称对阵矩阵$A$为负定矩阵；（3）$f\geqslant 0$（或$f\leqslant 0$），则称二次型$f$是半正定（或半负定）二次型，同时称矩阵$A$是半正定矩阵（或半负定矩阵）。（4）$f$的值有正有负，则称二次型$f$是不定的 定理6.4 $n$元二次型$f=x^{T}Ax$正（负）定的充分必要条件是：它的正（负）惯性指数为$n$。 推论1 对称矩阵$A$为正（负）定矩阵的充分必要条件是：$A$的特征值全为正（负）。 推论2 实二次型$f=x^{T}Ax$半正（负）定的充分必要条件是：它的正（负）惯性指数等于二次型的秩。 推论3 二次型经非退化线性变换后不改变它的有定性。 推论4 实对称矩阵$A$为正定矩阵的充分必要条件是：$A$与单位矩阵合同。 定理6.5 实对称矩阵$A$正定的充分必要条件是：存在可逆矩阵$C$，使得$A=C^{T}C$定理6.6 设$A$为正定矩阵，则（1）$A$的主对角线元$a_{ii}&gt;0$（2）$|A|&gt;0$ 推论5 设$A$为负定矩阵，则（1）$A$的主对角元$a_{ii}0$ 定义6.7 设$A=(a_{ij})_ {n\times n}$，称 |A_k|=\left | \begin{matrix} a_{11} & a_{12} & \cdots & a_{1k}\\ a_{21} & a_{22} & \cdots & a_{2k}\\ \vdots & \vdots & & \vdots\\ a_{k1} & a_{k2} & \cdots & a_{kk} \end{matrix} \right |为$A$的$k$阶顺序主子式。 定理6.7 $n$阶实对称矩阵$A$正定的充分必要条件是：$A$的所有顺序主子式（$n$个）全大于零，称为赫尔维茨定理。 推论6 实对称矩阵$A$负定的充分必要条件是：奇数阶顺序主子式为负，偶数阶顺序主子式为正。 第七章 线性空间与线性变换简介第一节 线性空间的基本概念线性空间的定义与性质定义7.1 设$V$是一非空集合，$P$是一数域，如果在$V$中定义了以下两种运算： $\alpha +\beta=\beta + \alpha$ $(\alpha +\beta )+\gamma = \alpha + (\beta + \gamma)$ $\alpha + 0 = \alpha$ 存在负元素$\beta=-\alpha$，$\alpha + \beta = 0$ $1\alpha = \alpha$ $\lambda(\mu \alpha)=(\lambda \mu)\alpha$ $(\lambda + \mu)\alpha=\lambda \alpha + \mu \lambda$ $\lambda(\alpha + \beta)=\lambda \alpha + \lambda \beta$那么称$V$是数域$P$上的线性空间（或向量空间），简称线性空间，$V$中元素也称为向量。 线性空间的加法和数量乘法称为线性运算。 性质1 零元素是唯一的 性质2 每个元素的负元素是唯一的 性质3 $0\cdot \alpha=0,\lambda\cdot 0 = 0,(-1)\alpha=-\alpha$ 性质4 若$\lambda \alpha =0$，则$\lambda=0$或$\alpha =0$ 定义7.2 设$L$是线性空间$V$的一个非空子集，若$L$对于$V$中所定义的加法和数乘运算也构成一个线性空间，则称$L$为$V$的一个线性子空间（简称子空间）。 定理7.1 线性空间$V$的非空子集$L$构成子空间的充分必要条件是：$L$对$V$的加法与数乘运算封闭。 定义7.3 线性空间$V$中，如果存在$n$个元素$\alpha_1,\alpha_2,…,\alpha_n$，满足这$n$个元素线性无关，并且$V$中的任意元素总能由这$n$个元素线性表示，就称这$n$个元素为线性空间$V$的一个基，$n$称为线性空间$V$的维数，记作$\text{dim}V=n$。维数为$n$的线性空间也称为$n$维线性空间。 定义7.4 设$\alpha_1,\alpha_2,…,\alpha_n$是线性空间$V$的一个基，对任一元素$\alpha \in V$，有唯一表达式$\alpha=x_1\alpha_1+x_2\alpha_2+…+x_n\alpha_n$，称有序数组$(x_1,x_2,…,x_n)$为元素$\alpha$在基$\alpha_1,\alpha_2,…,\alpha_n$下的坐标，并记作$\alpha=(x_1,x_2,…,x_n)$ 基坐标与坐标变换 定理7.2 设$n$维线性空间有两个不同的基$e_1,e_2,…,e_n$和$e_1’,e_2’,…,e_n’$且有$(e_1’,e_2’,…,e_n’)=(e_1,e_2,…,e_n)A$，其中$A$的第$j$列为$e_j’$在$e_1,e_2,…,e_n$下的坐标，这个公式叫做基变换公式，矩阵$A$称为过渡矩阵。$\begin{pmatrix}x_1\\ x_2\\ \vdots\\ x_n\end{pmatrix}=A\begin{pmatrix}x_1’\\ x_2’\\ \vdots\\ x_n’\end{pmatrix}$或$\begin{pmatrix}x_1’\\ x_2’\\ \vdots\\ x_n’\end{pmatrix}=A^{-1}\begin{pmatrix}x_1\\ x_2\\ \vdots\\ x_n\end{pmatrix}$这个称为坐标变换公式。 第二节 线性变换设$V$为线性空间，把$V$到$V$的映射称为$V$的变换。 线性变换的定义与性质定义7.5 数域$P$上的线性空间$V$的一个变换$T$称为线性变换，如果对于任意$x,y\in V,\lambda \in P$，都有$T(x+y)=T(x)+T(y),T(\lambda x)=\lambda T(x)$ 线性变换的矩阵表示就是把每个元素都变换一下，竖着排列，系数形成一个矩阵。 定理7.3 设$V$为$n$维线性空间，线性变换$T$在基$e_1,e_2,…,e_n$下的矩阵为$A$，则向量$x$与$T(x)$在基$e_1,e_2,…,e_n$下的坐标有关系式$T(x)=Ax,x=(x_1,x_2,…,x_n)^{T}$定理7.4 两个基，基（I)到基（II）的过渡矩阵为$C$，$T$是$V$的线性变换，他在基(I),(II)下的矩阵分别为$A$和$B$，则$B=C^{-1}AC$ 线性变换的运算3种运算和：$T(x)=T_1(x)+T_2(x)$，记作$T=T_1+T_2$数量乘积：$T(x)=\lambda(T_1(x))$，记作$T=\lambda T_1$乘积：$T(x)=T_1(T_2(x))$，记作$T=T_1T_2$ 定义7.6 设$I$是线性空间$V$的单位线性变换，$T$为$V$的线性变换，如果存在$V$的一个变换$S$，使得$TS=ST=I$，则称线性变换$T$是可逆的，而$S$称为$T$的逆变换，记作$T^{-1}$ 定理7.5 设线性空间$V$的线性变换$T_1,T_2$在$V$的某个基下的矩阵分别为$A$和$B$，则在这个基下，有(1)$T_1+T_2$的矩阵为$A+B$(2)$\lambda T_1$的矩阵为$\lambda A$(3)$T_1T_2$的矩阵为$AB$(4)若$T_1$可逆，则$A$可逆，且逆变换$T^{-1}$的矩阵为$A^{-1}$]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高等数学笔记]]></title>
    <url>%2F2019%2F04%2F07%2Fnote-math%2F</url>
    <content type="text"><![CDATA[Update 2019.6.22ps.为了加快复习速度可能不会太详细了…，有时后做了笔记并不会立刻同步上来下学期好好做人…学的时候就记笔记… Update 2019.6.251\def\ooint&#123;&#123;\bigcirc&#125;\kern-11.5pt&#123;\int&#125;\kern-6.5pt&#123;\int&#125;&#125; 自定义闭合曲线二重积分但是这里…用不了，我就用普通二重积分代替了 Update 2019.6.26差不多都复习了一遍了…最后几节实在是看不下去了，等下周再搞搞，还一直没有做套题，做上几套题再复习一下找时间还会在整理上学期的积分方法，不然稍微复杂点就忘咋算了 Update 2019.7.6 补充微分方程和修改部分错误 Update 2019.7.7 常系数非齐次线性微分方程还有傅里叶级数我放弃了…考到的话…分给你15我点了 第二章 导数与微分就光补充一下求导公式$\sec x=\frac{1}{\cos x}, \csc x=\frac{1}{\sin x}$ $(C)’=0$ $(x^{\mu})=\mu x^{\mu -1}$ $(\sin x)’=\cos x$ $(\cos x)’=-\sin x$ $(\tan x)’=\sec^2 x$ $(\cot x)’=-\csc ^2 x$ $(\sec x)’=\sec x\tan x$ $(\csc x)’=-\csc x\cot x$ $(a^x)’=a^x\ln a$ $(e^x)’=e^x$ $(\log_a x)’=\frac{1}{x\ln a}$ $(\ln x)’=\frac{1}{x}$ $(\arcsin x)’=\frac{1}{\sqrt{1-x^2}}$ $(\arccos x)’=-\frac{1}{\sqrt{1-x^2}}$ $(\arctan x)’=\frac{1}{1+x^2}$ $(\text{arccot} x)’=-\frac{1}{1+x^2}$ 和差积商求导法则 $(u\pm v)’=u’\pm v’$ $(Cu)’=Cu’$ $(uv)’=u’v+uv’$ $\left (\frac{u}{v} \right )’=\frac{u’v-uv’}{v^2}$ 第七章 微分方程第一节 微分方程基本概念一般地，凡是表示未知函数、未知函数的导数与自变量之间关系的方程，叫做微分方程，微分方程中所出现的未知函数的最高阶导数的阶数，称为微分方程的阶。找到一个函数代入微分方程使其称为恒等式，这个函数叫做微分方程的解，如果微分方程的解中含有任意成熟，且任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。满足一定条件的如$y|_ {x=x_0}=y_0,y’|_ {x=x_0}=y’_ 0$，叫做初值条件，确定了通解中任意常数以后，就得到微分方程的特解。 第二节 可分离变量的微分方程简单来说，把含$x$的函数和$\text{d}x$放在等式一边，将$y,\text{d}y$放在等式另一边，分别积分求解。一般地，如果一个一阶微分方程能写成$g(y)\text{d}y=f(x)\text{d}x$的形式，积分得$\int g(y)\text{d}y=\int f(x)\text{d}x$，设原函数分别为$G(y),F(x)$，即$G(y)=F(x)+C$ 第三节 齐次方程如果一阶微分方程可化为$\frac{\text{d}y}{\text{d}x}=\varphi \left (\frac{y}{x}\right )$的形式，那么称这方程为齐次方程。引入未知变量$u=\frac{y}{x}$，则$y=ux,\frac{\text{d}y}{\text{d}x}=u+x\frac{\text{d}u}{\text{d}x}$，代入得$u+x\frac{\text{d}u}{\text{d}x}=\varphi(u)$然后分离变量$\frac{\text{d}u}{\varphi(u)-u}=\frac{\text{d}x}{x}$ 第四节 一阶线性微分方程方程$\frac{\text{d}y}{\text{d}x}+P(x)y=Q(x)$叫做一阶线性微分方程，对于未知函数$y$及其导数是一次方程，如果$Q(x)\equiv 0$那么方程是齐次的，否则是非齐次的。 为求非齐次方程的解，先求对应的齐次线性方程$\frac{\text{d}y}{\text{d}x}+P(x)y=0$，可分离变量$\frac{\text{d}y}{y}=-P(x)\text{d}x$，积分得$\ln |y| =-\int P(x)\text{d}x+C_1$或$y=Ce^{-\int P(x)\text{d}x}(C=\pm e^{C_1})$用常数变易法，把通解中的$C$换成$x$的未知函数$u(x)$，即$y=ue^{-\int P(x)\text{d}x}$，于是$\frac{\text{d}y}{\text{d}x}=u’e^{-\int P(x)\text{d}x}-uP(x)e^{-\int P(x)\text{d}x}$，代入方程得$u’e^{-\int P(x)\text{d}x}-uP(x)e^{-\int P(x)\text{d}x}+P(x)ue^{-\int P(x)\text{d}x}=Q(x)$即$u’e^{-\int P(x)\text{d}x}=Q(x),u’=Q(x)e^{\int P(x)\text{d}x}$，两端积分得$u=\int Qe^{\int P(x)\text{d}x}\text{d}x+C$通解$y=e^{-\int P(x)\text{d}x}\left ( \int Q(x)e^{\int P(x)\text{d}x}\text{d}x+C\right )$ 第五节 可降阶的高阶微分方程$y^{(n)}=f(x)$，接连积分$n$次，得到含有$n$个任意常数的通解 $y’’=f(x,y’)$，设$y’=p$，那么$p’=f(x,p)$，设其通解$p=\varphi(x,C_1),p=\frac{\text{d}y}{\text{d}x}$，因此$\frac{\text{d}y}{\text{d}x}=\varphi(x,C_1)$，积分得到通解$y=\int \varphi(x,C_1)\text{d}x+C_2$ $y’’=f(y,y’)$，令$y’=p$，$y’’=\frac{\text{d}p}{\text{d}x}=\frac{\text{d}p}{\text{d}y}\cdot \frac{\text{d}y}{\text{d}x}=p\frac{\text{d}p}{\text{d}y}$，方程变成$p\frac{\text{d}p}{\text{d}y}=f(y,p)$，通解$y’=p=\varphi(y,C_1)$，分离变量并积分$\int \frac{\text{d}y}{\varphi(y,C_1)}=x+C_1$ 第六节 高阶线性微分方程二阶齐次线性方程$y’’+P(x)y’+Q(x)y=0$定理1 如果函数$y_1(x)$与$y_2(x)$是方程的两个解，那么$y=C_1y_1(x)+C_2y_2(x)$，也是解定理2 如果函数$y_1(x)$与$y_2(x)$是方程的两个线性无关的特解，那么$y=C_1y_1(x)+C_2y_2(x)$是方程的通解定理3 设$y^{\ast}$是二阶非齐次方程的一个特解，$Y(x)$是对应齐次方程的通解，则二阶非齐次方程的通解$y=Y(x)+y^{\ast}(x)$ 另叠加原理，右边是两个函数的和的形式，分别求特解，特解的和是原方程的特解。 第七节 常系数齐次线性微分方程$y’’+py’+qy=0$，其中$p,q$全为常数那么称为二阶常系数齐次微分方程，不全为常数称为二阶变系数齐次微分方程。特征方程$r^2+pr+q=0$，用二次方程求解 两个不相等的实根$r_1,r_2$，通解$y=C_1e^{r_1x}+C_2e^{r_2x}$ 两个相等实根$r_1=r_2$，通解$y=(C_1+C_2x)e^{r_1x}$ 一对共轭负根$r_{1,2}=\alpha + \beta \text{i}$，通解$y=e^{\alpha x}(C_1 \cos \beta x + C_2\sin \beta x$ 第八节 常系数非齐次线性微分方程$y’’+py’+qy=f(x)$二阶常系数非齐次线性微分方程 $f(x)=e^{\lambda x}P_m(x)$结论$y^{\ast}=x^kR_m(x)e^{\lambda x}$，$k$按$\lambda $不是特征方程的根，是特征方程的单根，是特征方程的重根依次取$0,1,2$ $f(x)=e^{\lambda x}[P_l(x)\cos \omega x+Q_n(x)\sin \omega x]$$y^{\ast}=x^ke^{\lambda x}[R_m^{(1)}(x)\cos \omega x+R_m^{(2)}\sin \omega x]$，$k$按$\lambda + \omega\text{i}$不是特征方程的根，是特征方程的单根依次取$0,1$ 我觉得应该考不到吧…忒麻烦了 第八章 向量代数与空间解析几何向量及其运算方向角向量$r$与三条坐标轴的夹角$\alpha \beta \gamma$称为向量$r$的方向角$\cos\alpha=\frac{x}{|r|},\cos\beta=\frac{y}{|r|},\cos\gamma=\frac{z}{|r|}$由方向向量可知$\cos^2\alpha+\cos^2\beta+\cos^2\gamma=1$ 向量在轴上的投影$Prj_ua=|a|\cos\varphi$$Prj_u(a+b)=Prj_ua+Prj_ub$ 数量积$a\cdot b=|a||b|\cos\theta=|a|Prj_ab=|b|Prj_ba=a_xb_x+a_yb_y+a_zb_z$$a\cdot a=|a|^2$非零向量$a,b$,$a\cdot b=0 \Leftrightarrow a\perp b$ 向量积$c=a\times b,|c|=|a||b|\sin\theta,c$垂直于$a$与$b$所决定的平面，用右手定则，四指从$a$转向$b$，拇指指向$c$的方向。$a\times a=0$非零向量$ab$，$a\times b=0 \Leftrightarrow a//b$$b\times a=-a\times b$$a\times b= \left|\begin{matrix} i&amp; j &amp; k\\ a_x&amp; a_y&amp; a_z\\ b_x&amp; b_y &amp; b_z\end{matrix}\right|$同时，$a\times b$ 表示以$a,b$为边的平行四边形面积。 混合积[abc]=(a\times b)\cdot c=\left|\begin{matrix}a_x& a_y& a_z\\ b_x& b_y & b_z \\ c_x& c_y & c_z \end{matrix}\right|混合积的绝对值表示以向量$a,b,c$为棱的平行六面体体积，$a,b,c$若为右手系则正，左手系为负。 平面表示方法点法式如果一非零向量垂直于一平面，这向量就叫做该平面的法线向量。因为过空间一点可以作而且只能作一平面垂直于一已知直线。点法式：平面上一点和平面的法线向量。 A(x-x_0)+B(y-y_0)+C(z-z_0)=0,\overrightarrow{n}=(A,B,C),M=(x_0,y_0,z_0)一般方程Ax+By+Cz+D=0, \overrightarrow{n}=(A,B,C)$D=0$，表示平面过原点$A,B,C=0$，分别表示$\overrightarrow{n}$与$x,y,z$轴垂直，即平面与$x,y,z$轴平行 截距式方程平面相交于坐标轴于$(a,0,0),(0,b,0),(0,0,c)$ \frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1几个小技巧已知三点$M_1,M_2,M_3$求平面方程平面任意一点$M$应该满足$M_1M\cdot (M_1M_2\times M_1M_3)=0$，也就是跟混合积很像的东西了 \left|\begin{matrix}x-x_1& y-y_1& z-z_1\\ x_2-x_1& y_2-y_1 & z_2-z_1 \\ x_3-x_1& y_3-y_1 & z_3-z_1 \end{matrix}\right|=0夹角两平面夹角两平面的法线向量的夹角（通常指锐角或直角）称为两平面的夹角。 \cos\theta=\frac{|A_1A_2+B_1B_2+C_1C_2|}{\sqrt{A_1^2+B_1^2+C_1^2}\sqrt{A_2^2+B_2^2+C_2^2}}两平面$\prod_1,\prod_2$互相垂直$A_1A_2+B_1B_2+C_1C_2=0$两平面$\prod_1,\prod_2$互相平行或重合$\frac{A_1}{A_2}=\frac{B_1}{B_2}=\frac{C_1}{C_2}$ 点到平面距离$P_0$到平面$Ax+By+Cz+D=0$距离，任取一点$P_1$ d=|\overrightarrow{P_0P_1}||\cos\theta|=\frac{|\overrightarrow{P_0P_1}\cdot n|}{|n|}=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}直线表示方法一般方程\left\{\begin{matrix}A_1x+B_1y+C_1z+D_1=0\\ A_2x+B_2y+C_2z+D_2=0\end{matrix}\right.对称式方程 || 点向式方程如果一个非零向量平行于一条已知直线，那么这个向量就叫做这条直线的方向向量。过空间一点可作而且只能作一条直线平行于一已知直线。已知直线$L$上一点$M_0$，和它一方向向量$s=(m,n,p)$对于直线$L$任意一点$M$，$\overrightarrow{MM_0}=(x-x_0,y-y_0,z-z_0)$，有 \frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}此方程组便是直线$L$的方程，叫做直线的对称式方程或点向式方程任一方向向量$s$的坐标$m,n,p$叫做这直线的一组方向数，而向量$s$的方向余弦叫做该直线的方向余弦 参数方程由直线的对称式方程，设 \frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t则，直线的参数方程 \left\{\begin{matrix}x=x_0+mt\\ y=y_0+nt\\z=z_0+pt\end{matrix}\right.两直线的夹角两直线的方向向量的夹角（通常指锐角或直角）叫做两直线的夹角。设直线$L_1,L_2$方向向量$s_1=(m_1,n_1,p_1),s_2=(m_2,n_2,p_2)$，则夹角$\varphi$. \cos\varphi=\frac{|m_1m_2+n_1n_2+p_1p_2|}{\sqrt{m_1^2+n_1^2+p_1^2}\sqrt{m_2^2+n_2^2+p_2^2}}两直线$L_1,L_2$互相垂直$m_1m_2+n_1n_2+p_1p_2=0$两直线$L_1,L_2$互相平行或重合$\frac{m_1}{m_2}=\frac{n_1}{n_2}=\frac{p_1}{p_2}$ 直线与平面的夹角当直线与平面不垂直是直线和它在平面上的投影直线的夹角$\varphi(0\leqslant \varphi &lt; \frac{\pi}{2})$，称为直线与平面的夹角，当直线与平面垂直时，规定直线与平面的夹角为$\frac{\pi}{2}$设直线方向向量$s=(m,n,p)$，平面法线向量$n=(A,B,C)$，直线与平面夹角$\varphi$. sin\varphi =\frac{Am+Bn+Cp}{\sqrt{A^2+B^2+C^2}\sqrt{m^2+n^2+p^2}}直线与平面垂直$\frac{A}{m}=\frac{B}{n}=\frac{C}{p}$直线与平面平行或在平面上$Am+Bn+Cp=0$ 平面束方程直线$L$. \left\{\begin{matrix}A_1x+B_1y+C_1z+D_1=0\\ A_2x+B_2y+C_2z+D_2=0\end{matrix}\right.方程$A_1x+B_1y+C_1z+D_1+\lambda (A_2x+B_2y+C_2z+D_2)=0$，能表示所有经过直线的平面，除了方程中第二个平面。通过定直线的所有平面的全体称为平面束。 直线与平面的交点解法一：将直线转化成参数方程，带入平面方程。解法二：求解三元一次方程。 点到直线的距离解法一：计算直线的方向向量，任取直线上一点，造一个三角形来计算夹角正弦。解法二：计算直线的方向向量，做过定点以直线方向向量为法向量的平面方程，将直线转化成参数方程求交点，最后求两点距离。解法三：$d=\frac{|P_0P\times s|}{|s|}$ 点到平面的投影由定点和平面法向量确定一条直线，用直线参数方程求交点。 直线到平面的投影解法一：用平面束方程，再由两平面垂直可以得到过直线且垂直于已知平面的平面方程，联立即可得到投影方程。解法二：求法向量和直线与平面的交点再加直线的一个点，确定垂直于已知平面的平面，联立即可得到投影方程。 曲面及其方程球面(x-x_0)^2+(y-y_0)^2+(z-z_0)^2=R^2Ax^2+Ay^2+Az^2+Dx+Ey+Fz+G=0旋转曲面以一条平面曲线绕其平面上的一条直线旋转一周所成的曲面叫做旋转曲面，旋转曲线和定直线依次叫做旋转曲面的母线和轴 直线$L$绕另一条与$L$相交的直线旋转一周，所得旋转曲面叫做圆锥面。两直线的交点叫做圆锥的顶点，两直线的夹角$\alpha (0&lt;\alpha &lt;\frac{\pi}{2})$叫做圆锥面的半顶角。 对于绕$z$轴的曲线，原曲线$f(y,z)=0$，旋转后$f(\pm \sqrt{x^2+y^2},z)=0$ 圆锥面z=\pm \sqrt{x^2+y^2} \cot \alpha旋转双曲面$xOz$平面上的方程$\frac{x^2}{a^2}-\frac{z^2}{c^2}=0$绕$z$轴旋转所成的旋转曲面叫做旋转单叶双曲面，绕$x$轴旋转所成的旋转曲面叫做旋转双叶双曲面。 柱面如$x^2+y^2=R^2$，不含$z$坐标，可以看做是由平行于$z$轴的直线$l$沿$xOy$面上的圆移动而形成的，这曲面叫做圆柱面,$xOy$面上的圆$x^2+y^2=R^2$叫做它的准线，这平行于$z$轴的直线$l$叫做它的母线。 一般地，直线$L$沿定曲线$C$平行移动形成的轨迹叫做柱面，定直线$C$叫做柱面的准线，动直线L叫做柱面的母线。 类似地，方程$y^2=2x$表示母线平行于$z$轴的柱面他的准线是$xOy$面上的抛物线，该柱面叫做抛物柱面。 二次曲面把三元二次方程$F(x,y,z)=0$所表示的曲面称为二次曲面，把平面称为一次曲面。 椭圆锥面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=z^2$以垂直于$z$轴的平面$z=t$截此平面，$t=0$时得一点$(0,0,0)$；$t\neq 0$时得椭圆$\frac{x^2}{(at)^2}+\frac{y^2}{(bt)^2}=1$平面$z=t$与曲面$F(x,y,z)=0$的交线称为截痕，通过综合截痕的变化来了解曲面形状的方法称为截痕法。 椭球面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$把$xOz$面上的椭圆$\frac{x^2}{a^2}+\frac{z^2}{c^2}=1$绕$z$轴旋转，所得曲面称为旋转椭球面，其方程为$\frac{x^2+y^2}{a^2}+\frac{z^2}{c^2}=1$，再把旋转椭球面沿$y$轴方向伸缩$\frac{b}{a}$倍，便得椭球面。 单叶双曲面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$把$xOz$面上的双曲线$\frac{x^2}{a^2}-\frac{z^2}{c^2}=1$绕$z$轴旋转得到旋转单叶双曲面$\frac{x^2+y^2}{a^2}-\frac{z^2}{c^2}=1$，再沿$y$轴方向伸缩$\frac{b}{a}$得到。 双叶双曲面 $\frac{x^2}{a^2}-\frac{y^2}{b^2}-\frac{z^2}{c^2}=1$把$xOz$面上的双曲线$\frac{x^2}{a^2}-\frac{z^2}{c^2}=1$绕$x$轴旋转得到旋转双叶双曲面$\frac{x^2}{a^2}-\frac{y^2+z^2}{c^2}=1$，再沿$y$轴方向伸缩$\frac{b}{c}$得到。 椭圆抛物面 $\frac{x^2}{a^2}+\frac{y^2}{b^2}=z$把$xOz$面上的抛物线$\frac{x^2}{a^2}=z$绕$z$轴旋转，所得的曲面叫做旋转抛物面，再沿$y$轴方向伸缩$\frac{b}{a}$倍 双曲抛物面 $\frac{x^2}{a^2}-\frac{y^2}{b^2}=z$双曲抛物面又称马鞍面用$x=t$截此平面，截痕为$l$，轨迹为$L$，双曲抛物面母线为$l$，$L$为准线。 还有三种二次曲面椭圆柱面$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$，双曲柱面$\frac{x^2}{a^2}-\frac{y^2}{b^2}=1$，抛物柱面$x^2=ay$ 空间曲线及其方程空间曲线的一般方程空间曲线可以看做两个曲面的交线，则方程组 \left\{\begin{matrix}F(x,y,z)=0\\G(x,y,z)=0 \end{matrix}\right.是两个曲面交线的方程，也叫做空间曲线的一般方程。 空间曲线的参数方程将空间曲线$C$上动点的坐标$x,y,z$表示为参数$t$的函数 \left\{\begin{matrix}x=x(t)\\y=y(t)\\z=z(t) \end{matrix}\right.当给定$t=t_1$时，就得到$C$上的一个点$(x_1,y_1,z_1)$；随着$t$的变动便可得到曲线$C$上的全部点，方程组叫做空间曲线的参数方程。 螺旋线若空间一个点$M$在圆柱面$x^2+y^2=a^2$上以角速度$\omega $绕$z$轴旋转，同时又以线速度$v$沿平行于$z$轴正方向上升，那么$M$构成的图形叫做螺旋线。 \left\{\begin{matrix}x=a\cos\theta\\y=a\sin\theta\\z=b\theta \end{matrix}\right.,b=\frac{v}{\omega}其中，参数为$\theta$，$h=2\pi b$称为螺距，即旋转一周上升的距离 曲面参数方程\left\{\begin{matrix}x=x(s,t)\\y=y(s,t)\\z=z(s,t) \end{matrix}\right.空间曲线在坐标面上的投影以曲线$C$为准线、母线平行于$z$轴的柱面叫做曲线$C$关于$xOy$面的投影柱面，投影柱面与$xOy$面的交线叫做空间曲线$C$在$xOy$面上的投影曲线，简称投影。即在$xOy$面上的投影 \left\{\begin{matrix}H(x,y)=0\\z=0 \end{matrix}\right.第九章 多元函数微分法及其应用多元函数基本概念平面点集设$P_0(x_0,y_0)$是$xOy$平面上的一个点，$\delta $是某一正数。与点$P_0(x_0,y_0)$距离小于$\delta $的点$P(x,y)$的全体，称为点$P_0$的$\delta$邻域，记作$U(P_0,\delta )$，即$U(P_0,\delta )=\{P||PP_0|&lt;\delta\}$，点$P_0$的去心$\delta$邻域$\overset{\circ}{U}(P_0,\delta )=\{P|0&lt;|PP_0|&lt;\delta\}$ 利用邻域描述点和点集之间的关系任意一点$P\in R^2$与任意一个点集$E\subset R^2$之间必有以下三种关系的一种 内点：如果存在点$P$的某个邻域$U(P)$，使得$U(P)\subset E$，那么称$P$为$E$的内点 外点：如果存在点$P$的某个邻域$U(P)$，使得$U(P)\cap E=\varnothing$，那么称$P$为$E$的外点 边界点：如果点$P$的任一邻域内既含有属于$E$的点，又含有不属于$E$的点，那么称$P$为$E$的边界点。$E$的边界点的全体，称为$E$的边界，记作$\partial E$$E$的内点必属于$E$；$E$的外点必定不属于$E$；而$E$的边界点可能属于$E$，也可能不属于$E$。 聚点：如果对于任意给定的$\delta &gt;0$，点$P$的去心邻域$\overset{\circ}{U}(P,\delta)$内总有$E$种的点，那么称$P$是$E$的聚点。 重要的平面点集 开集：如果点集$E$的点都是$E$的内点，那么称$E$为开集。 闭集：如果点集$E$的边界$\partial E\subset E$，那么称$E$为闭集。 连通集：如果点集$E$内任何两点，都可用折线联结起来，且该折线上的点都属于$E$，那么称$E$为连通集 区域（或开区域）：连通的开集称为区域或开区域。 闭区域：开区域连同它的边界一起所构成的点集称为闭区域。 有界集：对于平面点集$E$，如果存在某一正数$r$，使得$E\subset U(O,r)$，其中$O$是坐标原点，那么称$E$为有界集。 无界集：一个集合如果不是有界集，就称这个集合为无界集。 多元函数概念定义：设$D$是$R^2$的一个非空子集，称映射$f:D\rightarrow R$为定义在$D$上的二元函数，通常记为$z=f(x,y),(x,y)\in D$ 或 $z=f(P),P\in D$，其中点集$D$称为该函数的定义域，$x,y$称为自变量，$z$称为因变量。函数值$f(x,y)$的全体所构成的集合称为函数$f$的值域，记作$f(D)$。类似的$n$元函数，$u=f(x_1,x_2,…,x_n),(x_1,x_2,…,x_n)\in D$ 或简记为 $u=f(x),x=(x_1,x_2,…,x_n)\in D$，也可记为$u=f(P),P(x_1,x_2,…,x_n)\in D$$n=1$时，$n$元函数就是一元函数；$n\geqslant 2$时，$n$元函数统称为多元函数。讨论多元函数$u=f(x)$时，以使这个算式有意义的变元$x$的值所组成的点集为这个多元函数的自然定义域。$\{(x,y,z)|z=f(x,y),(x,y)\in D\}$这个点集称为二元函数$z=f(x,y)$的图形。 多元函数的基线定义：设二元函数$f(P)=f(x,y)$的定义域为$D$，$P_0(x_0,y_0)$是$D$的聚点，如果存在常数$A$，对于任意给定的正数$\varepsilon$，总存在正数$\delta$，使得当点$P(x,y)\in D \cap \overset{\circ}{U}(P_0,\delta)$时，都有$|f(P)-A|=|f(x,y)-A|&lt;\varepsilon$成立，那么就称常数$A$为函数$f(x,y)$当$(x,y)\rightarrow (x_0,y_0)$时的极限，记作$\lim_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=A$ 或 $f(x,y)\rightarrow A((x,y)\rightarrow (x_0,y_0))$，也记作$\lim_{P\rightarrow P_0}f(P)=A$ 或 $f(P)\rightarrow A(P\rightarrow P_0)$把二元函数的极限叫做二重极限。 多元函数的连续性定义：设二元函数$f(P)=f(x,y)$的定义域为$D$，$P_0(x_0,y_0)$为$D$的聚点，且$P_0\in D$。如果$\lim_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=f(x_0,y_0)$，那么称函数$f(x,y)$在点$P_0(x_0,y_0)$连续。设函数$f(x,y)$在$D$上有定义，$D$内的每一个点都是函数定义域的聚点。如果函数$f(x,y)$在$D$的每一点都连续，那么就称函数$f(x,y)$在$D$上连续，或者乘$f(x,y)$是$D$上的连续函数。 定义：设二元函数$f(P)=f(x,y)$的定义域为$D$，$P_0(x_0,y_0)$为$D$的聚点。如果函数$f(x,y)$在点$P_0(x_0,y_0)$不连续，那么称$P_0(x_0,y_0)$为函数$f(x,y)$的间断点。 一切多元初等函数在其定义区域内是连续的，所谓定义区域是指包含在定义域内的区域或闭区域。 性质1（有界性与最大值最小值定理） 在有界闭区域$D$上的多元连续函数，必定在$D$上有界，且能取得它的最大值和最小值。性质2（介值定理） 在有界闭区域$D$上的多元连续函数必取得介于最大值和最小值之间的任何值。性质3（一致连续性定理） 在有界闭区域$D$上的多元连续函数必定在$D$上一致连续。 偏导数偏导数定义及其计算法定义： 设函数$z=f(x,y)$在点$(x_0,y_0)$的某一邻域内有定义，当$y$固定在$y_0$而$x$在$x_0$处有增量$\Delta x$时，相应的函数有增量$f(x_0+\Delta x,y_0)-f(x_0,y_0)$，如果$\lim_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}$存在，那么称此极限为函数$z=f(x,y)$在点$(x_0,y_0)$处对$x$的偏导数，记作 \left .\frac{\partial z}{\partial x} \right |_ {\begin{matrix}x=x_0\\y=y_0\end{matrix}},\left .\frac{\partial f}{\partial x} \right |_ {\begin{matrix}x=x_0 \\ y=y_0\end{matrix}},\left . z_x\right |_ {\begin{matrix}x=x_0\\y=y_0\end{matrix}},f_x(x_0,y_0)对于多元函数来书豪，即使各偏导数在某点都存在，也不能保证函数在该点连续。 高阶偏导数设函数$z=f(x,y)$在区域$D$内具有偏导数 \frac{\partial z}{\partial x}=f_x(x,y),\frac{\partial z}{\partial y}=f_y(x,y)于是在$D$内$f_x(x,y),f_y(x,y)$都是$x,y$的函数，如果这两个函数的偏导数也存在，那么称它们是函数$z=f(x,y)$的二阶偏导数，按照对变量求导次序的不同有下列四个二阶偏导数： \begin{matrix}\frac{\partial}{\partial x}\left (\frac{\partial z}{\partial x}\right )=\frac{\partial^2 z}{\partial x^2}=f_{xx}(x,y),\frac{\partial}{\partial y}\left (\frac{\partial z}{\partial x}\right )=\frac{\partial^2 z}{\partial x\partial y}=f_{xy}(x,y)\\ \frac{\partial}{\partial x}\left (\frac{\partial z}{\partial y}\right )=\frac{\partial^2 z}{\partial y\partial x}=f_{yx}(x,y),\frac{\partial}{\partial y}\left (\frac{\partial z}{\partial y}\right )=\frac{\partial^2 z}{\partial y^2}=f_{yy}(x,y)\end{matrix}其中第二、三两个偏导数称为混合偏导数。二阶及二阶以上的偏导数统称为高阶偏导数。 定理：如果函数$z=f(x,y)$的两个二阶混合偏导数$\frac{\partial ^2 z}{\partial y\partial x},\frac{\partial ^2z}{\partial x\partial y}$在区域$D$内连续，那么在该区域内这两个二阶混合偏导数必相等，换句话说，二阶混合偏导数在连续的条件下与求导的次序壶关。 全微分全微分定义f(x+\Delta x,y)-f(x,y)\approx f_x(x,y)\Delta xf(x,y+\Delta y)-f(x,y)\approx f_y(x,y)\Delta y左端分别叫做二元函数对$x$和对$y$的偏增量，而右端分别叫做二元函数对$x$和对$y$的偏微分。在点$P(x,y)$对应于自变量的增量$\Delta x,\Delta y$的全增量，记作$\Delta z$，即$\Delta z=f(x+\Delta,y+\Delta)-f(x,y)$ 定义：设函数$z=f(x,y)$在点$(x,y)$的某邻域内有定义，如果函数在点$(x,y)$的全增量$\Delta z=f(x+\Delta,y+\Delta)-f(x,y)$，可表示为$\Delta z=A\Delta x+B\Delta y+o(\rho)$，其中$A$和$B$不依赖于$\Delta x$和$\Delta y$而仅与$x$和$y$有关，$\rho =\sqrt{(\Delta x)^2+(\Delta y)^2}$，那么称函数$z=f(x,y)$在点$(x,y)$可微分，而$A\Delta x+B\Delta y$称为函数$z=f(x,y)$在点$(x,y)$的全微分，记作$\text{d} z$，即$\text{d} z=A\Delta x+B\Delta y$ 在某点可微分，必定连续 定理1（必要条件） 如果函数$z=f(x,y)$在点$(x,y)$可微分，那么该函数在点$(x,y)$的偏导数$\frac{\partial z}{\partial x}$与$\frac{\partial z}{\partial y}$必定存在，且函数$z=f(x,y)$在点$(x,y)$的全微分为 \text{d} z=\frac{\partial z}{\partial x}\Delta x+\frac{\partial z}{\partial y}\Delta y定理2（充分条件） 如果函数$z=f(x,y)$的偏导数$\frac{\partial z}{\partial x}$与$\frac{\partial z}{\partial y}$在点$(x,y)$连续，那么函数在该点可微分。 通常把二元函数的全微分等于它的两个偏微分之和这件事称为二元函数的微分符合叠加原理。 多元函数求导法则懒得打那么多了… \frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\frac{\partial u}{\partial x}+\frac{\partial z}{\partial v}\frac{\partial v}{\partial x}注意一下是$\partial$还是$\text{d}$就行了这也叫做全导数 无论$u$和$v$是自变量还是中间变量，函数$z=f(u,v)$的全微分形式是一样的，这个性质叫做全微分形式不变性。 隐函数求导公式一个方程的情况同上…懒得打太详细 \frac{\text{d} y}{\text{d} x}=-\frac{F_x}{F_y}\frac{\partial z}{\partial x}=-\frac{F_x}{F_z},\frac{\partial z}{\partial y}=-\frac{F_y}{F_z}方程组的情况隐函数存在定理3 设$F(x,y,u,v),G(x,y,u,v)$在点$P(x_0,y_0,u_0,v_0)$的某一邻域内具有各个变量的连续偏导数，又$F(x_0,y_0,u_0,v_0)=0,G(x_0,y_0,u_0,v_0)=0$，且偏导数所组成的函数行列式（或称雅可比(Jacobi)式） J=\frac{\partial(F,G)}{\partial(u,v)}=\begin{vmatrix}\frac{\partial F}{\partial u} &\frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u} &\frac{\partial G}{\partial v} \end{vmatrix}在点$P(x_0,y_0,u_0,v_0)$不等于零，而方程组$F(x_0,y_0,u_0,v_0)=0,G(x_0,y_0,u_0,v_0)=0$在点$P(x_0,y_0,u_0,v_0)$的某一邻域内恒能唯一确定一组连续且具有连续偏导数的函数$u=u(x,y),v=v(x,y)$，它们满足条件$u_0=u(x,y),v_0=v(x,y)$，并有 \frac{\partial u}{\partial x}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(x,v)}=-\frac{\begin{vmatrix} F_x &F_v \\ G_x &G_v \end{vmatrix}}{\begin{vmatrix}F_u &F_v \\ G_u &G_v \end{vmatrix}}\frac{\partial v}{\partial x}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(u,x)}=-\frac{\begin{vmatrix} F_u &F_x \\ G_u &G_x \end{vmatrix}}{\begin{vmatrix}F_u &F_v \\ G_u &G_v \end{vmatrix}}\frac{\partial u}{\partial y}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(y,v)}=-\frac{\begin{vmatrix} F_y &F_v \\ G_y &G_v \end{vmatrix}}{\begin{vmatrix}F_u &F_v \\ G_u &G_v \end{vmatrix}}\frac{\partial v}{\partial y}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(u,y)}=-\frac{\begin{vmatrix} F_u &F_y \\ G_u &G_y \end{vmatrix}}{\begin{vmatrix}F_u &F_v \\ G_u &G_v \end{vmatrix}}多元函数微分学的几何应用一元向量值函数及其导数定义1 设数集$D\subset R$，则称映射$f:D\rightarrow R^n$为一元向量值函数，通常记为$r=f(t),t\in D$，其中数集$D$称为函数的定义域，$t$称为自变量，$r$称为因变量。 定义2 设向量值函数$f(t)$在点$t_0$的某一去心邻域内有定义，如果存在一个常向量$r_0$，对于任意给定的正数$\varepsilon $，总存在正数$\delta $，使得当$t$满足$0&lt;|t-t_0|&lt;\delta $时，对应的函数值$f(t)$都满足不等式$|f(t)-r_0|&lt;\varepsilon$，那么，常向量$r_0$就叫做向量值函数$f(t)$当$t\rightarrow t_0$时的极限，记作$\lim_{t\rightarrow t_0}f(t)=r_0$ 或 $f(t)\rightarrow r_0,t\rightarrow t_0$ 定义3 设向量值函数$r=f(t)$在点$t_0$的某一邻域内有定义，如果$\lim_{\Delta t\rightarrow 0}\frac{\Delta r}{\Delta t}=\lim_{\Delta t\rightarrow 0}\frac{f(t_0+\Delta t)-f(t_0)}{\Delta t}$存在，那么就称这个极限向量为向量值函数$r=f(t)$在$t_0$处的导数或导向量，记作$f’(t_0)$或$\left .\frac{\text{d} r}{\text{d} t}\right |_ {t=t_0}$ 注意切向量有正负两个 空间曲线的切线与法平面空间曲线参数方程 \left\{\begin{matrix}x=\varphi(t)\\ y=\psi (t)\\z=\omega (t)\end{matrix}\right.在点$M(x_0,y_0,z_0)$处的切线方程 \frac{x-x_0}{\varphi'(t_0)}=\frac{y-y_0}{\psi'(t_0)}=\frac{z-z_0}{\omega'(t-t_0)}法平面方程 \varphi'(t_0)(x-x_0)+\psi' (t)(y-y_0)+\omega' (t)(z-z_0)=0曲线的切平面与法线曲面上通过点$M$的一切曲线在点$M$的切线都在同一平面上，这个平面称为曲面$\Sigma $在点$M$的切平面，这个切平面的方程是 F_x(x_0,y_0,z_0)(x-x_0)+F_y(x_0,y_0,z_0)(y-y_0)+F_z(x_0,y_0,z_0)(z-z_0)=0通过点$M(x_0,y_0,z_0)$且垂直于切平面的直线称为曲面在该点的法线，法线方程是 \frac{x-x_0}{F_x(x_0,y_0,z_0)}=\frac{y-y_0}{F_y(x_0,y_0,z_0)}=\frac{z-z_0}{F_z(x_0,y_0,z_0)}垂直于曲面上切平面的向量称为曲面的法向量，向量 n=(F_x(x_0,y_0,z_0),F_y(x_0,y_0,z_0),F_y(x_0,y_0,z_0))方向导数与梯度方向导数定理 如果函数$f(x,y)$在点$P(x_0,y_0)$可微分，那么函数在该点沿任一方向$l$的方向导数存在，且有 \left .\frac{\partial f}{\partial l}\right |_ {(x_0,y_0)}=f_x(x_0,y_0)\cos \alpha +f_y(x_0,y_0)\cos \beta其中，$\cos \alpha$和$\cos \beta$是方向$l$的方向余弦。 梯度\mathbf{grad}f(x_0,y_0)=\nabla f(x_0,y_0)=f_x(x_0,y_0)i+f_y(x_0,y_0)j其中$\nabla =\frac{\partial}{\partial x}i+\frac{\partial}{\partial y}j$称为（二维的）向量微分算子或Nabla算子。 \begin{align*} \left .\frac{\partial f}{\partial l}\right |_ {(x_0,y_0)}&= f_x(x_0,y_0)\cos \alpha +f_y(x_0,y_0)\cos \beta\\ &= \mathbf{grad}f(x_0,y_0)\cdot e_l=|\mathbf{grad}f(x_0,y_0)|\cos \theta\\& \theta=(\widehat{\mathbf{grad}f(x_0,y_0),e_l})\end{align*}类似地，可以推广到三元函数的情形 数量场 向量场 引力场如果对于空间区域$G$内的任一点$M$，都有一个确定的数量$f(M)$，那么称在这空间区域$G$内确定了数量场。一个数量场可用一个数量函数$f(M)$来确定，如果与点$M$相对应的是一个向量$F(M)$，那么称在这空间区域$G$内确实能够了一个向量场。一个向量场可用一个向量值函数$F(M)$来确定，而$F(M)=P(M)i+Q(M)j+R(M)k$，其中$P(M),Q(M),R(M)$是点$M$的数量函数。若向量场$F(M)$是某个数量函数$f(M)$的梯度，则称$f(M)$是向量场$F(M)$的一个势函数，并称向量场$F(M)$为势场。 多元函数的极值及其求法多元函数的极值及最大值和最小值定义 设函数$z=f(x,y)$的定义域为$D$，$P_0(x_0,y_0)$为$D$的内点，若存在$P_0$的某个邻域$U(P_0)\subset D$，使得对于该邻域内异于$P_0$的任何点$(x,y)$，都有$f(x,y) &lt; f(x_0,y_0)$，则称函数$f(x,y)$在点$(x_0,y_0)$有极大值$f(x_0,y_0)$，点$(x_0,y_0)$称为函数的极大值点。类似地，可以定义极小值点，极大值与极小值统称为极值，使得函数取得极值的点称为极值点。 定理1（必要条件） 设函数$z=f(x,y)$在点$(x_0,y_0)$具有偏导数，且在点$(x_0,y_0)$处有极值，则有$f_x(x_0,y_0)=0,f_y(x_0,y_0)=0$ 凡是能使$f_x(x_0,y_0)=0,f_y(x_0,y_0)=0$成立的点$x_0,y_0$称为函数$z=f(x,y)$的驻点 定理2（充分条件） 设函数$z=f(x,y)$在点$(x_0,y_0)$的某一邻域内连续且有一阶及二阶连续偏导数，又$f_x(x_0,y_0)=0,f_y(x_0,y_0)=0$，令 f_{xx}(x_0,y_0)=A,f_{xy}(x_0,y_0)=B,f_{yy}(x_0,y_0)=C则$f(x,y)$在$(x_0,y_0)$处是否取得极值的条件如下：（1）$AC-B^2&gt;0$时具有极值，且当$A0$时有极小值；（2）$AC-B^2&lt;0$时没有极值；（3）$AC-B^2=0$时可能有极值，也可能没有极值，还需另作讨论。 条件极值对于函数自变量，除了限制在函数的定义域内外，并无其他条件，称为无条件极值。对自变量有附加条件的极值称为条件极值。有时需要将条件极值转化成无条件极值进行计算。 拉格朗日乘数法一种寻求条件极值的方法要找函数$z=f(x,y)$在附加条件下$\varphi(x,y)=0$下的可能极值点，可以先作拉格朗日函数 L(x,y)=f(x,y)+\lambda \varphi(x,y)其中$\lambda $为参数，称为拉格朗日乘子，求其对$x$与$y$的一阶偏导数，并使之为零，$L_x(x,y)=0,L_y(x,y)=0$，联立可得 \left\{\begin{matrix}f_x(x,y)+\lambda \varphi_x(x,y)=0\\ f_y(x,y)+\lambda \varphi_y(x,y)=0\\\varphi(x,y)=0 \end{matrix}\right.由此解出$x,y,\lambda$，这样得到的$(x,y)$就是函数$f(x,y)$在附加条件$\varphi(x,y)=0$下的可能极值点$\lambda$表示的是$-\frac{f_y(x_0,y_0)}{\varphi_y(x_0,y_0)}$ 多变量多条件情况下的拉格朗日函数 L(x,y,z,t)=f(x,y,z,t)+\lambda \varphi(x,y,z,t)+\mu \psi(x,y,z,t)第十章 重积分二重积分的概念与性质概念曲顶柱体：它的底是$xOy$面上的闭区域，则侧面是以$D$的边界曲线为准线，母线平行于$z$轴的柱面，顶是曲面。 定义： 设$f(x,y)$是有界闭区域$D$上的有界函数，将闭区域$D$任意分成$n$个小闭区域$\Delta \sigma_1, \Delta \sigma_2,…,\Delta \sigma_n$，其中$\Delta \sigma_i$表示第$i$个小闭区域，也表示它的表面积。在每个$\Delta \sigma_i$上任取一点$(\xi_i, \eta_i)$，作乘积$f(\xi_i, \eta_i)\Delta \sigma_i(i=1,2,…,n)$，并作和$\sum_{i=1}^{n}f(\xi_i, \eta_i)\Delta \sigma_i$。如果当各小闭区域的直径中的最大值$\lambda \rightarrow 0$时，这和的极限总存在，且与闭区域$D$的分法及点$(\xi_i, \eta_i)$的取法无关，那么称此极限为函数$f(x,y)$在闭区域$D$上的二重积分，记作$\iint_{D}f(x,y)\text{d}\sigma$，即 \iint_{D}f(x,y)\text{d}\sigma=\lim_{\lambda \rightarrow 0}{\sum_{i=1}^{n}f(\xi_i, \eta_i)\Delta \sigma_i}其中$f(x,y)$叫做被积函数，$f(x,y)\text{d}\sigma$叫做被积表达式，$\text{d}\sigma$叫做面积元素，$x$与$y$叫做积分变量，$D$叫做积分区域，$\sum_{i=1}^{n}f(\xi_i, \eta_i)\Delta \sigma_i$叫做积分和。$\text{d}\sigma$有时记作$\text{d}x\text{d}y$叫做直角坐标系中的面积元素 性质 性质1\iint _{D}{[\alpha f(x,y)+\beta g(x,y)]\text{d}\sigma}=\alpha \iint_{D}f(x,y)\text{d}\sigma+\beta \iint_{D}g(x,y)\text{d}\sigma 性质2 积分区域可加性\iint_{D}f(x,y)\text{d}\sigma=\iint_{D_1}f(x,y)\text{d}\sigma+\iint_{D_2}f(x,y)\text{d}\sigma,D=D_1+D_2 性质3\sigma=\iint_{D}1\cdot\text{d}\sigma=\iint_{D}\text{d}\sigma 性质4如果在$D$上，$f(x,y)\leqslant g(x,y)$，那么有\iint_{D}f(x,y)\text{d}\sigma\leqslant \iint_{D}g(x,y)\text{d}\sigma特殊地，由于-|f(x,y)|\leqslant f(x,y)\leqslant |f(x,y)|又有\left |\iint_{D}f(x,y)\text{d}\sigma\right |\leqslant \iint_{D}|f(x,y)|\text{d}\sigma 性质5 设$M$和$m$分别是$f(x,y)$在闭区域$D$上的最大值和最小值m\sigma\leqslant \iint_{D}f(x,y)\text{d}\sigma\leqslant M\sigma\iint_{D}m\text{d}\sigma\leqslant \iint_{D}f(x,y)\text{d}\sigma\leqslant \iint_{D}M\text{d}\sigma 性质6（二重积分的中值定理） 设函数$f(x,y)$在闭区域$D$连续，$\sigma$是$D$的面积，则在$D$上至少存在一点$(\xi_i, \eta_i)$，使得\iint_{D}f(x,y)\text{d}\sigma=f(\xi_i, \eta_i)\sigma 二重积分的计算法利用直角坐标计算二重积分转化成二次积分 \iint_{D}f(x,y)\text{d}\sigma=\int_{a}^{b}{\text{d}x\int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)\text{d}y}\iint_{D}f(x,y)\text{d}\sigma=\int_{a}^{b}{\text{d}y\int_{\psi_1(y)}^{\psi_2(y)}f(x,y)\text{d}x}积分的时候注意是不是$X$型区域或$Y$型区域 利用极坐标计算二重积分\iint_{D}f(x,y)\text{d}\sigma=\iint_{D}f(\rho \cos \theta,\rho \cos \theta)\rho\text{d}\rho\text{d}\theta$\rho\text{d}\rho\text{d}\theta$就是极坐标中的面积元素 \iint_{D}f(\rho \cos \theta,\rho \cos \theta)\rho\text{d}\rho\text{d}\theta=\int_{\alpha}^{\beta}\text{d}\theta\int_{\varphi_1(\theta)}^{\varphi_2(\theta)}f(\rho \cos \theta,\rho \cos \theta)\rho\text{d}\rho面积 \sigma=\iint_{D}\rho\text{d}\rho\text{d}\theta=\int_{\alpha}^{\beta}\text{d}\theta\int_{\varphi_1(\theta)}^{\varphi_2(\theta)}\rho\text{d}\rho=\frac{1}{2}\int_{\alpha}^{\beta}[\varphi_{2}^{2}(\theta)-\varphi_{1}^{2}(\theta)]\text{d}\theta例题 反常积分的计算反常积分$\int_{0}^{+\infty }e^{-x^2}\text{d}x$设 \begin{align*}D_1&= \{(x,y)|x^2+y^2\leqslant R^2,x\geqslant 0,y\geqslant 0\} \\ D_2 &= \{(x,y)|x^2+y^2\leqslant 2R^2,x\geqslant 0,y\geqslant 0\}\\ S &=\{(x,y)|0\leqslant x\leqslant R,0\leqslant y\leqslant R\} \end{align*}显然$D_1\subset S\subset D_2$，有二重积分不等式 \iint_{D_1}e^{-x^2-y^2}\text{d}x\text{d}y < \iint_{S}e^{-x^2-y^2}\text{d}x\text{d}y]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeJamQualificationRound]]></title>
    <url>%2F2019%2F04%2F07%2Fpro-CodeJamQualificationRound%2F</url>
    <content type="text"><![CDATA[某未出土选手出土训练还没做就来打比赛了。还好我设置了提醒，不然就忘记了… 只做了T1和T2 T1Description给一个数$n$，表示成两个数相加的形式，$A+B=n$，其中$A$，$B$的各位不能包含$4$$T\leqslant 100, n\leqslant 10^{100}$ Solution每位独立的来做就好了…一共三个点，第一个点$10^5$，第二个点$10^9$，最后一个点才$10^{100}$暴力可以过第一个点，随机化可以过第二个点，然后我最后写的这个应该可以过第三个点。一开始以为不能输出0的，怕被111这种卡掉，然后发现好像可以，然后被100卡掉了…最后修改了一下 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;char ch[N];int ans1[N], ans2[N];void out(int l, int ans[]) &#123; int s=0; for(; s&lt;l; s++) if(ans[s]) break; if(s==l) putchar('0'); for(; s&lt;l; s++) putchar('0'+ans[s]);&#125;int main() &#123; srand(time(0)); int t; scanf("%d",&amp;t); for(int c=1;c&lt;=t;c++) &#123; scanf("%s", ch); int l=strlen(ch); for(int i=0; i&lt;l; i++) &#123; int x=ch[i]-'0'; if(x==0) &#123; ans1[i]=ans2[i]=0;continue; &#125; for(int u=1; u&lt;=x; u++) if(u!=4 &amp;&amp; x-u!=4) &#123; if(rand()&amp;1) &#123; ans1[i]=u, ans2[i]=x-u; &#125; else &#123; ans1[i]=x-u, ans2[i]=u; &#125; break; &#125; &#125; printf("Case #%d: ",c); out(l, ans1), putchar(' '), out(l, ans2), putchar('\n'); &#125; return 0;&#125; T2Description一个$n\times n$的网格，每次只能向右或向下，给出一条路径，让你不发生路径覆盖的从左上走到右下。$T\leqslant 100 , n\leqslant 5\times 10^5$ Solution…其实输出对称的路径就能过… Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;char ch[N];int main() &#123; int t, n, l; scanf("%d", &amp;t); for(int c=1; c&lt;=t; c++) &#123; scanf("%d", &amp;n); scanf("%s", ch); l=strlen(ch); for(int i=l-1; ~i; i--) &#123; if(ch[i]=='S') ch[i]='E'; else ch[i]='S'; &#125; printf("Case #%d: %s\n", c, ch); &#125; return 0;&#125; 后面两道题连开都没开..然后时间就到了…昨天开始的，现在已经结束了…差点没赶上..]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>codejam</tag>
        <tag>program</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程基础笔记]]></title>
    <url>%2F2019%2F03%2F30%2Fnote-softwareproject%2F</url>
    <content type="text"><![CDATA[概念软件：软件生命周期：将软件产品从提出、实现、使用维护到停止使用退役的过程。分为三个阶段：定义阶段、开发阶段、维护阶段。软件定义阶段的任务是：确定软件开发工作必须完成的目标；确定工程的可行性。软件开发阶段的任务是：具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试。总体设计和系统设计又称为系统设计，编码和测试又称为系统实现。软件维护阶段的任务是：使软件在运行中持久的满足用户的需要。]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>softwareproject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记]]></title>
    <url>%2F2019%2F03%2F29%2Fnote-database%2F</url>
    <content type="text"><![CDATA[概念数据：描述事物的符号记录数据库：数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。数据库管理系统：是数据库的机构，是一种系统软件，负责数据库中的数据组织、数据操纵、数据维护、控制及保护和数据服务等。数据定义语言(Data Definition Language, DDL)：数据的模式定义和数据的物理存取构建。数据操纵语言(Data Manipulation Language, DML)：负责数据的操纵，包括查询及增、删、改等操作。数据控制语言(Data Control Language, DCL)：负责数据的完整性、安全性的定义与检查以及并发控制、故障恢复等功能。结构化查询语言(Structured Query Language)：SQL是高级非过程性编程语言数据库管理员：对数据库的规划、设计、维护、监视。数据库系统：由数据库（数据）、数据库管理系统（软件）、数据库管理员（人员）、硬件平台、软件平台组成。数据库应用系统：是数据库系统再加上应用软件及应用界面。 数据库系统的基本特点 数据的集成性 数据的高共享性与低冗余性 数据的独立性 数据的统一管理与控制 数据库系统的内部结构体系数据模式是数据库系统中数据结构的一种表现形式。三级模式：概念级模式、内部级模式、外部级模式二级映射：概念级到内部级的映射、外部级到概念级的映射 数据模型数据模型是数据特征的抽象，从抽象层次上描述了系统的静态特征、动态行为和约束条件，为数据库系统的信息表示与操作提供了一个抽象的框架。数据模型描述的内容有三部分，他们是数据结构、数据操作与数据约束。数据模式按不同的应用层次分为三种类型，它们是概念数据模型、逻辑数据模型(层次模型、网状模型、关系模型、面向对象模型)、物理数据模型。 E-R模型：实体、属性、联系层次模型：树形结构网状模型：不加任何条件限制的无向图关系模型：采用二维表来表示，满足一定条件的二维表称为关系；二维表中凡能唯一标识元祖的最小属性集称为该表的键或码。 关系代数 插入 删除 修改 查询：投影运算、选择运算、笛卡尔积运算 交运算 除运算 连接与自然连接 数据库设计与管理数据库设计：基本任务是根据用户对象的信息需求、处理需求和数据库支持环境设计出数据模式。四个阶段：需求分析、概念设计、逻辑设计、物理设计。需求分析：结构化分析方法(自顶向下、逐层分解)数据字典：是各类数据描述的集合，包括：数据项、数据结构、数据流、数据储存、处理过程概念设计：目的是分析数据间内在语义关联，在此基础上建议一个数据的抽象模型；方法：集中式模型设计法、视图集成设计法；过程：选择局部应用、视图设计(自顶向下、由底向上、由内向外)、视图集成]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL笔记]]></title>
    <url>%2F2019%2F03%2F14%2Fnote-mysql%2F</url>
    <content type="text"><![CDATA[: colon; semicolon MySQLSQL(Structured Query Language) Features Open source(开源) Scalable(可伸缩) Portable(可移植) Works with client/server and embedded architecture(使用客户端/服务端嵌入式架构) High performance(高性能) Low TCO(低成本) Reliable(可靠) Easy to use(易于使用) Secure(安全) High availability(高可用性) 最小屏幕分辨率$1280\times 1024$, 推荐$1920\times 1200$及以上 Database Query LanguageDDLIt is used to define and modify the structure the database objects, such as tables, views, and indexs.数据定义语言(Data Definition Language, DDL)：数据的模式定义和数据的物理存取构建。 CREATE ALTER RENAME DROP TRUNCATE DMLIs used to manipulate the data in database objects.数据操纵语言(Data Manipulation Language, DML)：负责数据的操纵，包括查询及增、删、改等操作。 INSERT UPDATE DELETE SELECT DCLIs used to control the access to the objects in the database.数据控制语言(Data Control Language, DCL)：负责数据的完整性、安全性的定义与检查以及并发控制、故障恢复等功能。 GRANT(to assign access permissions to the users on the database objects.) REVOKE(to deny permissions) Layered architectureApplication layerAdministrative interface and utilitiesClient interfaces and utilitiesQuery interface and utilities Logical layerQuery processor subsystemTransaction management subsystemRecovery management subsystemStorge management subsystem 储存引擎(Storage engines) InnoDB(default) MyISAM(supports full-text search indexs.) Memory(Nontransaction-safe storage engine, supports temporary tables types and stores tables in memory rather than in secondary storage devices.) Physical layerMySql登录123456mysql -P 端口号 -h mysql主机名\ip -u root(用户名) -p password dbnamemysql -P 3306 -h localhost -u root -p sakila(DatabaseName)or mysql --port=port_num --host=hostname --user username --password=password dbname 最简单1mysql -u root -p MySQL commands123456789101112Help or \h or ?Eg. Help showClear or \cEg. ClearConnect or \rEg. Connect sakila Quit or \qEg. QuitStatus or \sEg. StatusDelimiter or \dEg. Delimiter &amp; 数据库Database ObjectsTableA table contains data int rows and columns. It provides a structured organization of data. It offers a provision for maintaining data integrity by allowing users to:Store only the data that satisfies certain pre-defined conditions.Perform only those operations on the data that do not violate the conditions. IndexAn index is an internal table structure that MySQL uses to provide quick access to the rows of a table, based on the values of one or more columns. An index is similar to the index of a book. ViewA view is a virtual table that provides access to a subset of columns from one or more related tables. Stored procedureA stored procedure is a named block of SQL and procedural statements that are stored in the server and executed as a single unit. FunctionA function is a named block of SQL and procedural statements that are stored under one name and return a value. TriggerA trigger is a named object associated with a table, and comprises a block of SQL statements. A trigger is invoked automatically whenever an event on the assoociated table occurs. Types of DatabasesUser-defined DatabasesSystem Databases information_schema mysql performance_schema 建立数据库123CREATE DATABASE [IF NOT EXISTS] &lt;database_name&gt;[[DEFAULT] CHARACTER SET &lt;character_set_name&gt;][[DEFAULT] COLLATE &lt;collation_name&gt;] The default character in MySQL is latin1.big5 supports the Chinese language. 使用数据库12USE &lt;database_name&gt;SHOW DATABASES; 修改数据库123ALTER DATABASE &lt;database_name&gt;[[DEFAULT] CHARACTER SET &lt;character_set_name&gt;][[DEFAULT] COLLATE &lt;collation_name&gt;] 查询使用的character set1SHOW CHARACTER SET; 删除数据库1DROP DATABASE database_name; MySQL does not allow deleting system databases. 数据类型NumericStringDate Integer Data Types Data type Range for signed integers Range for unsigned integers Storage(Bytes) TINYINT -128 to 127 0 to 255 1 SMALLINT -32,768 to 32,767 0 to 65535 2 MEDIUMINT -83,88,608 to 83,88,607 0 to 16777215 3 INT / INTEGER -2,147,483,648 to 2,147,483,647 0 to 4294967295 4 BIGINT -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 0 to 18446744073709551615 8 Fractional Data Types Data type Range Used to store Storage(Bytes) FLOAT -3.402823466E+38 to -1.175494351E-38, 0 and 1.175494351E-38 to 3.402823466E+38 Fractional value with floating single-precision 4 DOUBLE(p,s) PRECISION(p,s) REAL(p,s) -1.7976931348623157E+308 to -2.2250738585072014E-308, 0 and 2.2250738585072014E-308 to 1.7976931348623157E+308 Fractional value with floating double- precision and scale 8 DECIMAL(p,s) DEC(p,s) NUMERIC(p,s) FIXED(p,s) Depends on values specified in the column definition Fractional value with fixed precision and scale NA Bit Data TypeBIT(M) 表示方法b’1001’ String Data type Range Used to store CHAR(n) n characters, 1 &lt;= n &lt;= 255 Fixed length VARCHAR(n) n characters, 1 &lt;=n &lt;= 255 Variable length TINYTEXT 1 to 255 characters Variable length TEXT 1 to 65,535 characters Variable length MEDIUMTEXT 1 to 16,777,215 characters Variable length LONGTEXT 1 to 4,294,967,295 characters Variable length BINARY(n) n bytes, 1&lt;= n &lt;= 255 Fixed length VARBINARY(N) n bytes, 1&lt;=n &lt;= 255 Variable length TINYBLOB 255 characters(355 bytes) Variable length BLOB 1 to 65,535 characters(64KB) Variable length MEDIUMBLOB 1 to 16,777,215 characters(16MB) Variable length LONGBLOB 1 to 4,294,967,295 characters(4GB) Variable length BLOB 类型可以储存图片 Date Data type Range Used to store DATE 1000-01-01 through 9999-12-31 Date data DATETIME 1000-01-01 00:00:00 through 9999-12-31 23:59:59 Date and time data TIMESTAMP 1970-01-01 00:00:00 2037-12-31 Date and time value that is updated with the current date and time value of system, whenever a record is updated or inserted into the table YEAR 1901 to 2155 Year data TIME -838:59:59 to 838:59:59 Time data ENUM用一个数字index表示数据 eg. 123456create table if not exists tb(id int primary key not null,status enum('Married', 'Unmarried', 'Divorced', 'Widow', 'Widower'));insert into tb values(1, 1), (2, 2), (3,4); Set跟ENUM差不多，但是是个集合，取值为子集而不是用index Eg. 12345678create table if not exists tb (id int not null,S set('A', 'B', 'C', 'D'));insert into tb value(1, ('A,B,C'));select * from tb; 表格创建表格123456CREATE [TEMPORARY] TABLE [IF NOT EXISTS] &lt;table_name&gt;(&lt;column_definition&gt; [&#123;, &lt;column_definition&gt;&#125;...])[ENGINE = &#123; MEMORY | INNODB | MERGE | MRG_MYISAM | MYISAM&#125;]&lt;column_definition&gt;=&lt;column_name&gt; &lt;data_type&gt; [NOT NULL | NULL] [DEFAULT &lt;value&gt;][AUTO_INCREMENT] 查看表格属性12DESCRIBE table_name [column_name | `value`]DESC Products 'P%' 查看是数据库中表格1SHOW TABLES 添加约束在创建表格时123[CONSTRAINT constraint_name] PRIMARY KEY(&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])[CONSTRAINT constraint_name] UNIQUE (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])[CONSTRAINT constraint_name] FOREIGN KEY (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...]) REFERENCES master_table_name(&lt;column_name&gt; [&#123;,&lt;column_name&gt;&#125;...]) 修改表格12345678ALTER TABLE &lt;table_name&gt;&#123;ADD [COLUMN] &lt;column_definition&gt; [FIRST|AFTER &lt;column_name&gt;]&#125; |&#123;ADD [CONSTRAINT] &lt;constraint_name&gt; &lt;constraint_clause&gt; &#125; |&#123;ALTER [COLUMN] &lt;column_name&gt; &#123;SET DEFAULT &lt;values&gt; | DROP DEFAULT&#125;&#125; |&#123;MODIFY [COLUMN] &lt;column_definition&gt; [FIRST|AFTER &lt;column_name&gt;]&#125; |&#123;DROP [COLUMN] &lt;column_name&gt; &#125; |&#123;DROP PRIMARY KEY | FOREIGN KEY constraint_name | UNIQUE constraint_name&#125; |&#123;RENAME [TO] &lt;new_table_name&gt;&#125; Manipulating Table DataInserting DataINSERT Statement123456INSERT [LOW_PRIORITY | DELAYED] [IGNORE] [INTO] &lt;table_name&gt; &#123;&lt;values_option&gt; | &lt;set_option&gt;&#125;;&lt;values_option&gt;=SET &lt;column_name&gt;=&#123;&lt;value_list&gt; | DEFAULT&#125;[&#123;, &lt;column_name&gt;=&#123;value_list&gt; | DEFAULT&#125;&#125;...] REPLACE Statement1REPLACE [LOW_PRIORITY | DELAYED] [IGNORE] [INTO] &#123;&lt;values_option&gt; | &lt;set_option&gt;&#125;; Updating Data12UPDATE [LOW_PRIORITY | DELAYED] [IGNORE] [INTO] &lt;table_name&gt; SET &lt;column_name&gt;=&lt;expression&gt; [&#123;, &lt;column_name&gt;=&lt;expression&gt;&#125; ...] [WHERE &lt;condition&gt;]; Copying DataSELECT statement1SELECT *|&lt;column_name&gt; [&#123;,&lt;column_name&gt;&#125;...] FROM &lt;table_name&gt;; Copying data to an existing table12345INSERT INTO &lt;table_name&gt;SELECT *|&lt;column_name&gt; [&#123;,&lt;column_name&gt;&#125;...] FROM &lt;table_name&gt;;orREPLACE INTO &lt;table_name&gt;SELECT *|&lt;column_name&gt; [&#123;,&lt;column_name&gt;&#125;...] FROM &lt;table_name&gt;; Copying data to a new table123CREATE TABLE &lt;table_name&gt; (&lt;column_definition&gt;[&#123;, &lt;column_definition&gt;&#125;...]) SELECT *|&lt;column_name&gt; [&#123;,&lt;column_name&gt;&#125;...] FROM &lt;table_name&gt;; Deleting DataDELETE statement1DELETE [LOW_PRIORITY] [IGNORE] FROM &lt;table_name&gt; [WHERE &lt;condition&gt;]; TRUNCATE statement删除所有记录，相当于把表删除重建1TRUNCATE [TALBE] &lt;table_name&gt;; Removing a Table1DROP [TEMPORARY] TALBE [IF EXISTS] [database_name].&lt;table_name&gt;[&#123;,&lt;table_name&gt;&#125;...] 插入图片long blob类型 1insert into commoditytable values('qiezibao', load_file('F:\\Code\\mysql\\a.jpg')); Retrieving Data 检索数据Retrieving Specific AttributesSELECT statement12SELECT [ALL|DISTINCT] select_expr[as new_name] [, select_expr...] [FROM table_reference] [WHERE where_condition] 逻辑运算符123OR(||)AND(&amp;&amp;)NOT(!) 比较运算符123456789&gt;&lt;=&gt;=&lt;=&lt;&gt;, !=BETWEENLIKE 类似于正则匹配(% is used to match any number of characters, _ is used to match a single characters) Eg. LIKE '_F%'IN 在一个集合中 Eg. IN ('001', '002') 算术运算符123456DIV (整除)/ (除法)-%, MOD+* 用LIMIT约束12LIMIT [offset, ] row_countoffset 跳过计数的行数 用函数Customize查询结果String Functions1234567891011121314151617181920212223242526ASCIISELECT ASCII('ABC'); return 65LEFTSELECT LEFT('DAVID', 4); return 'DAVI'REVERSESELECT REVERSE('ABC'); return 'CBA'RIGHTSELECT RIGHT('LAWSON', 4); return 'WSON'SUBSTRINGSELECT SUBSTRING('Whether', 2, 2); return 'he'UPPERSELECT UPPER('lawson'); return 'LAWSON'LOWERSELECT LOWRT('RICHARD'); return 'richard'CONCATSELECT CONCAT('Mary', ' ', 'Smith'); return 'Mary Smith'REGEXPSELECT 'John Peter' REGEXP 'peter' 1234567891011. matches a single characterp* matches zero or any number of occurrences of the p characterp+ matches one or any number of occurrences of the p characterp? matches zero or one occurrence of the p character^p matches the string(s) that begins with a p characterp$ matches the string(s) that ends with a p characterpqr|abc matches the string(s) having either the sequence of pqr or abc[pqrs] matches a single character from the characters contained in '[' and ']'[^pqrs] matches a single character that is not contained in '[' and ']'[p-s] matches any character from p to s[^p-s] matches any character except the characters from p to s Date Functions1234567891011121314151617ADDDATESELECT ADDDATE('2008-8-24 15:25:52', INTERVAL '8:20' HOUR_MINUTE); return '2008-08-24 23:45:52'DATESELECT DATE('2008-8-24 15:25:52'); return '2008-08-24'MONTHSELECT MONTH('2008-8-24 15:25:52'); return 8MONTHNAMESELECT MONTHNAME('2008-8-24 15:25:52'); return 'August'YEARSELECT YEAR('2008-8-24 15:25:52'); return 2008DATEDIFFSELECT DATEDIFF('2008-8-24 15:25:52', '2008-9-4 18:20:00'); return -11TIMEDIFFDAYEXTRACTDATE_FORMAT expr12345678910111213141516HOUR 小时MINUTE 分SECOND 秒MICROSECOND 毫秒YEAR 年MONTH 月DAY 日WEEK 周QUARTER 季YEAR_MONTH 年和月DAY_HOUR 日和小时DAY_MINUTE 日和分钟DAY_ SECOND 日和秒HOUR_MINUTE 小时和分HOUR_SECOND 小时和秒MINUTE_SECOND 分钟和秒 123456789%a name of weekday in an abbreviate%b name of month in an abbreviate%c month in numeric form%H hour in numeric form%i minutes in numeric form%j day of year in numeric form%M name of month%p time in am or pm%S second Mathematical Functions123456FLOORCOT return cotangent of the specified angle in radiansPIPOWROUND (numeric_expression, length) SELECT ROUND(12.789, 2); return 12.79SQRT Information Functions12345current_user()connection_id()database()version()charset() return character set of the string argument Cast Functions123BINARY() # 大小写敏感CAST() # CAST(expr AS type)CONVERT() # CONVERT(expr, type) Aggregate Functions12345avgsumminmaxcount Sorting and Grouping DataSorting Data1234567SELECT [ALL | DISTINCT] select_expr [, select_expr ...] [FROM table_reference] [WHERE where_condition] [ORDER BY column_name] [ASC | DESC] Grouping Data1234567SELECT [ALL | DISTINCT] select_expr [, select_expr ...] [FROM table_reference] [WHERE where_condition] [GROUP BY &#123;column_name | expr&#125;] [HAVING where_condition] Join和SubqueriesJoin一张图片搞定 Inner Join12345SELECT column_name, column_name, [, column_name]FROM table1_name JOIN table2_nameON table1_name.ref_column_name join_operator table2_name.ref_column_name | USING (ref_column_name)[WHERE search_condition] ON 和 USING 二选一，USING可以合并相同的列 Outer JoinLEFT OUTER JOINRIGHT OUTER JOIN12345SELECT column_name, column_name, [, column_name]FROM table1_name [LEFT | RIGHT] OUTER JOIN table2_nameON table1_name.ref_column_name join_operator table2_name.ref_column_name | USING (ref_column_name)[WHERE search_condition] Natural Join根据公共列连接两个表A natural join clubs columns from one table with the columns of another table on the basis of a common column12SELECT column_name, column_name, [, column_name]FROM &lt;table_reference&gt; NATURAL [&#123;LEFT| RIGHT&#125; [OUTER]] JOIN &lt;table_reference&gt; Cross JoinA cross join is used to join each row of one table with each row of another table.就是乘法12SELECT column_name, column_name, [, column_name]FROM &lt;table_reference&gt; CROSS JOIN &lt;table_reference&gt; Self JoinCompare the value of one column with that of another in the same tableIn a self join a table is joined to itself. As a result, one row in a table correlates with other rows in the same table.123SELECT column_name(s)FROM table1 T1, table1 T2WHERE condition; SubqueriesIN1234SELECT column, column [, column]FROM table_nameWHERE column IN | NOT IN ( SELECT column FROM table_name [ WHERE where_condition] ) EXISTS1234SELECT column, column [, column]FROM table_nameWHERE column EXISTS | NOT EXISTS ( SELECT * FROM table_name [ WHERE where_condition] ) 1、exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；2、in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。3、如果用not in ，则是内外表都全表扫描，无索引，效率低，可考虑使用not exists，也可使用A left join B on A.id=B.id where B.id is null 进行优化。 Using Modified Comparison Operators1234SELECT column, column [, column]FROM table_nameWHERE column &gt; | &lt; | = ALL | ANY ( SELECT column FROM table_name [ WHERE where_condition] ) The ALL keyword returns a TRUE value if the comparison performed is true for all the values that are retrieved by the subquery. It return FALSE if only some of the values satisfy the comparison operator or if the subquery does not return any rows to the outer statementThe ANY keyword returns a TRUE value if any value retrieved by the subquery satisfies the comparison operator. It returns a FALSE value if no values in the subquery satisifies the comparison operator or if the subquery does not return any row that matches the outer statement. Using Nested SubqueriesYou may need to use one or more subqueries within another subquery, known as a nested subquery. In the nested subquery, the condition specified in a subquery depends on the result of another subquery, which, in turns depends on the result of some another subquery. Using Correlated Subquery相关子查询 1.扫描外查询的第一条记录2.扫描子查询，并将第一条记录的对应值传给子查询，由此计算出子查询的结果3.根据子查询的结果，返回外查询的结果。4.重复上述动作，开始扫描外查询的第二条记录，第三条记录，直至全部扫描完毕 You may want to use an inner query that depends on the outer query for its execution.In a normal nested subquery, the inner query executes only once. The main query is executed by using the value returned by the inner query.On the other hand, in a correlated subquery, the inner query is driven by the outer query. In this case, the inner query executes once for each row seleted by the outer query. Implementing Indexes and ViewsCreating and Managing IndexesIdentifying the Types of IndexesMySQL allows you to create indexes on the tables to speed up data access. Indexes should be created on the columns that are most frequently included in the conditions, such as the columns included in the WHERE or HAVING clauses of SELECT statements. Therefore, you can create appropriate indexes on the required columns to improve the response time of the MySQL server. MySQL supports the following types of indexes: Primary key Foreign key Unique Regular Full-text Full-text index is defined on the column(s) that can accept string values. The purpose of this index is to improve the speed of the searches made on the string values included in the column data. The data type of the column(s) on which the full-text index can be defined can be CHAR, VARCHAR, or TEXT. Moreover, these column(s) can accept deplicate or NULL values.The full-text indexes can be defined only on the tables that are accessed by using the MyISAM storage engine. Creating Indexes12345678910111213CREATE TABLE &lt;table_name&gt; (...&#123;INDEX | KEY&#125; [&lt;index_name&gt;] (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])FULLTEXT &#123;INDEX | KEY&#125; [&lt;index_name&gt;] (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...]))ALTER TALBE &lt;table_name&gt;ADD &#123;INDEX | KEY&#125; [&lt;index_name&gt;] (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])CREAR UNIQUE INDEX &lt;index_name&gt; ON &lt;table_name&gt; (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])CREAR INDEX &lt;index_name&gt; ON &lt;table_name&gt; (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...])CREAR FULLTEXT INDEX &lt;index_name&gt; ON &lt;table_name&gt; (&lt;column_name&gt; [&#123;, &lt;column_name&gt;&#125;...]) Viewing Indexes1SHOW INDEXES FROM table_name [FROM database_name] Removing Indexes123456ALTER TABLE &lt;table_name&gt;DROP INDEX &lt;index_name&gt;or DROP INDEX &lt;index_name&gt; ON &lt;table_name&gt; Creating and Managing ViewsA view is a database object that stores a query raised on one or more tables or other views. The query that contains joins, calculated columns, and subqueries is generally complex.Views help in simplifying the execution of complex queries. Creating ViewsA view is a virtual table that provides access to subset of columns or records from one or more tables or views. In addition to the columns of tables or other views, a view definition can also contain calculated columns using aggregate functions. View is a query strored as an object in the database and does not have its own data. A view can derived are known as the base tables or underlying tables. A database developer can create views to ensure the security of data by restricting access to Specific records of a table. Specific columns of a table. Specific records and columns of a table. Records fetches by using joins. Subsets of other views or a subset of views and tables.In addition to restricting access, views can also be used to create and save queries based on multiple tables.123CREATE [OR REPLACE]VIEW view_name [(&lt;column_name&gt; [, &lt;column_name&gt;]...)]AS &lt;select_statment&gt; Querying Views1SELECT &lt;select_statment&gt; FROM &lt;view_name&gt; [WHERE &lt;where_condition&gt;] View 可以包含 WHERE, ORDER BY, GROUP BY Restrictions on ViewsSome of these restriction are A view cannot be created on a temporary table. A temporary view cannot be created. A trigger cannot be created on a view. An index cannot be created on a view. The underlying table(s) or view(s) of view must already exist. The SELECT statement in a view definition cannot contain subqueries in the FROM clause. Updatable ViewsThe views are said to be non-updatable if the following constructs are contained in their defubutuib: An aggregate function in the column list. The DISTINCT, GROUP BY, HAVING clause in the SELECT statement. A subquery in the SELECT statement. A nonupdatable view in the FROM clause. Insert operations can be performed only on the views that contain all the NOT NULL columns from the underlying table(s) and do not contain any calculated column in the column list. Update operation cannot bt performed on a view when It modifies the values of the derived columns. It results in modification of multiple tables. MySQL allows you to perform the dalate operations only on those views that contain columns from a single table. Managing Views123456ALTER [ALFORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]VIEW view_name [(column_list)]AS &lt;select_statment&gt;[WITH CHECK OPTION]DROP VIEW [IF EXISTS] view_name [, view_name] Implementing Compound Statements and Stored Routines实现复合语句和储存过程 Creating a Compound Statement复合语句123[begin_label:] BEGIN [statement_list]END [end_label] 变量declare1DECLARE var_name [, var_name] type [default values] set1SET variable_assignment [, variable_assignment] 声明与初始化1234567# Local Variable 局部变量声明必须在begin end之间DECLARE var int;SET var=15;# Gloabal Variable 全局变量可以直接声明declare @var int;set @var=15, @age=19; 函数123456789delimiter //create function f(t int) returns intbegin declare age int; set age=t; return t;end//delimiter ; 好像函数必须要有返回值… 流程控制语句IF-THEN-ELSE123456789101112IF condition THENstatements;[ELSE IF condition THENstatements;][ELSEstatements;]END IF; IF a&gt;b THEN SET s=CONCAT(a, '&gt;', b);ELSEIF a=b THEN SET s=CONCAT(a, '=', b);else set s=CONCAT(a, '&lt;', b);END IF; 如果是elseif只需要一个end if; 如果是else if则需要两个 CASE12345678CASE expressionWHEN value1 THENstatements;[WHEN value2 THENstatements;][ELSEstatements;]END CASE; WHILE123[loopname:] WHILE condition DOstatements;END WHILE [loopname]; LOOP123[begin_label:] LOOP statement_listEND LOOP [end_label] LEAVE lable 可以跳出LOOP, REPEAT, WHILE ITERATE statement相当于continue1ITERATE lable REPEAT statement1234[begin_label:] REPEAT statement_listUNTIL conditionEND REPEAT [end_label] Handling Exceptions12345678910DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statementhandler_action: CONTINUE | EXIT | UNDOcondition_value: mysql_error_code | SQLSTATE [VALUE] sqlstate_value | SQLWARNING | NOT FOUND | SQLEXCEPTION 异常数值文档https://dev.mysql.com/doc/refman/5.6/en/server-error-reference.html 返回异常1234SIGNAL SQLSTATE [VALUE] sqlstate_value[SET MESSAGE_TEXT=string_or_variable]use '45000', which means “unhandled user-defined exception.” Using Cursors游标In MySQL cursors can be used inside stored procedures, triggers, and functions. Folloewing steps: Declare a cursor 声明 Open the cursor 打开 Fetch the cursor 获取 Close the curson 关闭 1234DECLARE cursor_name CURSOR FOR select_statmentOPEN cursor_nameFETCH cursor_name INTO var_name [, var_name] ...;CLOSE cursor_name Implementing Stored RoutinesProcedures1234CREATE PROCEDURE proc_name ([[IN|OUT|INOUT]pro_parameter [, ...]]) [characteristic ...] routine_bodyCALL proc_name([parameter[,...]]) IN参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值OUT:该值可在存储过程内部被改变，并可返回INOUT:调用时指定，并且可被改变和返回 Function1234CREATE FUNCTION func_name ([func_parameter[,..]]) RETURNS type [characteristic ..] routine_bodySELECT func_name(); Implementing Triggers and TransactionsTriggersA triggers can be considered as small program that is pre-compiled and stored in the database. It is automatically executed when a DML statement, such as UPDATE, DELETE, or INSERT is performed on the corresponding table.123456789CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] TRIGGER &lt;trigger_name&gt; &lt;trigger_time&gt; &lt;trigger_event&gt; ON &lt;table_name&gt; FOR EACH ROW &lt;trigger_body&gt;trigger_time: AFER | BEFOREtrigger_event: INSERT | UPDATE | DELETE Restrictions on Triggers Any foreign key action does not activate triggers. The CALL statement is not permitted inside the trigger body. A TEMPORARY table or a view cannot be associated with a trigger. The RETURN statement is not permitted in trigger. The mysql database does not permit any trigger creation on its tables. Statement related to transactions such as COMMIT, ROLLBACK, and START TRANSACTION cannot be executed inside a trigger. The trigger cache does not update itself dynamically if any changes are made to the structure of a database object after the information about its structure has been loaded in the cache. 用NEW | OLD来区分， DELETE 里只有 OLD. 1DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name TransactionsA transaction stands for a series of data manipulation statments encapsulated as a single logical unit of work. This single locical unit of work is executed in a specific sequence and its completion depends on the successful execution of each individual statement within it. If an individual statement fails, the entire logical unit of work will fail.In an RDBMS, whenever an operation is performed, it can be treaded as a reansaction if it has ACID properties. These properties of a transaction can be explained as: Atomicity: This means that either all the data-rekated operations in a transaction atr performed or none of them is performed. Consistency: This means that all the data is in a consistent state after a transaction is completed successfully. Isolation: This delermines whether or not any changes in data by an operation atr made visible to a concurrent transaction. Durability: This states that any change in data by a completed transaction remains permanently in effect in the system. 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 123456789101112SET AUTOCOMMIT=0 禁止自动提交SET AUTOCOMMIT=1 开启自动提交SET sql_safe_updates=0START TRANSACTION 显式地开启一个事务；COMMIT 提交事务，并使已对数据库进行的所有修改成为永久性的；ROLLBACK 回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；ROLLBACK TO SAVAPOINT identifier 把事务回滚到标记点；SET TRANSACTION 用来设置事务的隔离级别SHOW VARIABLES LIKE 'tx_isolation' 查看当前数据库的事务隔离级别 事务的并发问题1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 MySQL事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交(READ UNCOMMITTED) 是 是 是 不可重复读(READ COMMITED) 否 是 是 可重复读(REPEATABLE READ) 否 否 是 串行化(SERIALIZABLE) 否 否 否 Mysql 支持4种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READa).read uncommitted(读未提交数据)：允许事务读取未被其他事物提交的变更。脏读、不可重复读和幻读的问题都会出现b).read commited(读已提交数据)：只允许事务读取已经被其他事务提交的变更。可避免脏读，但不可重复读和幻读问题仍然存在c).repeatable read(可重复读)：确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可避免脏读和不可重复读，但幻读的问题仍然存在d).serializable(串行化)：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行增删改操作。所有的并发问题都可以避免，但性能什么低下。 READ UNCOMMITTEDThe READ-UNCOMMITTED isolation level specifies that the transactions are able to see the data changes made by other transactions that atr not yet committed. READ COMMITEDThe READ-COMMITTED isolation level specifies that the data changes are visible to other transactions only when thay are committed. REPEATABLE READThe REPEATABLE-READ isolation level specifies that every read in the transaction will return the same set of data. SERIALIZABLEThe SERIALIZABLE isolation level specifies that transactions place locks on all accessed records and the resource so that records cannot be added, updated, or deleted fron the table used in the transaction. 123SET [GOLBAL | SESSION] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED | READ COMMITED | REPEATABLE READ | SERIALIZABLE&#125; LockMyISAM1234567LOCK &#123;TABLE | TABLES&#125;&lt;table_name&gt; [AS &lt;alias&gt;] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125; [&#123;, &lt;table_name&gt; [AS &lt;alias&gt;] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125; &#125;...]UNLOCK &#123;TABLE | TABLES&#125;SHOW OPEN TABLES; 导出和导入数据导出数据123456789select * from &lt;tablename&gt; into OUTFILE `&lt;filename&gt;` [&lt;export_option&gt;]&lt;export_option&gt;::=&#123; FIELDS[TERMINATED BY `&lt;value&gt;`] # 列结束[[OPTIONALLY] ENCLOSED BY `&lt;value&gt;`] # 开始和结束[ESCAPED BY `&lt;value&gt;`] &#125; | &#123; LINES[STARTING BY `&lt;value&gt;`] # 行起始TERMINATED BY `&lt;value&gt;`] &#125; # 行结束 貌似高版本无法导出文件，需要在MySQL安装路径里找my.ini，然后在[mysqld]后面加上一句，就能导出了 123456[mysqld]# The TCP/IP Port the MySQL Server will listen onport=3306secure_file_priv = &apos;&apos; 导出csv 1234select * from customertableinto outfile 'F:\\Code\\mysql\\a.csv'fields terminated by ',' optionally enclosed by '"'lines terminated by '\r\n'; 导出图片 12select [select options] into dumpfile `&lt;filename&gt;`;select img from commoditytable where id='qiezibao' into dumpfile 'F:\\Code\\mysql\\a.jpg'; 导入数据12345678910LOAD DATA INFILE `&lt;filename&gt;` into table &lt;tablename&gt; [&lt;import_option&gt;] [IGNORE &lt;number&gt; LINES] [(&lt;column name&gt;[&#123;, &lt;column name&gt;&#125;...])]&lt;import_option&gt;::=&#123; FIELDS | COLUMNS[TERMINATED BY `&lt;value&gt;`] # 列结束[[OPTIONALLY] ENCLOSED BY `&lt;value&gt;`] # 开始和结束[ESCAPED BY `&lt;value&gt;`] &#125; | &#123; LINES[STARTING BY `&lt;value&gt;`] # 行起始TERMINATED BY `&lt;value&gt;`] &#125; # 行结束 导入csv 123load data infile 'F:\\Code\\mysql\\a.csv' into table customertablefields terminated by ',' optionally enclosed by '"'lines terminated by '\r\n'; Administering MySQL Databases用户管理创建用户用sql语句有两种方法一种create new user12create user 'joe' identified by 'password_joe';create user 'joe'@'localhost' identified by 'password_joe'; 一种insert into mysql.user1insert into mysql.user values('%', 'beiyu', PASSWORD('beiyu'), 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', '', '', '', '', 0, 0, 0, 0, '', ''); 用flush privileges;刷新权限 hosts: localost = % 修改用户名1rename user &lt;old_user_name&gt; to &lt;new_user_name&gt;; 修改用户密码两种方式，set password 和 update 1234set password=password('1234'); # 修改当前账户密码set password for &lt;account_name&gt; = &#123; password('password_1234') | 'encrypted_password'&#125; 1update mysql.user set password=password('1234') where user 'beiyu'; 删除用户两种方式，drop user 和 delete12drop user account_name;delete from user where user='beiyu'; 用户权限管理给予权限1234grant &lt;privilege_type&gt; [(&lt;col_name&gt; [, &lt;col_name&gt;...])] [, &lt;privilege_type&gt; [(&lt;col_name&gt; [, &lt;col_name&gt;...])] ...] on privilege_level to account_name [identified by [password] 'password'] [, account_name [identified by [password] 'password']...] privilege_type: all alter create create routine create user create view delete drop select update privilege_level: *.* * database_name.* table_name 查看权限1SHOW GRANT FOR account_name 撤销权限12345REVOKE &lt;privilege_type&gt; [(&lt;column_name&gt;) [, &lt;column_name&gt;...]][,&#123;&lt;privilege_type&gt; [(&lt;column_name&gt;) [, &lt;column_name&gt;...]]&#125;...]ON privilege_levelFROM account_name [IDENTIFED BY [PASSWORD] `&lt;password&gt;`][,account_name [IDENTIFED BY [PASSWORD] `&lt;password&gt;`] ...] 备份Back up123456mysqld --log-bin [=&lt;base_name&gt;]mysqldump [--flush-logs] -u &lt;user_name&gt; -p &lt;database_name&gt;mysqldump [--flush-logs] -u &lt;user_name&gt; -p &lt;database_name&gt; &gt; &lt;path_and_filename&gt;mysqldump [--flush-logs] -u &lt;user_name&gt; -p &lt;database_name&gt; [&lt;table_name&gt;, [&lt;table_name&gt;]...] &gt; &lt;path_and_filename&gt;mysqldump [--flush-logs] -u &lt;user_name&gt; -p --database &lt;database_name&gt; [&lt;database_name&gt;...] &gt; &lt;path_and_filename&gt;mysqldump --all-databases &gt; &lt;path_and_filename&gt; Recover1mysql -u &lt;user_name&gt; -p [&lt;database_name&gt;] &lt; &lt;path_and_filename&gt; Updating the Reloaded Databases Using Binary Logs1mysqlbinlog &quot;&lt;Path&gt;\&lt;binary_log_file&gt;&quot; | mysql -u &lt;user_name&gt; -p Using Text File with Exported Binary Log Data```mysqlbinlog “\“ &gt; “\“ 参考 https://www.techonthenet.com/mysql/index.php https://www.w3schools.com/sql/default.asp]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2019%2F03%2F14%2Fnote-java%2F</url>
    <content type="text"><![CDATA[阿伟整理不完了…要考试了 Javajava companySun Microsystem, Inc. java文件每个java文件只能有一个public类，文件名与public类名相同。 编译与运行12javac helloworld.javajava hellojava 打包编译1javac -d 目标路径 文件路径 设置环境变量/set path=/path= 数据类型 Java数据类型 Group DataType Size Range DefaultValue Integer byte 1 byte $-2^7~2^7-1$ 0 short 2 bytes $-2^15~2^15-1$ 0 int 4 bytes $-2^31~2^31-1$ 0 long 8 bytes $-2^63~2^63-1$ 0 floating point float 4 bytes 3.4^{e-038}~3.4^{e+038} 0.0 double 8 bytes 1.7^{e-308}~1.7^{e+308} 0.0 字符型char字符串String是一个类 布尔型boolean 运算符基本跟c一样特殊的无符号右移&gt;&gt;&gt;判断类型是否相等instanceof 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）public : 对所有类可见。使用对象：类、接口、变量、方法protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。final 修饰符final 变量：final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。final 修饰符通常和 static 修饰符一起使用来创建类常量。 输入输出Scanner1234567import java.util.Scanner;Scanner sn = new Scanner(System.in);int a = sn.nextInt();String b = sn.next();String c = sn.nextLine();char d = sn.next().charAt(0);double f = sn.nextDouble(); System.out123System.out.println(); // 输出并换行System.out.print(); // 输出不换行System.out.printf(); // 格式化输出 数组1234arraytype arrayname[] = new arraytype[size];arraytype[] arrayname = new arraytype[size];arraytype arrayname[][] = new arraytype[sizex][sizey]; String/StringBuffer/StringBuilder12String a = "Hello" String a = new String("Hello"); 123456789101112131415161718charAt(0); // 返回第一个字符length(); // 长度getChar(int srcBegin, int srcEnd, char[] dst, int dstBegin); // 将src开始到结束左闭右开区间的字符串copy到dstBegin开始的字符串中equals(); // 判断是否相等，最好用字符常量与变量判断，防止空字符串。compareTo(); // 字符串比较startsWith(); // 是否以指定字符串为开头endsWith(); // 是否以指定字符串为结尾indexOf(); // 返回第一次字符出现的位置，若不存在返回-1lastIndexOf(); // 返回最后一次字符出现的位置，若不存在返回-1subString(int beginindex); // 返回从index开始的，到字符串末尾的子串。concat(String str); // 连接字符串replace(char oldChar, char newChar); // 字符替换，将oldChar替换成newChartoUpperCase(); // 大写toLowerCase(); // 小写trim(); // 去掉两段的空格toCharArray(); // 转换成char数组返回valueOf(); // 转换成字符串equalsIgnoreCase(); // 大小写不敏感比较字符串 StringBuffer 和 StringBuilder不建立新的字符串对象，但可以使用append(), delete(), insert(), reverse() 函数 类继承和多态InheritanceYou can reuse or extend the functionalities and capabilities of an existing class in a new class if both the classes have similarities amongst themselves. A class inherit the features of a related class and add new features, as per the requirement. Single level inheritance(单级继承) Multilevel inheritance(多级继承) Hierarchical inheritance(分层继承)Java doesnot support Multiple inheritance, using interface can do it. PolymorphismPolymorphism is an OOP feature that enables an entity to exist in multiple forms. In Java, polymorphism has the following two types. Static polymorphism Dynamic polymorphism The method signature comprises a method’s name and parameter list. 图形界面JDBC多线程Work with ThreadsFurther, you can implement multithreading in an application to achieve an efficient performance and utilize the CPU processing capabilities. Advantages of multithreading Improved performance Minimized system resource usage Program structure simplification Disadvantages Race condition Deadlock condition Lock starvation]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出土训练1]]></title>
    <url>%2F2019%2F03%2F10%2Fpro-ctxl1%2F</url>
    <content type="text"><![CDATA[只出现一次的数字 12345678class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int t=0; for(int i=0;i&lt;nums.size();i++) t^=nums[i]; return t; &#125;&#125;;]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式]]></title>
    <url>%2F2019%2F03%2F08%2Fjava-HangLieShi%2F</url>
    <content type="text"><![CDATA[UPD20190318我发现写错了…交换行的时候没写变号… ---------------- 上课闲着没事…用Java写了个求行列式的还是高斯消元那样求 我的命名还是一如既往的风骚233 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// QAQ.javaimport java.util.Scanner;class QAQ &#123; private double eps = 1e-6; private int n; private double[][] a = new double[55][55]; // private double abs(double a) &#123; return a&gt;0?a:-a; &#125; private boolean cmp(double a, double b) &#123; return Math.abs(a-b)&lt;eps; &#125; public void init() &#123; Scanner sn = new Scanner(System.in); n = sn.nextInt(); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; a[i][j] = sn.nextDouble(); &#125; &#125; &#125; public double Solve() &#123; double ans = 1; for(int i=1; i&lt;=n; i++) &#123; if(cmp(a[i][i],0)) &#123; ans = -ans; int flag = 0; for(int j=i+1; j&lt;=n; j++) if(!cmp(a[j][i],0)) flag = j; if(flag==0) return 0; for(int j=i; j&lt;=n; j++) &#123; double t=a[i][j]; a[i][j]=a[flag][j]; a[flag][j]=t; // swap(a[i][j], a[flag][j]); &#125; &#125; for(int j=i+1; j&lt;=n; j++) &#123; // if(cmp(a[j][i],0)) continue; double t=a[j][i]/a[i][i]; for(int k=i; k&lt;=n; k++) a[j][k]-=t*a[i][k]; &#125; &#125; for(int i=1; i&lt;=n; i++) ans*=a[i][i]; return ans; &#125; public void print() &#123; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; System.out.print(a[i][j] + " "); &#125;System.out.println(""); &#125; &#125; public static void main(String[] args) &#123; QAQ qwq = new QAQ(); qwq.init(); System.out.println("ans = " + qwq.Solve()); qwq.print(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitmenttest]]></title>
    <url>%2F2019%2F01%2F18%2Ftest-gitmenttest%2F</url>
    <content type="text"><![CDATA[gitment测试一下QAQ]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20190118]]></title>
    <url>%2F2019%2F01%2F18%2F20190118%2F</url>
    <content type="text"><![CDATA[没啥事干不想玩游戏 感觉JavaScript有关对象的一些内容太过于复杂了…不学了，用到再说。]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛32 F Friendly Polynomial]]></title>
    <url>%2F2019%2F01%2F17%2Fpro-NK207F%2F</url>
    <content type="text"><![CDATA[Description求 $i \in [1,n-1], a_1,a_2,…,a_i $ 构成一个 $i$ 排列的个数$T$ 次询问$n,T \leqslant 10^5$ Solution老年人体谅一下没有完整的代码只有 $O(n^2)$ 的做法其实就是我不会写NTT了 感觉这题没啥难度 除了NTT多项式求逆 还有我的脑子 阻碍了我做出这道题 留坑。以后如果想起来就填好吧。 先说一下心路历程好吧。 先想暴力。然后我发现了好多检查前缀是否是i排列的方法。取最大值，求和 貌似都可以 然后看一下有啥性质 最大的在第一个一定合法，在最后一个一定不合法 一开始我考虑的是递推，从$n-1$递推到$n$，我觉得最大的影响就是最后一个数字的位置，分成两个记录，分为被之前影响的和未被影响的。然后我去洗澡了233然后发现有问题，其实这个题很简单就是分为两个合法和不合法就行了，之前想的未被影响的其实就是合法的然后可以从前往后来做，考虑贡献，一个不合法的只能贡献一次，对于$i$位合法的才能对后面产生贡献枚举第一个不合法的点，然后后面直接排列就行了。 公式 \begin{align*}f[n]&=\sum_{i=1}^{n-1} ((n-i)!\times (i!-f[i]))\\&=(\sum_{i=1}^{n-1}(n-i)!\times i!)-(\sum_{i-1}^{n-1}(n-1)!\times f[i])\end{align*}多项式 f=g^2-g\times f\Rightarrow f=\frac{g^2}{1+g}好了，双手一撒。掰掰了您内！ Code$ O(n^2) $ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1005;ll p = 998244353;ll f[N]; // 0 - illegal / 1 legalll pn[N];ll pw(ll a, ll b, ll r=1) &#123; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) r=r*a%p;return r; &#125;ll C(ll n, ll m) &#123; if(n&lt;m) return 0; return pn[n]*pw(pn[m],p-2)%p*pw(pn[n-m],p-2)%p;&#125;void init() &#123; f[1]=0; pn[0]=pn[1]=1; for(int i=2;i&lt;N;i++) pn[i]=pn[i-1]*i%p;&#125;void work() &#123; for(int i=2;i&lt;N;i++) &#123; for(int j=1;j&lt;i;j++) f[i]=(f[i]+(pn[j]-f[j]+p)%p*pn[i-j]%p)%p; &#125;&#125;int main() &#123; init(); work(); int n; cin &gt;&gt; n; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>problem</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>fft/ntt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记]]></title>
    <url>%2F2019%2F01%2F09%2Fnote-linuxcommend%2F</url>
    <content type="text"><![CDATA[I think if you want to know the options, you just need to type man/info+options or option—help is enough. LinuxFeatures of the Linux Operating System Multiuser Multiprogramming Time-sharing Multitasking Virtual memory Shared libraries POSIX-compliance Samba Network Information Service Cron scheduler Office suites Data archiving utilities Licensing Web Server Other features: have many free software. Advantages of Linux Open-source Reliability Backward compatibility Simple upgrade and installation process Low total cost of ownership Support for legacy devices GUI interface Multiple distributors Excellent security features Support for high user load Support for development libraries Distributors of Linux Red Hat Mandriva Debian SUSE Slackware Fedora Consistthree main components Kernel Shell Linux Utilities and Application Programs 文件系统.gnome-desktop桌面 Commendpasswd1passwd change the user password.修改用户密码 root可以修改其他用户密码1passwd username dateShow the date.显示日期和时间 1date 1234date &quot;+opt&quot;Egdate &quot;+%T&quot;13:13:13 1234date &quot;+text opt&quot;Egdate &quot;+DATE : %D&quot;DATE : 1/9/2019 Option Description %m Displays month of the year %d Displays day of the month %y Displays year %D Displays date as mm/dd/yy %H Displays hour %M Displays minutes %S Displays seconds %T Displays time as HH:MM:SS %a Displays abbreviated weekday %h Displays abbreviated month %r Displays time in the AM/PM notation clearClear Screen.清屏 tput - Pendingtput 完成交互，专业性强的屏幕输出 Option Description tput clear clear screen tput sc save the position of cursor tput cup change the position of cursor tput civis Hide the cursor tput cnorm Show the cursor tput rc show the output tput smso tput rmso tput blink tput reset who显示当前登录的用户第一列：登录名第二列：终端类型和终端号第三列：登录时间第四列：The remote host name of the terminal from where the user has logged in. Note that this is shown only for users who have not logged in from the server. 1who Option Description -m 当前登录用户名，等价于who am i -q 只显示登录名和登录数 1who am i uptime显示系统持续时间 分别是：当前时间，系统运行时间，登录用户数，平均CPU使用率 1uptime man1man +程序名 infoinfo比man要详细一些1info [options] [menu item] Option Description —apropos=string Search string -o,—output=FILENAME output the information -h,-help help —version version cdchange the current directory1234567cd ../ 切换到上一层目录cd / 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录（返回） ls显示目录下的文件和子文件夹ls -l Column Description 1 文件类型和权限 2 Number of link 3 文件所有者 4 组所有者 5 文件大小 6,7,8 最后修改时间 9 文件名 文件类型 Symbol Description - 普通文件 d 文件夹 b c l s p | Option | Description || -a | 显示所有文件 || -F | || -R | || -r | || -S | || -A | | catpwd显示当前目录 1pwd mkdircprmrmdir删除文件夹1rmdir +文件夹名 mv0&lt;,1&gt;,1&gt;&gt;,2&gt;文件重定向 Option Description 0&lt;,&lt; 读入 &gt;,1&gt; 输出到文件，重新写 &gt;&gt;,1&gt;&gt; 续写文件 2&gt; 输出错误提示信息到文件 chmod- --- --- ---dir|document owner group otheruser Symbol Meaning Number r read 4 w write 2 x execute 1 - no 0 Symbol Meaning u owner g group o otheruser a alluser chmod u|g|o|a +|- r|w|x file_namechmod 777 file_name filters使用多个过滤器时用|分隔开，在最前面写文件名 grep1grep [option(s)] pattern [filename] 以行为单位筛选包含指定字符的行 Option Description -n 显示行号 -c 输出匹配到行的个数 -v 反向查找，查找不匹配的行 wc1wc [option(s)] [filename] 计数工具 Option Description -l 显示行数量 -w 显示单词数 -c 显示字符数 cut1cut [option(s)] [filename] 显示一列、一列字符 Option Description -f 显示的列数，用逗号分隔，可用-连接 -c 显示每列字符的位数 -d&lt;column_delimiter 列分隔符 trtr字符可以对来自标准输入的字符进行替换、压缩和删除，可以将一组字符编程另外一组字符。 例如1tr &quot;[a-z]&quot; &quot;[A-Z]&quot; 转换小写为大写需要文件重定向来写入 Option Description -c, -C, --complement 取代所有不属于第一字符集的字符 -d, --delete 删除所有属于第一字符集的字符 -s, --squeeze-repeats 把连续重复的字符以单独一个字符表示 -t, --truncate-set1 先删除第一字符集较第二字符集多出的字符 sort排序 ascending(asc)正序descending(desc)倒序 Option Description -b 忽略每行前面开始出的空格字符 -c 检查文件是否已经按照顺序排序 -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符 -f 排序时，将小写字母视为大写字母 -i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符 -m 将几个排序好的文件进行合并 -M 将前面3个字母依照月份的缩写进行排序 -n 依照数值的大小排序 -o 将排序后的结果存入指定的文件 -r 以相反的顺序来排序 -t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符 +&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围左闭右开]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>linux</tag>
        <tag>linuxcommend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLT笔记]]></title>
    <url>%2F2019%2F01%2F08%2Fnote-PLT%2F</url>
    <content type="text"><![CDATA[Phases - 阶段Input-Process-Output cycle A set of instructions to perform a particular job is called a program. An algorithm is a sequence of steps required to solve a problem. A flowchart is a graphical representation of the steps to be followed for solving a problem.It consists of a set of symbols, each symbol represents a specific activity. 平行四边形 - Input - 输入长方形 - Process - 过程左尖右弧 - Output - 输出菱形 - Decision - 决策长方形+两个竖线 - Procedure/Subtoutine - 子程序箭头 - Flow lines - 流程线椭圆 - Terminator - 结束符圆 - On-page connector - 同页连接器长方形+倒三角 - Off-page connector - 分页连接器右不封口长方形+竖线 - Annotation - 注释 Variabletype:Numeric CharacterNumeric variables can contain only numbers.Character variables can contain any combination of letters, numbers, and special characters.Variable Naming Conventions:first letter of variable may indicate data type used; first letter of each words could be capitalized; not contain embedded space and ?!@#$%^&amp;*(){}[].,:;&quot;&#39;/\ Operators: Arithmetic operators, Relational operators, Logical operators.Arithmetic operators are used to perform arithmetic calculations.Relational operators are used to test the relationship between two variables or the relationship between a variable and a constant.Logical operators are used to combine expressions containing relational operators.Precedence of the execution of logical operators is NOT, AND and OR. The decision box is used to apply conditions by asking a question in a flowchart. Dry run table (预检表)The concept of dry run will help you perform a logic check and understand the flow of control in a flowchart.You can also use the dry run table to evaluation the output of the program with a set of sample values.A dry run provides a step by step evaluation of values in the variables of the program. IterationA loop is a sequence of instructions that will be repeated more than once.A loop must always perform certain steps in a specified sequence.There are two types of loops:fixed loops where the number of repetitions is known;variable loops where the number of repetitions is not known.Statements within a loop will be executed repeatedly until the condition becomes false. The structured programming techniques provide ways to break up a long, continuous program into a series of individual modules that are related to each other in a specified manner.A large program can be divided into several modules, where each module performs a specific task. A module is also called a procedure.A procedure or a module is invoked from the main program and the control returned from the procedure to the main program by using the return statement.]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>PLT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brainfuck编译器]]></title>
    <url>%2F2019%2F01%2F06%2Fc-Brainfuck%2F</url>
    <content type="text"><![CDATA[随便写的qwq严格的说应该是翻译器233改改就可以成解释器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;iostream&gt;using namespace std;deque&lt;char&gt;::iterator pt;deque&lt;char&gt; cp;vector&lt;char&gt; inf;vector&lt;char&gt;::iterator it;stack&lt;vector&lt;char&gt;::iterator&gt; stk;int chk() &#123; int cnt=0; for(it=inf.begin();it!=inf.end();it++) &#123; if(*it=='[') cnt++; if(*it==']') cnt--; &#125; if(cnt) return 1; return 0;&#125;int main() &#123; freopen("a.in","r",stdin); char a; cp.push_back(0); pt=cp.begin(); while((a=getchar())!=EOF) inf.push_back(a); if(chk()) &#123; cout&lt;&lt;"Error"&lt;&lt;endl;return 0; &#125; it=inf.begin(); while(it!=inf.end()) &#123; switch(*it) &#123; case '&gt;': if(++pt == cp.end()) cp.push_back(0); break; case '&lt;': if(pt == cp.begin()) cp.push_front(0); pt--; break; case '+': (*pt)++; break; case '-': (*pt)--; break; case '.':// cout&lt;&lt;(int)(*pt)&lt;&lt;endl; putchar(*pt); break; case ',': ++it,(*pt)=(*it); break; case '[': if(*pt) stk.push(it); else &#123; int cnt=1; for(it++;;it++) &#123; if(*it=='[') cnt++; if(*it==']') cnt--; if(!cnt) break; &#125; &#125; break; case ']': it=stk.top(),it--,stk.pop(); break; default: if(*it!='\n' &amp;&amp; *it!='\t' &amp;&amp; *it!=' ') &#123; cout&lt;&lt;"Error!"&lt;&lt;endl;return 1; &#125; break; &#125;// cout&lt;&lt;(*it)&lt;&lt;" "&lt;&lt;(int)(*pt)&lt;&lt;endl; it++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20181226]]></title>
    <url>%2F2018%2F12%2F26%2F20181226%2F</url>
    <content type="text"><![CDATA[好几天没更新博客了…或者说这博客其实一周一更，只是每次更新都不会把博文重新置顶而已。 自己过了个圣诞节好气哦。 为了自己寒假不颓废决定先写个TODOLIST 计算机二级。 写个微信小程序 学学js 就先这样。]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell笔记]]></title>
    <url>%2F2018%2F12%2F26%2Fnote-shell%2F</url>
    <content type="text"><![CDATA[Unix Shells Bourne shell(sh) C shell(csh) Korn shell(ksh) Restricted shell TC shell(tcsh) Linux Shells Bourne again shell(bash) A shell(ash) 运行脚本在第一行加入123#!/bin/bash或#!/bin/sh 1. + 空格 + 文件名 (不需要权限) 1. + 路径 (需要权限) 1/bin/bash + 文件名 变量定义变量12a=3b=&quot;haha&quot; 注意 变量名和等号之间不能有空格！ 不能用关键词，首字符不能为数字，可以使用下划线 使用变量在定义过的变量前加上$可以用{}将变量名括起来，这个是可选的，但是有时候输出必须要区分开 只读变量1234readonly var=3或var=3readonly var 变量类型局部变量局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 特殊变量 变量 描述 $0 当前脚本文件名 $n 传递给脚本或函数的参数，n是一个数字，表示第几个参数，第一个参数$1 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数 $@ 传递给脚本或函数的所有参数，被双引号包含时，与$*稍有不同 $? 上个命令的退出状态或函数的返回值 $$ 当前Shell进程ID $! 后台运行的最后一个进程的ID号 $- 显示Shell使用的当前选项，与set命令功能相同。 $* 和 $@的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。但是当它们被双引号(“ “)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;的形式输出所有参数。 $?可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 删除变量1unset a Shell字符串单引号原样输出，不进行转义 双引号可以有变量和转义字符 获取字符串长度12str=&quot;abcd&quot;echo $&#123;#str&#125; 提取子字符串12str=&quot;abcd&quot;echo $&#123;#str:2:3&#125; #bc 查找子字符串查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： 12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 数组定义数组12345678910111213数组名=(值1 值2 ... 值n)array_name=(value0 value1 value2 value3)或array_name=(value0value1value2value3)或array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组1$&#123;数组名[下标]&#125; 获取数组长度123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; 注释用#开头若大量代码需要注释，那么可以有定义成函数并不调用 多行注释 12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF EOF 也可以使用其他符号: 1234567891011:&lt;&lt;&apos;注释内容...注释内容...注释内容...&apos;:&lt;&lt;!注释内容...注释内容...注释内容...! Shell基本运算符原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 算术运算符下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等 用于比较两个数字，相同则返回 true。[ $a == $b ] 返回 false。 != 不相等 用于比较两个数字，不相同则返回 true。[ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 乘号(*)前边必须加反斜杠(\)才能实现乘法运算； 运算 expr函数 用$(())可以转化为表达式 小数运算 awk 比较复杂… 12echo `awk &apos;BRGIN&#123;a=5.5/3.3;print a&#125;&apos;`echo `awk -v x=2.45 -v y=3.123 &apos;BEGIN&#123;printf &quot;%.2f\n&quot;,x*y&#125;&apos;` | bc 12s2=$(echo &quot;scale=3; 6 / 5&quot; | bc)echo $s2 关系运算符 符号 描述 -eq 等于 -ne 不等 -gt 大于 -lt 小于 -ge 大于等于 -le 小于等于 布尔运算符 符号 描述 ！ 非 -o 或 -a 与 逻辑运算符 符号 描述 &#124;&#124; 或 &amp;&amp; 与 字符串运算符比较的时候等号两边要加空格… 符号 描述 = 相等 != 不等 -z 长度是否为0 -n 长度是否不为0 string 是否为空 文件测试运算符 符号 描述 -b file 检测文件是否是块设备文件 -c file 检测文件是否是字符设备文件 -d file 检测文件是否是目录 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件） -g file 检测文件是否设置了 SGID 位 -k file 检测文件是否设置了粘着位(Sticky Bit) -p file 检测文件是否是有名管道 -u file 检测文件是否设置了 SUID 位 -r file 检测文件是否可读 -w file 检测文件是否可写 -x file 检测文件是否可执行 -s file 检测文件是否为空（文件大小是否大于0） -e file 检测文件（包括目录）是否存在 输出echo单引号不转义，双引号转义，-e开启转义 printf格式化输出 test命令用于检测某条件是否成立代码中[]执行基本的算术运算 流程控制条件控制if1234567891011if conditionthen command1 command2 ... commandN fi或if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi if-else123456789if conditionthen command1 command2 ... commandNelse commandfi if-else-if-else123456789if condition1then command1elif condition2 then command2else commandNfi 循环for 1234567891011for var in item1 item2 ... itemNdo command1 command2 ... commandNdone或for var in item1 item2 ... itemN; do command1; command2… done; 计数循环12&#123;0..9&#125;$(seq 10) while1234while conditiondo commanddone 计数循环1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done until 直到条件满足截止1234until conditiondo commanddone 分支12345678910111213141516case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;*) #其他 ;;esac Eg.12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone 跳出循环 break continue 函数123456789[ function ] funname [()]&#123; action; [return int;]&#125; 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)函数返回值在调用该函数后通过 $? 来获得。必须使用前定义在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…参数总数 $#作为一个字符串输出所有参数 $* 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$$$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 输入输出重定向 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。 /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 Shell 文件包含和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下：123. filename # 注意点号(.)和文件名中间有一空格或source filename]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式笔记]]></title>
    <url>%2F2018%2F12%2F05%2Fnote-zzbds%2F</url>
    <content type="text"><![CDATA[转义字符 字符 描述 \cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符 \f 匹配一个换页符。等价于 \x0c 和 \cL \n 匹配一个换行符。等价于 \x0a 和 \cJ \r 匹配一个回车符。等价于 \x0d 和 \cM \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v] \t 匹配一个制表符。等价于 \x09 和 \cI \v 匹配一个垂直制表符。等价于 \x0b 和 \cK 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &#39;\n&#39; 或 &#39;\r&#39;。要匹配 $ 字符本身，请使用 \$ ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \) * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \* + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+ . 匹配除换行符 \n之外的任何单字符。要匹配 . ，请使用 \. [ 标记一个中括号表达式的开始。要匹配 [，请使用 \[ ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \? \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。&#39;\n&#39; 匹配换行符。序列 &#39;\\&#39; 匹配 &quot;\&quot;，而 &#39;\(&#39; 则匹配 &quot;(&quot; ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^ { 标记限定符表达式的开始。要匹配 {，请使用 \{ &#124; 指明两项之间的一个选择。要匹配 &#124;，请使用 \&#124; 限制符 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,} + 匹配前面的子表达式一次或多次。例如，&#39;zo+&#39; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 、 &quot;does&quot; 中的 &quot;does&quot; 、 &quot;doxy&quot; 中的 &quot;do&quot; 。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，&#39;o{2}&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但是能匹配 &quot;food&quot; 中的两个 o {n,} n 是一个非负整数。至少匹配 n 次。例如，&#39;o{2,}&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但能匹配 &quot;foooood&quot; 中的所有 o。&#39;o{1,}&#39; 等价于 &#39;o+&#39;。&#39;o{0,}&#39; 则等价于 &#39;o*&#39; {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o{1,3}&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&#39;o{0,1}&#39; 等价于 &#39;o?&#39;。请注意在逗号和两个数之间不能有空格]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[imagemagnifier]]></title>
    <url>%2F2018%2F12%2F02%2Fjs-imagemagnifier%2F</url>
    <content type="text"><![CDATA[cnv1 = document.getElementById('cnv1'); ctx1 = cnv1.getContext('2d'); cnv2 = document.getElementById('cnv2'); ctx2 = cnv2.getContext('2d'); var img = new Image(); img.src = '/img/201812021851.png'; var zm = function(e) { ctx1.drawImage(img, 0, 0); var x = event.layerX; var y = event.layerY; ctx2.drawImage(cnv1, Math.abs(x-5), Math.abs(y-5), 10, 10, 0, 0, 100, 100); } cnv1.addEventListener('mousemove', zm);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>canvas</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Breakoutv0.0.1]]></title>
    <url>%2F2018%2F12%2F02%2Fjs-Breakoutv0.0.1%2F</url>
    <content type="text"><![CDATA[var cnv = document.getElementById("cnv1"); var ctx = cnv.getContext('2d'); var start = false; var raf; var vv = 5; var over = false; var ball = { x: 150, y: 600-5-8, //change vx: 0, vy: vv, r: 8, col: "black", draw: function() { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI, false); ctx.closePath(); ctx.fillStyle = this.col; ctx.fill(); ctx.restore(); }, rset: function() { this.x = 150, this.y = 600-5-8; //change } } var block = { x: 150, y: 600, h: 5, w: 60, col: "black", draw: function() { ctx.save(); ctx.fillStyle = this.col; ctx.fillRect(this.x-this.w/2, this.y-this.h, this.w, this.h); ctx.restore(); }, rset: function() { this.x = 150, this.y = 600; } } var line = { x1: 150, y1: ball.y, x2: 0, y2: 0, length: 80, width: 3, ang: 0, col: "red", rot: function(x, y) { dx = x-this.x1; dy = Math.max(0, this.y1-y); this.ang = Math.atan(dy/dx); if(this.ang < 0) this.ang += Math.PI; this.x2 = 150+this.length*Math.cos(this.ang); this.y2 = this.y1-this.length*Math.sin(this.ang); }, draw: function() { ctx.save(); ctx.lineWidth = this.width; ctx.strokeStyle = this.col; ctx.beginPath(); ctx.moveTo(this.x1, this.y1); ctx.lineTo(this.x2, this.y2); ctx.stroke(); ctx.restore(); } } ball.move = function() { if(!start) return; this.x += this.vx; this.y += this.vy; if(this.x-this.r < 0) { this.x = this.r-this.x; this.vx = -this.vx; } if(this.x+this.r > 300) { this.x = 600-(this.x+this.r); this.vx = -this.vx; } if(this.y-this.r < 0) { this.y = this.r-this.y; this.vy = -this.vy; } if(this.y+this.r > 600-block.h) { if(ball.x-5 > block.x+block.w/2 || ball.x+5 < block.x-block.w/2) { over = true; return; } this.y = 2*(600-block.h)-(this.y+this.r); this.vy = -this.vy; } } function clear() { ctx.clearRect(0, 0, 300, 600); } function rset() { clear(); start = false; over = false; ball.rset(); block.rset(); } function move() { clear(); ball.move(); ball.draw(); block.draw(); if(over) { rset(); window.cancelAnimationFrame(raf); return; } raf = window.requestAnimationFrame(move); } cnv.addEventListener("mousemove", function(e) { if(!start) { clear(); ball.draw(); block.draw(); line.rot(e.clientX, e.clientY); line.draw(); } else { block.x = e.clientX; } }); /* cnv.addEventListener("mouseover", function(e) { }); cnv.addEventListener("mouseout", function(e) { }); */ cnv.addEventListener("click", function(e) { if(!start) { start = true; over = false; ball.vx = vv*Math.cos(line.ang); ball.vy = vv*Math.sin(line.ang); raf = window.requestAnimationFrame(move); } });]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>canvas</tag>
        <tag>breakout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AddBall2]]></title>
    <url>%2F2018%2F12%2F02%2Fjs-addball2%2F</url>
    <content type="text"><![CDATA[点击释放小球，再次点击可以开关尾部踪迹，因为blog的原因可能兼容不好…没有鼠标悬停的动画 cnv = document.getElementById('cnv1'); ctx = cnv.getContext('2d'); var raf; var running = false; var tail = false; var ball = { x: 0, y: 0, vx: 5, vy: 5, r: 10, col: "red", draw: function() { ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, 2*Math.PI, false); ctx.closePath(); ctx.fillStyle = this.col; ctx.fill(); ctx.restore(); } } function clear() { if(tail) { ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; ctx.fillRect(0, 0, 500, 350); } else { ctx.clearRect(0, 0, 500, 350); } } function move() { clear(); ball.draw(); ball.x += ball.vx; ball.y += ball.vy; if(ball.x-ball.r < 0) ball.x = ball.r-ball.x, ball.vx = -ball.vx; if(ball.x+ball.r > 500) ball.x = 1000-(ball.x+ball.r), ball.vx = -ball.vx; if(ball.y-ball.r < 0) ball.y = ball.r-ball.y, ball.vy = -ball.vy; if(ball.y+ball.r > 350) ball.y = 700-(ball.y+ball.r), ball.vy = -ball.vy; raf = window.requestAnimationFrame(move); } cnv.addEventListener("mousemove", function(e) { if(!running) { clear(); ball.x = e.clientX; ball.y = e.clientY; ball.draw(); } }); cnv.addEventListener("click", function(e) { if(!running) { running = true; raf = window.requestAnimationFrame(move); } else { tail = !tail; } }); cnv.addEventListener("mouseover", function(e) { if(running) { raf = window.requestAnimationFrame(move); } }); cnv.addEventListener("mouseout", function(e) { window.cancelAnimationFrame(raf); });]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈哈哈哈哈哈哈]]></title>
    <url>%2F2018%2F11%2F29%2Ftest-Haha%2F</url>
    <content type="text"><![CDATA[哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Canvas笔记]]></title>
    <url>%2F2018%2F11%2F29%2Fnote-canvas%2F</url>
    <content type="text"><![CDATA[Tutorial usagedefault size:300px * 150px not using CSS 1&lt;canvas id="" width="" height=""&gt; &lt;/canvas&gt; 渲染上下文 12var canvas = document.getElementById(&apos;id&apos;);var ctx = canvas.getContext(&apos;2d&apos;); 检查支持性 12345678var canvas = document.getElementById(&apos;tutorial&apos;);if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; 绘制栅格网格是左上角为(0,0)，向右为x正方向，向下为y正方向 绘制矩形(x,y)为矩形左上角坐标 fillRect(x, y, width, height)绘制填充矩形 storkeRect(x, y, width, height)绘制矩形边框 clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明 绘制路径beginPath()新建一条路径 closePath()闭合路径 stroke()绘制图形轮廓 fill()填充区域 注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo()，无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。 注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。 移动笔触moveTo(x, y)将笔触移动到指定坐标 如果没有moveTo()会变成一条连续的线 线lineTo(x, y)绘制一条从当前位置到指定坐标的线 圆弧arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。参数anticlockwise为一个布尔值。为true时，是逆时针方向，否则顺时针方向。 arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 注意：arc()函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式:弧度=(Math.PI/180) * 角度。 二次贝塞尔曲线及三次贝塞尔曲线Bézier curve quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 矩形rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标。 Path2D对象Path2D()Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。 123new Path2D(); // 空的Path对象new Path2D(path); // 克隆Path对象new Path2D(d); // 从SVG建立Path对象 Path2D.addPath(path [, transform])​添加了一条路径到当前路径（可能添加了一个变换矩阵）。 关于Path2D() 颜色fillStyle = color设置图形的填充颜色。 strokeStyle = color设置图形轮廓的颜色 color是符合CSS3color 的字符串 透明度globalAlpha = transparencyValue这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。 因为 strokeStyle 和 fillStyle 属性接受符合 CSS 3 规范的颜色值，那我们可以用下面的写法来设置具有透明度的颜色。 123// 指定透明颜色，用于描边和填充样式ctx.strokeStyle = &quot;rgba(255,0,0,0.5)&quot;;ctx.fillStyle = &quot;rgba(255,0,0,0.5)&quot;; rgba() 方法与 rgb() 方法类似，就多了一个用于设置色彩透明度的参数。它的有效范围是从 0.0（完全透明）到 1.0（完全不透明）。 线型lineWidth = value设置线条宽度。 lineCap = type设置线条末端样式。 type 参数为: butt，round 和 square。默认是 butt。butt 是刚好平齐，round 和 square 都会多出一块，一个是圆形，一个是矩形。 lineJoin = type设定线条与线条间接合处的样式。type 参数为: round, bevel 和 miter。默认是 miter。折线分别为圆弧形，被切去尖角，尖角 miterLimit = value限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。可以限制上面的参数，miter超过限制时就会变成bevel getLineDash()返回一个包含当前虚线样式，长度为非负偶数的数组。 setLineDash(segments)设置当前虚线样式。接受一个数组，设置线段和间隙。 lineDashOffset = value设置虚线样式的起始偏移量。 渐变createLinearGradient(x1, y1, x2, y2)createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 createRadialGradient(x1, y1, r1, x2, y2, r2)createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。 gradient.addColorStop(position, color)addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。 然后可以将这些渐变色赋值给fillStyle 和 strokeStyle 图案样式createPattern(image, type)该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。 图案的应用跟渐变很类似的，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。 阴影shadowOffsetX = floatshadowOffsetY = floatshadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。 shadowBlur = floatshadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。 shadowColor = colorshadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。 Canvas 填充规则当我们用到 fill（或者 clip和isPointinPath）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。 两个可取的值： “nonzero”: non-zero winding rule, 默认值. “evenodd”: even-odd winding rule. 绘制文本fillText(text, x, y [, maxWidth])在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. strokeText(text, x, y [, maxWidth])在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 文本样式font = value当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。 textAlign = value文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。 textBaseline = value基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。 direction = value文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。ltr: left-to-right,rtl: right-to-left measureText()将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性，可以获得更多细节。 图像获取图片HTMLImageElement这些图片是由Image()函数构造出来的，或者任何的元素 HTMLVideoElement用一个HTML的 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像 HTMLCanvasElement可以使用另一个 元素作为你的图片源。 ImageBitmap这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。 详细使用请移步吧… 绘制图片drawImage(image, x, y)其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。 drawImage(image, x, y, width, height)这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。 变形状态保存和恢复save()restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 一个绘画状态包括：当前应用的变形（即移动，旋转和缩放，见下）strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值 移动translate(x, y)translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，用来移动 canvas 和它的原点到一个不同的位置。 旋转rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。 缩放scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。 变形transform(m11, m12, m21, m22, dx, dy)这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵m11：水平方向的缩放m12：水平方向的倾斜偏移m21：竖直方向的倾斜偏移m22：竖直方向的缩放dx：水平方向的移动dy：竖直方向的移动 setTransform(m11, m12, m21, m22, dx, dy) resetTransform() 组合globalCompositeOperation = type这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。 type Description source-over 这是默认设置，并在现有画布上下文之上绘制新图形。 source-in 新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。 source-out 在不与现有画布内容重叠的地方绘制新图形。 source-atop 新图形只在与现有画布内容重叠的地方绘制。 destination-over 在现有的画布内容后面绘制新的图形。 destination-in 现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。 destination-out 现有内容保持在新图形不重叠的地方。 destination-atop 现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的。 lighter 两个重叠图形的颜色是通过颜色值相加来确定的。 copy 只显示新图形。 xor 图像中，那些重叠和正常绘制之外的其他地方是透明的。 multiply 将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。 screen 像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。 overlay multiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮。 darken 保留两个图层中最暗的像素。 lighten 保留两个图层中最亮的像素。 color-dodge 将底层除以顶层的反置。 color-burn 将反置的底层除以顶层，然后将结果反过来。 hard-light 屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了。 soft-light 用顶层减去底层或者相反来得到一个正值。 difference 一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。 exclusion 和difference相似，但对比度较低。 hue 保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）。 saturation 保留底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）。 color 保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)。 luminosity 保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）。 裁切路径clip()将当前正在构建的路径转换为当前的裁剪路径。 限制绘制区域 基本动画基本步骤清空 canvas除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。 保存 canvas 状态如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。 绘制动画图形（animated shapes）这一步才是重绘动画帧。 恢复 canvas 状态如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。 操控动画更新画布首先，可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。 setInterval(function, delay)当设定好间隔时间后，function会定期执行。 setTimeout(function, delay)在设定好的时间之后执行函数 requestAnimationFrame(callback)告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。 高级动画一个事件库 像素操作ImageData对象width图片宽度，单位是像素 height图片高度，单位是像素 dataUint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255） 创建ImageData对象12var myImageData = ctx.createImageData(width, height);var myImageData = ctx.createImageData(anotherImageData); 创建出来的像素都被预设成透明黑 得到场景像素数据1var myImageData = ctx.getImageData(left, top, width, height); 在场景中写入像素数据1ctx.putImageData(myImageData, dx, dy);]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>note</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20181120]]></title>
    <url>%2F2018%2F11%2F20%2F20181120%2F</url>
    <content type="text"><![CDATA[仿佛发现了新的快乐源泉！ &quot;B&quot;+&quot;a&quot;+ +&quot;B&quot;+&quot;a&quot; 这句在JavaScript中会输出 BaNaNa ! 12345"B"+"a"+ +"B"+"a" // "BaNaNa"[] == ![]; // "true"2 == [2]; // true"" == [null]; // trueNaN == NaN // false 还有很多奇怪的东西都在这里↓传送门]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
        <tag>javascript</tag>
        <tag>exm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript笔记]]></title>
    <url>%2F2018%2F11%2F18%2Fnote-javascript%2F</url>
    <content type="text"><![CDATA[JavaScript快速上手变量定义1var name; 变量名开头可以是任意Unicode字符、美元符、下划线后面的字符除上述以外还有Unicode数字 不能是关键字关键字：1234567891011arguments break case catchclass const continue debuggerdefault delete do elseenum export extends falsefinally for function ifimplements import in instanceofinterface let new nullpackage private protected publicreturn static super switchthis throw true trytypeof var void while 3个标识符不是保留字但也要视为保留字 1Infinity NaN undefined 原始值有布尔值、数字、字符串、空值(undefine null)特点可进行内容比较其属性不能被改变、添加或移除 ToPrimitive()将值转换为原始值 对象非原始值都是对象简单对象、数组、正则表达式 比较身份标识，每个值都有各自的身份标识对象属性可以很自由地改变、添加或移除 undefined 和 null丢失参数、访问不存在的属性会得到undefinednull是没有对象可以直接比较相等 typeof 和 instanceoftypeof用法typeof value; 操作数 结果 undefined ‘undefined’ null object 布尔值 boolean 数字 number 字符串 string 函数 function 其他常规值 object 引擎创建的值 任意字符串 instanceof用法value instanceof Constr判断value是否由Constr创建 12&gt; undefined instanceof Objectfalse 布尔值以下值会被认为是false undefined\null false -0,NaN ‘’ 严格的相等或不等=== !==宽松的相等或不等== != 数字特殊的数字NaN = Not a number12&gt; Number(&apos;xyz&apos;)NaN 检查是否为NaN用isNaN()，但对非数字不起作用，可以用其值是否等于自身来判断 Infinity1234&gt; 3/0Infinity&gt; Math.pow(2,1024)//too largeInfinity isFinite()可以用来检查是否为实际值，即不为以上两个值 parseFloat()将字符串中字符转换成数字，对于一些特殊的例如true null ‘’ 无法处理 JavaScript有两个0，+0，-0 数字内部表示为双精度 部分 位数 位置 符号 1位 第63位 指数 [-1023,1024] 11位 62~52 分数 52位 52~0 表示公式 $ (-1)^{sign} \times %1.fraction \times 2^{exponent} $ 安全整型范围Number.MAX_SAFE_INTEGER=2^53Number.MIN_SAFE_INTEGER=-2^53 浮点数转化为整数的方法Math.floor(),Math.ceil(),Math.round() 位运算或Toint32()得到32位整数 parseInt()可得到整数，可选基数，在第二个参数 Number原型方法 函数 描述 Number.prototype.toFixed(fractionDigits) 舍入到小数点后指定位数 Number.prototype.toPrecision(precision) 精确到指定位 Number.prototype.toString(radix) 转化为可选字符串可选进制 Number.prototype.toExponential(fractionDigits) 强制指数表示 运算符基本都一样 字符串原始值 不可改变单引号双引号均可以使用 一个反斜杠对行结束符转义，使字符串跨行拼写 可以用&gt;&lt;直接比较 也可以String.prototype.localeCompare(other) 构造器方法String.fromCharCode()String.fromCharCode().apply() 原型方法String.prototype.charAt(pos)String.prototype.charCodeAt(pos) //String.fromCharCode()逆函数String.prototype.slice(start [,end])String.prototype.substring(start [,end])String.prototype.split([separator] [,limit]) //separator可以为正则表达式 limit 是最多包含元素 字符串变换String.prototype.trim() //去除开头结尾空格换行符等String.prototype.concat(str1,str2,...)String.prototype.toLowerCase()String.prototype.toLocaleLowerCase()String.prototype.toUpperCase()String.prototype.toLocaleUpperCase() 字符串检索和比较String.prototype.indexOf(searchString,position)String.prototype.lastIndexOf(searchString,position)String.prototype.localeCompare(other) 支持正则表达式的方式String.prototype.search(regexp) //返回第一个起始位置，未匹配返回-1String.prototype.match(regexp) //返回所有匹配的子字符串String.prototype.replace(search, replacement) 语句if/switch/for/while/do-while与C/C++完全相同 函数函数声明方式定义函数123function add(a, b) &#123; return a + b;&#125; 给变量赋值为函数表达式123var add = function(a, b) &#123; return a + b;&#125; 函数声明的提升特性函数声明具有提升特性 他们实体会被移动到所在作用域开始处 argumentsJavaScript中所有参数可被调用，通过arguments来使所有参数可用123456&gt; function f() &#123; return arguments; &#125;&gt; var args = f(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);&gt; args.length3&gt; args[0]&apos;a&apos; 参数太多或太少太多额外的参数会忽略太少丢失的参数会得到undefined 可选参数附上默认值 123456function pair(x, y) &#123; x = x || 0; y = y || 0; return [x, y]; &#125; 限制参数长度12345funton pair(x, y) &#123; if(arguments.length !== 2) &#123; throw new Error(&apos;Need exactly 2 arguments&apos;); &#125;&#125; 将arguments转化为数组123function toArray(arrayLikeObject) &#123; return Array.prototype.slice.call(arrayLikeObject);&#125; 异常捕获123456789101112131415161718function getPerson(id) &#123; if (id &lt; 0) &#123; throw new Error(&apos;ID must not be negative:&apos; + id); &#125; return &#123; id:id &#125;;&#125;function getPerson(ids) &#123; var result = []; ids.forEach(function(id) &#123; try &#123; var person = getPerson(id); result.push(person); &#125; catch (exception) &#123; console.log(exception); &#125; &#125;); return result;&#125; 严格模式&lt;script&gt;标签第一行输入 &#39;use strict&#39;或在每一个函数中激活&#39;use strict&#39;; 变量作用域和闭包一个变量的作用域总是完整的函数提升特性，声明会被移动到函数开始处闭包，每个函数都和他周围的变量保持连接IIFE模式，防止成为全局变量，用函数限制作用域 对象和构造函数可以用delete移除属性 任意属性名 提取方法使用bind()方法 方法中的函数无法使用this，两种解决方法:保存在另一个变量中，利用函数参数传入 构造函数 数组数组可以拥有自定义属性。索引 $i$ 是数字 $0\leqslant i &lt; 2^32-1$ length不是函数，数组的一个属性。 二维数组需要手动创建1234567var rows = [];for(var i=0; i&lt;3; i++) &#123; rows[i]=[]; for(var j=0; j&lt;3; j++) &#123; rows[i][j]=1; &#125;&#125; in检查的索引值。 长度length的基本功能是追踪数组的最大索引。 可以直接修改长度…多加少减。 添加和删除元素（破坏性地）123456789101112Array.prototype.shift() // 移除索引0处的元素，随后元素索引依次-1Array.prototype.unshift(elem1?, elem2?, ...) // 在数组最前面添加给定元素，返回新的数组长度Array.prototype.pop() // 移除数组最后的元素并返回该元素Array.prototype.push() // 在数组尾部添加该元素，返回新的数组长度// 破坏性地吧arr2添加到arr1后Array.prototype.push.apply(arr1, arr2)Array.prototype.splice(start, deleteCount?, elem1?, elem2?, ...) // 从start开始移除deleteCount个元素，并插入给定元素// start可以是负数，-1指向最后的元素，以此类推// deleteCount是可选的，若省略（连同所有后续的参数），那么将移除之后所有的元素 排序和颠倒元素顺序（破坏性地）12345Array.prototype.reverse() // 颠倒顺序Array.prototype.sort(compareFunction?) // 排序，转化为字符串比较// function compareFunction(a, b) 比较ab，返回负数(a&lt;b)；返回0(a=b)；返回正数(a&gt;b) 合并、切分和连接（非破坏性地）1234567Array.prototype.concat(arr1?, arr2?, ...) // 创建一个新数组Array.prototype.slice(begin?, end?) // 将[begin,end)复制到新数组，缺少end使用数组长度，都缺少复制整个数组。若任意索引时负值，那么加上数组长度Array.prototype.join(separator?) // 对所有数组元素创建字符串，用separator连接，若缺少，默认为&apos;,&apos; 值的查找（非破坏性地）1234567Array.prototype.indexOf(searchValue, startIndex?)// 从startIndex开始查找searchValue，返回第一次出现的位置，没有找到返回-1。若缺少startIndex查找整个数组。// 查找使用严格相等Array.prototype.lastIndexOf(searchElement, startIndex?)// 从startIndex反向查找searchValue返回第一次出现的索引，若没有找到返回-1，缺少startIndex查找整个数组// 查找使用严格相等 迭代（非破坏性地）检查方法1234567891011121314arr.examinationMethod(callback, thisValue?)function callback(element, index, array)thisValue可以配置callback内的thisArray.prototype.forEach(callback, thisValue?)Array.prototype.every(callback, thisValue?) // 若对于每个元素回调函数都返回true则返回true，一旦返回false则停止迭代，返回false// undefined也会被解释成false// 如果数组是空的，结果是true，且不调用callbackArray.prototype.some(callback, thisValue?) // 至少一个返回true则返回true，若回调函数返回true则停止迭代// undefined也会被解释成false// 如果数组是空的，结果是false，且不调用callback 转化方法12345Array.prototype.map(callback, thisValue?)// 对每个元素应用callback的结果Array.prototype.filter(callback, thisValue?)// 返回callback为true的元素 归约函数123456789101112callback函数有所不同function callback(previousValue, currentElement, currentIndex, array)// previousValue 是会掉函数返回之前的值// 提供显式initialValue，previousValue是initialValue，currentElement是数组第一个元素(reduceRight: 数组最后一个元素)// 未提供显式initalValue，previousValue是数组第一个元素，currentElement是数组第二个元素(reduceRight: 数组最后一个和倒数第二个元素)Array.prototype.reduce(callback, initialValue?)// 从左到右遍历，返回回调函数最后的值Array.prototype.reduceRight(callback, initialValue?)// 从右到左遍历，返回回调函数最后的值 正则表达式test()exec()replace() Math标准库参考 《深入理解JavaScript》]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记]]></title>
    <url>%2F2018%2F11%2F17%2Fnote-css%2F</url>
    <content type="text"><![CDATA[CSS12&lt;!-- --&gt; HTML注释/* */ CSS注释 基本语法1234选择器 &#123; 属性1:属性值1; ...&#125; 元素选择器1234元素选择器 &#123; 属性1:属性值1; ...&#125; ID选择器1234#ID选择器 &#123; 属性1:属性值1; ...&#125; 类选择器1234.类选择器 &#123; 属性1:属性值1; ...&#125; 多类选择器1234.类选择器1.类选择器2... &#123; 属性1:属性值1; ...&#125; 伪类选择器1234选择器:伪类 &#123; 属性1:属性值1; ...&#125; 伪类1234567:active 被激活的元素:hover 鼠标悬浮元素上方:link 未被访问的链接:visited 被访问的链接:focus 被选中的元素:first-child 每一层元素指定类型的第一个子元素:lang 带有指定lang属性的元素 伪元素选择器1234选择器:伪元素 &#123; 属性1:属性值1; ...&#125; 伪元素1234:first-letter 文本第一个字符:first-line 文本首行:before 选择器选择元素之前:after 选择器选择元素之后 通用选择器1234* &#123; 属性1:属性值1; ...&#125; 交集选择器样式重叠 都具有1234元素选择器.类选择器 | #ID选择器 &#123; 属性1:属性值1; ...&#125; 并集选择器集体声明123456选择器1,选择器2,... &#123; 属性1:属性值1; ...&#125; 后代选择器1234选择器1 选择器2 ... &#123; 属性1:属性值1; ...&#125; 子元素选择器1234选择器1&gt; 选择器2 &#123; 属性1:属性值1; ...&#125; 相邻兄弟选择器1234选择器1+选择器2 &#123; 属性1:属性值1; ...&#125; 属性选择器1234属性选择器1属性选择器2... &#123; 属性1:属性值1; ...&#125; 常见属性选择器1234567[属性] 带有指定属性的元素[属性=值] 带有指定属性和值的元素[属性~=值] 属性值包含指定值的元素，完整单词[属性|=值] 属性值以指定值开头，完整单词或后带有&apos;-&apos;连接符[属性^=值] 属性值以指定值开头的元素[属性$=值] 属性值以指定值结尾的元素[属性*=值] 属性值中包含指定值的元素 应用到HTML的方式 行内式&lt;标签名 style=&quot;属性名1:属性值1;...&quot; ...&gt; 内嵌式 123456&lt;style type=&quot;text/css&quot;&gt;选择器 &#123; 属性1:属性值1; ...&#125;&lt;/style&gt; 链接式 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;*.css&quot; /&gt;]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F11%2F17%2Fnote-html%2F</url>
    <content type="text"><![CDATA[这1k多行的Markdown我大概写了一个多月，差不多俩月qwq 结构基本标记标签文档类型声明1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHRML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; HTML51&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;/html&gt;&lt;head&gt;&lt;/head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta&gt; 文档元数据1&lt;meta htt[-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=字符集&quot;&gt; HTML51&lt;meta charset=&quot;字符集&quot;&gt; 关键字1&lt;meta name=&quot;keywords&quot; contenet&quot; , , , &quot;&gt; 网页描述信息1&lt;meta name=&quot;discription&quot; content=&quot;网页描述信息&quot;&gt; &lt;body&gt;&lt;/body&gt;html注释&lt;!-- --&gt; 字体字体粗细1font-weight: normal | bold | bolder | number(100,900) | inherit; 字体风格1font-style: normal | italic | oblique | inhert; italic | oblique 均为倾斜字体 常用 italic 字体大小1font-size: medium | length | n% | inherit; length: px | pt | em 字体族属性1font-family: 字体族1,字体族2,...,通用字体族 |inherit; 行高1line-height: normal | number | length | n% | inherit 字体属性1font: [font-style][font-weihgt] font-size/line-height font-family; []内的可没有 其他属性必须有 并且/不可省略 文本属性颜色1color: 颜色英文名 | 颜色十六进制 | RGB | inherit; 一种省略表示方式：RGB3位全相同可只写3位 水平对齐属性1text-align: left | right | center | inherit; 首行缩进属性1text-indent: length | n% | inherit; 文本修饰属性12text-decoration: none | underline | overline | line-through | inherit;无修饰 | 下划线 | 上划线 | 删除线 | 继承父属性 字符间距属性1letter-spacing: normal | length |inherit; 字间距属性1word-spacing: normal | length | inherit; 背景属性背景颜色属性1background-color: 英文单词 | RBG | transparent | inherit; 背景图片属性1background-image: url(image_file_path) | inherit; 背景图片重复属性1background-repeat: repeat | repeat-x | repeat-y | no-repeat | inherit; 背景图片位置属性12background-position: 表示位置的关键字 | x% y% | xpos ypos;关键字 top/center/bottom left/center/right; 背景图片滚动属性12background-attachment: scroll | fixed | inherit;默认值滚动 | 背景图片不滚动 | 继承父属性 背景属性1background: background-color | background-image[ | background-position | background-repeat | background-attachment ] 盒子模型边框风格属性 12345border-styleborder-bottom-styleborder-left-styleborder-right-styleborder-top-style 语法 12border-style: style [style] [style] [style] [style];border-方向-style: style [style] [style] [style]; 参数值 12345678910none 无边框dotted 点dashed 虚线solid 实线double 双实线groove 3D凹槽ridge 3D垄状inset 内嵌立体边框outset 外嵌立体边框inherit 继承父元素 1个值时设置4个方向2个值时上下/左右3个值时上/左右/下4个值时上/右/下/左 边框宽度12345border-widthborder-bottom-widthborder-left-widthborder-right-widthborder-top-width 语法 12border-width: width_value [width_value] [width_value] [width_value] | inherit;border-方向-width: width_value [width_value] [width_value] [width_value] | inherit; 边框颜色12345border-colorborder-bottom-colorborder-left-colorborder-right-colorborder-top-color 语法 12border-color: color_value [color_value] [color_value] [color_value] | inherit;border-方向-color: color_value [color_value] [color_value] [color_value] | inherit; 边框属性12345borderborder-bottomborder-leftborder-rightborder-top 形状三角形 123456div &#123; width:0; height:0; border: 20px solid #fff; border-left-color: #ff594f;&#125; 盒子内边距12345paddingpadding-bottompadding-leftpadding-rightpadding-top 12padding: padding_value [padding_value] [padding_value] [padding_value];padding-方向: padding_value [padding_value] [padding_value] [padding_value]; 1234autolength%inherit padding会撑开元素大小 盒子外边距12345marginmargin-bottommargin-leftmargin-rightmargin-top 12margin: margin_value [margin_value] [margin_value] [margin_value];margin-方向: margin_value [margin_value] [margin_value] [margin_value]; 1234autolength%inherit 外边距合并 标签段落&lt;p align=&quot;left/right/center&quot;&gt;段落内容&lt;/p&gt; 换行&lt;br /&gt; 标题&lt;hn [align=&quot;&quot;]&gt;标题&lt;/hn&gt; (n=1,2,3,4,5,6) 强调&lt;strong&gt;文本&lt;/strong&gt;文本 &lt;em&gt;文本&lt;/em&gt;文本 &lt;mark&gt;文本&lt;/mark&gt;文本 时间&lt;time datetime=&quot;2018-10-15 23:23&quot;&gt;晚上11点&lt;/time&gt;晚上11点 &lt;time pubdate&gt;2018-10-15 23:23&lt;/time&gt;2018-10-15 23:23 装饰性标签&lt;span&gt;文本&lt;/span&gt;文本 特殊字符 特殊符号 字符实体 空格 &amp;nbsp; &quot; &amp;quot; &amp; &amp;amp; &lt; &amp;lt; &gt; &amp;gt; &middot; &amp;middot; &times; &amp;times; &sect; &amp;sect; &cent; &amp;cent; &yen; &amp;yen; &pound; &amp;pound; &copy; &amp;copy; &reg; &amp;reg; &trade; &amp;trade; 文档结构标签&lt;header&gt;标签一般放置 站点名称、Logo、导航栏、搜索栏、内容区域标题、作者、发布日期。 注意: 可以做为网页或任何元素头部信息 无个数限制 不能嵌套&lt;header&gt;和&lt;footer&gt; &lt;article&gt;标签&lt;article&gt;独立内容&lt;/article&gt; &lt;section&gt;标签分块&lt;section&gt;块内容&lt;/section&gt; &lt;main&gt;标签主体内容 不可重复出现&lt;main&gt;主体内容&lt;/main&gt; &lt;nav&gt;标签&lt;nav&gt;导航条&lt;/nav&gt; &lt;aside&gt;标签侧边栏&lt;aside&gt;导航条&lt;/aside&gt; 多媒体标签&lt;object&gt;标签 IE9/IE8/IE7/IE6 123456&lt;object classid=&quot;clsid_value&quot; codebase=&quot;url&quot; width=&quot;value&quot; height=&quot;value&quot;&gt; &lt;param name=&quot;movie&quot; value=&quot;fail_name&quot;&gt; &lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt; &lt;param name=&quot;wmode&quot; value=&quot;opaque&quot;&gt; ...&lt;/object&gt; IE 10/11 not IE 123456789101112&lt;object classid=&quot;clsid_value&quot; codebase=&quot;url&quot; width=&quot;value&quot; height=&quot;value&quot;&gt; &lt;param name=&quot;movie&quot; value=&quot;fail_name&quot;&gt; &lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt; ... &lt;!--[if !IE]&gt;--&gt; &lt;object type=&quot;media_type&quot; data=&quot;media_fileName&quot; width=&quot;value&quot; height=&quot;value&quot;&gt; &lt;!--&lt;!endif]--&gt; ... &lt;!--[if !IE]&gt;--&gt; &lt;/object&gt; &lt;!--&lt;![endif]--&gt;&lt;/object&gt; 属性 描述 classid 设置浏览器ActiveX控件 codebase 设置ActiveX控件的位置，如果浏览器没安装会自动下载安装 data 在嵌套的object标签中指定嵌入多媒体文件名 type 嵌套的object标签中这是媒体类型，对动画类型是 application/x-shockwave-flash height 以百分比或限速指定嵌入对象高度 width 以百分比或限速指定嵌入对象宽度 name 设置参数名称 value 设置参数值 movie 指定动画的下载地址 quality 指定嵌入对象的播放质量 wmode 设置嵌入对象窗口模式，可取 window/opaque/transparent，其中，window为默认值，表示嵌入对象始终位于HTML顶层，opaque允许嵌入对象上层可以有网页遮挡，transparent 设置 flash背景透明 &lt;embed&gt;标签用于Netscape Navigator2.0及以后的浏览器包括IE, Chrome,firefox不支持语法 1&lt;embed src=&quot;file_url&quot;&gt; &lt;/embed&gt; 属性 描述 src 文件路径文件类型可以为mp3,mp4,swf width 以像素为单位定义嵌入对象宽度 height 以像素为单位定义嵌入对线高度 loop 定义嵌入对象是否循环播放,true为循环播放,默认为false hidden 设置嵌入对象可视属性,默认false可见 type 定义嵌入对象MIME类型 &lt;video&gt;标签支持HTML5的可以用&lt;video&gt; &lt;audio&gt;代替前两个标签 语法 1&lt;video src=&quot;file_url&quot;&gt;&lt;/video&gt; 属性 描述 src 指定嵌入对象文件路径 autoplay 嵌入对象在加载页面后自动播放 controls 出现该属性则向用户显示控件 preload 设置视频在页面加载时进行加载，并预备播放，如果同时设置了autoplay则该属性无效 muted 音频输出静音 width 以像素为单位定义嵌入对象宽度 height 以像素为单位定义嵌入对线高度 loop 定义嵌入对象是否循环播放,true为循环播放,默认为false hidden 设置嵌入对象可视属性,默认false可见 poster 设置视频下载时显示的图像，或者在用户单击播放按钮前显示的图像 type 定义嵌入对象MIME类型 &lt;audio&gt;标签嵌入音频格式包括 mp3,wav,ogg,webm 语法 1&lt;audio src=&quot;file_url&quot; control&gt; &lt;/audio&gt; 属性 描述 src 指定嵌入对象文件路径 autoplay 嵌入对象在加载页面后自动播放 controls 出现该属性则向用户显示控件 preload 设置视频在页面加载时进行加载，并预备播放，如果同时设置了autoplay则该属性无效 muted 音频输出静音 width 以像素为单位定义嵌入对象宽度 height 以像素为单位定义嵌入对线高度 loop 定义嵌入对象是否循环播放,true为循环播放,默认为false hidden 设置嵌入对象可视属性,默认false可见 type 定义嵌入对象MIME类型 元素类型block块级元素特点 独占一行 不设置宽度时自动撑满父元素宽度 和相邻的块级元素依次垂直排列 可设置元素宽度高度和四个方向内外边距 常见的div,o,h1~h6,ul,ol,dt,ddHTML5中section,header,footer,nav inline行内元素特点 行内元素从左到右依次排列在同一行里，直到排不下 不可设置宽度高度 可以设置四个方向内边距及左右外边距，不可设置上下外边距 高度由元素高度决定，宽度由内容长度控制。 常见span,a,em,strongHTML5中mark,time inline-block行内块元素特点 从左到右排列在同一行，直到排不下才换行 可以设置高度和宽度 可以设置4个方向内外边距 常见 input,img 问题 浏览器兼容问题低版本失效(解决方法:display:inline;zoom:1;) 默认下方有间隙(解决方法:给行内块元素设置vertical-align:middle|top|bottom之一) 使用display属性改变元素类型 属性 描述 none 不显示 block 显示为块级元素 inline 显示为行内元素 inline-block 显示为行内块级元素 inherit 继承父级元素display属性 使用CSS reset标签样式重置标签默认样式，防止浏览器默认样式不同。 图片常用格式JPEG,GIF,PNG 插入图片基本语法1&lt;img src=&quot;file_url&quot;&gt; 属性 描述 alt 指定图片的替换信息 height 高度 width 宽度 title 提示信息 border,align属性建议使用CSS设置 取消小空隙 设置父元素高度 添加垂直对齐样式 使用CSS设置样式vertical-align: align_value; 参数 描述 length 以px,em为单位,可取正负值。正值表示相对于基线升高的，负值表示相对于基线降低的 % 相对于继承的line-height百分数，可取正负值，同上。 baseline 默认对齐方式，基线与父元素基线对齐 bottom 底端对齐 text-bottom 底部与父元素文本底部对齐 middle 居中对齐 top 顶部对齐 text-top 顶部与文本对齐 列表有序列表语法 12345&lt;ol&gt; &lt;li&gt;p_1&lt;/li&gt; &lt;li&gt;p_2&lt;/li&gt; ...&lt;/ol&gt; 项目符号&lt;ol type=&quot; &quot;&gt; 参数 描述 1 1,2,3 a a,b,c A A,B,C i i,ii,iii I I,II,III 无序列表语法 12345&lt;ul&gt; &lt;li&gt;p_1&lt;/li&gt; &lt;li&gt;p_2&lt;/li&gt; ...&lt;/ul&gt; 项目符号&lt;ul type=&quot;&quot;&gt; 参数 描述 disc 实心圆点(默认) circle 空心圆点 squatr 实心方块 定义列表语法 123456789&lt;dl&gt;&lt;dt&gt;noun_1&lt;/dt&gt; &lt;dd&gt;explain_1&lt;/dd&gt; &lt;dd&gt;explain_2&lt;/dd&gt; ...&lt;dt&gt;noun_2&lt;/dt&gt; &lt;dd&gt;explain_1&lt;/dd&gt; ...&lt;/dl&gt; 无项目符号 使用CSS列表属性设置列表样式 属性 参数 描述 list-style 其他任意列表参数 简写属性 disc 实心圆点 circle 空心圆点 square 实心方块 decimal 阿拉伯数字 list-style-type lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写英文字母 upper-alpha 大写英文字母 none 无项目符号 创建横纵菜单横向菜单注意设置display:inline;注意取消边框线、项目符号 display:inline-block;可以设置图文横向排列 链接a标签 属性 描述 href 链接路径 target 目标窗口 title 链接提示信息 语法1&lt;a href=&quot;url&quot;&gt; text/images &lt;/a&gt; href 参数 描述 “”(无内容) 跳转到页面顶部(search) # 跳转到页面顶部(hash) javascript:…; 执行javascript脚本 URL 跳转到指定页面 target 参数 描述 _blank 新开窗口打开 _self 同窗口/框架下打开(默认) _parent 上一级窗口打开 _top 在浏览器整个窗口打开 框架名称 指定浮动框架窗口打开 基准URL路径前共同部分可以使用基准URL+相对路径的形式 基本语法1&lt;base href=&quot;..&quot; target=&quot;..&quot; /&gt; 链接类型内部链接 外部链接 URL格式 描述 http:// 万维网 mailto: 启动邮件发送系统 ftp:// 文件传输服务器 telnet:// 启动远程登录方式 news:// 启动新闻讨论组 书签链接HTML5中用id创建书签创建书签链接&lt;a href=&quot;#name&quot;&gt; origin &lt;/a&gt;&lt;a href=&quot;file_url#name&quot;&gt; origin &lt;/a&gt; 脚本链接 文件下载链接 文本链接 图像链接 图像映射 基本语法1234567&lt;img src=&quot;img_url&quot; usemap=&quot;#map_name&quot;&gt;&lt;map name=&quot;map_name&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;x1,y1,x2,y2&quot; href=&quot;URL&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;x,y,r&quot; href=&quot;URL&quot;&gt; &lt;area shape=&quot;poly&quot; coords=&quot;x1,y1,x2,y2,x3,y3,...&quot; href=&quot;URL&quot;&gt; ...&lt;/map&gt; 标签usemap用于激活映射 标签定义图像映射中包含热点映射 标签用于图像映射中定义一个热区,包含3个必要属性:href,shape,coords href属性设置热区链接 shape设置热区形状 coords设置热区坐标 shape coords 描述 rect x1,y1,x2,y2 左上 右下 circle x,y,r 圆心半径 poly x1,y1,x2,y2… 各个顶点坐标按照单击先后顺序 伪类设置链接样式伪类类型:link,:visited,:hover,:active未访问、访问后、鼠标悬停、活动状态 链接内联框架语法&lt;iframe src=&quot;source_url&quot;&gt;...&lt;/iframe&gt; 属性 参数 描述 src file_url 文档地址 height px,% 高度 width px,% 宽度 name frame_name 名字 frameborder 1,0 是否显示边框 marginheight px 顶部底部边距 marginwidth px 左右边距 网页表格表格标签 标签 描述 &lt;table&gt; 定义表格 &lt;caption&gt; 定义表格标题 &lt;tr&gt; 定义表格行 &lt;th&gt; 定义表格表头 &lt;td&gt; 定义表格单元格 &lt;thead&gt; 定义表格页眉 &lt;tbody&gt; 定义表格主体 &lt;tfoot&gt; 定义表格页脚 &lt;table&gt;标签 属性 参数 描述 align left,center,right 水平对齐方式,默认左对齐 border px 边框宽度,默认为0 bgcolor #xxxxxx,rgb(x,x,x),colorname 背景颜色 cellpadding px 单元格间距,数据与边框 cellspcing px 单元格边距,单元格与单元格 height px,% 表格高度 width px,% 表格宽度 注意HTML5中以上属性不再支持，建议使用CSS格式化表格 &lt;tr&gt;标签 属性 参数 描述 align left,center,right 水平对齐方式,&lt;td&gt;默认左对齐,&lt;th&gt;默认居中对齐 bgcolor #xxxxxx,rgb(x,x,x),colorname 行背景颜色 height px,% 表格行高度 valign baseline,top,middle,bottom 垂直对齐方式,默认居中对齐 &lt;td&gt; &amp; &lt;th&gt;标签 属性 参数 描述 align left,center,right 水平对齐方式,&lt;td&gt;默认左对齐,&lt;th&gt;默认居中对齐 bgcolor #xxxxxx,rgb(x,x,x),colorname 背景颜色 colspan number 单元格横跨列数 rowspan number 单元格横跨行数 height px,% 单元格高度 width px,% 大暖格宽度 valign baseline,top,middle,bottom 垂直对齐方式,默认居中对齐 &lt;caption&gt;标签 属性 参数 描述 align left,center,right 设置水平对齐方式,默认center valign top,bottom 设置垂直对齐方式,默认top &lt;thead&gt;,&lt;tbody&gt;,&lt;tfoot&gt;标签分区 表格标签属性格式化表格CSS表格属性下面代码不是Markdown语法咯，自己练练HTML表格 CSS表格属性 属性 参数 描述 border-collase separate 默认值,表格边框和单元格边框会分开 collapse 表格边框和单元格边框会合并为单一边框 border-spacing length[length] 相邻单元格边框之间距离，单位可取px,cm，定义一个参数则为水平垂直间距，两个参数则为水平和垂直间距 caption-side top 默认值，标题显示在表格上面 bottom 标题在表格下面 table-layout automatic 默认值，单元格宽度由内容决定 fixed 单元格宽度由表格宽度和单元格宽度决定 CSS格式化表格 属性 参数 描述 top 单元格内容与上边框靠近 vertical-align middle 默认值,垂直居中 bottom 与下边框靠近 inherit 继承父元素 display属性值 标签 display属性设置 描述 &lt;table&gt; display:table 块级表格，表格前后带换行符 &lt;caption&gt; display:table-caption 表格标题 &lt;thead&gt; display:table-header-group 分组显示 &lt;tbody&gt; display:table-row-group 分组显示 &lt;tfoot&gt; display:table-footer-group 分组显示 &lt;tr&gt; display:table-row 表格行 &lt;th&gt;,&lt;td&gt; display:table-cell 表格单元格 表单概述 标签 描述 &lt;form&gt; 定义一个表单区域 &lt;input&gt; 定义输入表单元素 &lt;select&gt; 定义列表元素 &lt;option&gt; 定义列表元素中的项目 &lt;textarea&gt; 定义表单文本域元素 &lt;lable&gt; 定义输入元素标签 &lt;button&gt; 定义按钮 &lt;form&gt;标签语法123&lt;form name=&quot;..&quot; method=&quot;the way of submitting&quot; action=&quot;program&quot;&gt; ...&lt;/form&gt; 属性 描述 name 表单名称 method 定义表单数据从客户端传送到服务器方法,包括get和post,默认get action 用于指定处理表单服务端程序 onsubmit 用于指定处理表单的脚本函数 enctype 设置MIME类型，默认值application/x-www-form-urlencoded;需要上传到服务器时应设为multipart/form-data target 规定何处打开action URL,包括_black,_self,_parent,_top,_framename input表单控件语法1&lt;input type=&quot;..&quot; name=&quot;..&quot;&gt; 属性 描述 text 设置但行文本框元素 password 设置密码元素 file 设置文件元素 hidden 设置隐藏元素 radio 设置单选框元素 checkbox 设置复选框元素 button 设置普通按钮元素 submit 设置提交按钮元素 reset 设置重置按钮元素 文本框语法1&lt;input type=&quot;text&quot; name=&quot;..&quot;&gt; 文本框其他属性 属性 描述 name 设置名称 maxlength 最多可输入字符数 size 文本框长度,单位px,默认20px value 设置文本框默认值 密码框语法1&lt;input type=&quot;password&quot; name=&quot; &quot;&gt; 和文本框属性相同 隐藏域用于传递实体id的值1&lt;input type=&quot;hidden&quot; name=&quot;..&quot; value=&quot;..&quot;&gt; 文件域1&lt;input type=&quot;file&quot; name=&quot;..&quot;&gt; 将本地文件上传至服务器 单选框和复选框单选框1&lt;input type=&quot;radio&quot; name=&quot;..&quot; value=&quot;..&quot; checked=&quot;checked&quot;&gt; checked:默认选中或不选中 复选框1&lt;input type=&quot;checkbox&quot; name=&quot;..&quot; value=&quot;..&quot; checked=&quot;checked&quot;&gt; 提交按钮1&lt;input type=&quot;submit&quot; name=&quot;..&quot; value=&quot;..&quot;&gt; 普通按钮1&lt;input type=&quot;button&quot; value=&quot;..&quot; onclick=&quot;javascriptfucation&quot; name=&quot;..&quot;&gt; 重置按钮1&lt;input type=&quot;reset&quot; name=&quot;..&quot; value=&quot;..&quot;&gt; 图像按钮1&lt;input type=&quot;image&quot; name=&quot;..&quot; src=&quot;..&quot; alt=&quot;..&quot; width=&quot;..&quot; height=&quot;..&quot;&gt; button元素按钮1&lt;button type=&quot;submit|button|reset&quot; name=&quot;..&quot; value=&quot;..&quot;&gt; text|images|.. &lt;/button&gt; label标签可以通过单击标签来进行选择 &lt;label&gt;..&lt;/label&gt; 显式联系&lt;label for=&quot;id&quot;&gt;..&lt;label&gt; 选择列表 标签 属性 描述 select name 列表名称 select size 定义同时显示的列表项数,默认为1,取值大于等于1 select multiple 定义列表选项可多选 option value 设置选项值 option selected 设置默认选项 多行文本域123&lt;textarea name=&quot;..&quot; rows=&quot;..&quot; cols=&quot;..&quot;&gt; ..&lt;/textarea&gt; 令文本域不能扩大缩小 CSS代码123textarea &#123; resize:none;&#125; 表单元素的disabled 和 readonly属性在标签内加上readonly|disable或readonly|disable=truereadonly可被提交disable不可以 form 属性表明隶属关系不必放在&lt;form&gt;&lt;/form&gt;之间 formaction 属性12&lt;input type=&quot;submit|image&quot; formaction=&quot;.jsp&quot;&gt;&lt;button type=&quot;submit&quot; formaction=&quot;.jsp&quot;&gt; autofocus 属性仅有一个设置 1234567&lt;input type=&quot;text&quot; autofocus/&gt;or&lt;input type=&quot;text&quot; autofocus=&quot;true&quot;/&gt;&lt;textarea rows=&quot;&quot; cols=&quot;&quot; autofocus&gt;...&lt;/textarea&gt;or&lt;textarea rows=&quot;&quot; cols=&quot;&quot; autofocus=&quot;true&quot;&gt;...&lt;/textarea&gt; pattern 属性验证属性 正则表达式 1&lt;input type=&quot;text&quot; pattern=&quot;code&quot; title=&quot;error note&quot;/&gt; placeholder 属性输入信息提示信息自动消失，清空显示 12&lt;input type=&quot;text&quot; placeholder=&quot;note&quot;&gt;&lt;textarea rows=&quot;&quot; cols=&quot;&quot; placeholder=&quot;note&quot;&gt; required 属性判断是否为空 123&lt;input type=&quot;&quot; name=&quot;...&quot; required&gt;or&lt;input type=&quot;&quot; name=&quot;...&quot; required=&quot;true&quot;&gt; textarea select也可设置该属性 outline 轮廓线 属性 参数 描述 outline 声明同时设置各属性，之间空一格:outline-color outline-style outline-width 简写属性 none inherit outline-color 同border-color 设置轮廓线颜色，当outline-style不为none才有效，默认transparent outline-style 同border-style 轮廓风格，默认为none outline-width 同border-width 轮廓线宽度，默认为medium，outline-style不为none时有效 美化浮动定位参考 《前端HTML+CSS修炼之道》]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim笔记]]></title>
    <url>%2F2018%2F11%2F16%2Fnote-vim%2F</url>
    <content type="text"><![CDATA[修改vi/vim配置永久修改vi/vim配置 1vi ~/.vimrc 编辑器设置 Option Description :set number 显示行号 :set nonumber 不显示行号 :set tabstop 设置制表符长度 :set ruler 显示标尺 :set wrap 自动折行 :set nowrap 不自动折行 :set autoindent 首行缩进 :set ignorecase 关闭大小写敏感 :set nomagic 关闭特殊字符’*’’?’等 :set showmode 显示模式 :set showmatch 显示匹配的括号 :set wrapscan 文本循环 find string/string 从上往下搜索 ?string 从下往上搜索 可用正则表达式 ab Command设置缩写 1:ab &lt;string1&gt; &lt;string2&gt; string1代表string2 map Command]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AddBall]]></title>
    <url>%2F2018%2F11%2F15%2Fjs-addball%2F</url>
    <content type="text"><![CDATA[//canvas var cnv = document.getElementById("cnv1"); var ctx = cnv.getContext("2d"); //define ball var ball = { x : [], y : [], xSpeed : [], ySpeed : [] }; ball.add = function(a=Math.random()*400,b=Math.random()*400) { this.x.push(a); this.y.push(b); this.xSpeed.push(Math.random()*3); this.ySpeed.push(Math.random()*3); }; ball.draw = function() { for(var i=0;i]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>canvas</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScriptPainting]]></title>
    <url>%2F2018%2F11%2F14%2Fjs-JavaScriptPainting%2F</url>
    <content type="text"><![CDATA[Now,let’s start painting!Ususally,the numbers are starting from 0, what will happen if you press 0? Have a try. var cvs = document.getElementById("cvs1"); var ctx = cvs.getContext("2d"); var mg3 = prompt("What do you want to draw? Enter 1 to draw a rectangle;2 to draw a strokerectangle;3 to draw a triangle;4 to draw a cross;5 to draw two circles;6 to draw a Gomokuboard;7 to draw a Chessboard;...to be continue..."); if(mg3 === "0") { ctx.fillStyle = "#000000"; ctx.strokeStyle = "#000000"; ctx.lineWidth = 4; //draw a circle ctx.beginPath(); ctx.arc(200,200,190,0,2*Math.PI,false); ctx.stroke(); //draw the smile ctx.beginPath(); ctx.arc(200,200,160,(0.1)*Math.PI,(0.9)*Math.PI,false); ctx.stroke(); //left eye ctx.beginPath(); ctx.arc(100,400,250,(1.42)*Math.PI,(1.58)*Math.PI,false); ctx.stroke(); ctx.beginPath(); ctx.arc(100,420,250,(1.42)*Math.PI,(1.58)*Math.PI,false); ctx.stroke(); ctx.beginPath(); ctx.arc(100-250*Math.sin(0.08*Math.PI),400+10-250*Math.cos(0.08*Math.PI),10,0,2*Math.PI,false); ctx.fill(); ctx.beginPath(); ctx.arc(100+250*Math.sin(0.08*Math.PI),400+10-250*Math.cos(0.08*Math.PI),10,-0.5*Math.PI,0.5*Math.PI,false); ctx.stroke(); //right eye ctx.beginPath(); ctx.arc(300,400,250,(1.42)*Math.PI,(1.58)*Math.PI,false); ctx.stroke(); ctx.beginPath(); ctx.arc(300,420,250,(1.42)*Math.PI,(1.58)*Math.PI,false); ctx.stroke(); ctx.beginPath(); ctx.arc(300-250*Math.sin(0.08*Math.PI),400+10-250*Math.cos(0.08*Math.PI),10,0,2*Math.PI,false); ctx.fill(); ctx.beginPath(); ctx.arc(300+250*Math.sin(0.08*Math.PI),400+10-250*Math.cos(0.08*Math.PI),10,-0.5*Math.PI,0.5*Math.PI,false); ctx.stroke(); } else if(mg3 === "1") { ctx.fillStyle = "#FF0000" ctx.fillRect(100,100,100,100); } else if(mg3 === "2") { ctx.strokeStyle = "#FF0000" ctx.strokeRect(100,100,100,100); } else if(mg3 === "3") { ctx.fillStyle = "Blue"; ctx.beginPath(); ctx.moveTo(50,50); ctx.lineTo(350,50); ctx.lineTo(200,300); ctx.fill(); } else if(mg3 === "4") { ctx.strokeStyle = "#FF0000"; ctx.beginPath(); ctx.moveTo(50,50); ctx.lineTo(150,150); ctx.moveTo(50,150); ctx.lineTo(150,50); ctx.stroke(); } else if(mg3 === "5") { ctx.skrokeStyle = "#FF0000"; ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.arc(50,50,30,0,Math.PI*2,false); ctx.stroke(); ctx.beginPath(); ctx.arc(150,50,30,0,Math.PI*2,false); ctx.fill(); } else if(mg3 === "6") { ctx.fillStyle = "#000000"; ctx.strokeStyle = "#000000"; ctx.lineWidth = 1; for(var i=0;i]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20181114]]></title>
    <url>%2F2018%2F11%2F14%2F20181114%2F</url>
    <content type="text"><![CDATA[JavaScriptTest var mg1 = prompt("Enter Your Name:"); var mg2 = confirm("Are You " + mg1.toString()); if(mg2) { alert("Hello " + mg1.toString()); } else { alert("You are just fucking kiding me!"); }]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20181113]]></title>
    <url>%2F2018%2F11%2F13%2F20181113%2F</url>
    <content type="text"><![CDATA[我终于装好了MathJax！！！！！！！！！！ 曲率 $ K=\frac {|y’’|} {(1+y’^2)^{\frac {3}{2}}} $s]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F11%2F13%2Ftest-HelloWorld%2F</url>
    <content type="text"><![CDATA[This is my first blog page.And I just for test. [toc] Markdown TestH1H2H3H4CodeTest1234567#include &lt;iostream&gt;using namespce std;int main() &#123; cout &lt;&lt; "HelloWorld" &lt;&lt;endl; return 0;&#125; 1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf8"&gt; &lt;title&gt;???&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="2.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt;qwq&lt;/div&gt; &lt;div id="div2"&gt;QAQ&lt;/div&gt; &lt;p&gt;&lt;time pubdate&gt;2018-10-15 23:23&lt;/time&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; MathJaxTest$ \sqrt {256} $ \begin{eqnarray} \nabla\cdot\vec{E} &=& \frac{\rho}{\epsilon_0} \\ \nabla\cdot\vec{B} &=& 0 \\ \nabla\times\vec{E} &=& -\frac{\partial B}{\partial t} \\ \nabla\times\vec{B} &=& \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right) \end{eqnarray}]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F11%2F13%2Ftest-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
</search>
